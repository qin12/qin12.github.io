<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Language" content="zh-cn">
    <meta charset="utf-8">
    
    
    
    <title>qin12的学习博客 | 只为成功找方法，不为失败找借口！</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
    
    <meta name="theme-color" content="#77AAFF">
    
    
    <meta name="keywords" content="">
    
    

    

    <!-- Baidu Push -->
<script>
	(function(){
		var bp = document.createElement('script');
		var curProtocol = window.location.protocol.split(':')[0];
		if (curProtocol === 'https') {
			bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
		}
		else {
			bp.src = 'http://push.zhanzhang.baidu.com/push.js';
		}
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(bp, s);
	})();

	var _hmt = _hmt || [];
</script>



    
    <meta name="description" content="漫漫长路，伴你同行">
<meta property="og:type" content="website">
<meta property="og:title" content="qin12的学习博客">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="qin12的学习博客">
<meta property="og:description" content="漫漫长路，伴你同行">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="qin12的学习博客">
<meta name="twitter:description" content="漫漫长路，伴你同行">
    
        <link rel="alternate" type="application/atom+xml" title="qin12的学习博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link id="style" rel="stylesheet" href="/css/style.css?v=3.0">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    
            
</head>

<body>
    <div id="loading" class="active"></div>
    <aside id="menu"   >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" >
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg" alt="avatar">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname" id="name">Qgx</h5>
          
            <div id="yiyanmotto" class="motto">&nbsp;</div>
          
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
              <li class="waves-block waves-effect">
                  <a href="/"  >
                    <i class="icon icon-lg icon-home"></i>
                    <span>主 页</span><i class="icon icon-lg icon-caret-left"></i>
                  </a>
              </li>
            
              <li class="waves-block waves-effect">
                  <a href="/archives/"  >
                    <i class="icon icon-lg icon-archives"></i>
                    <span>归 档</span><i class="icon icon-lg icon-caret-left"></i>
                  </a>
              </li>
            
              <li class="waves-block waves-effect">
                  <a href="/categories/"  >
                    <i class="icon icon-lg icon-th-list"></i>
                    <span>分 类</span><i class="icon icon-lg icon-caret-left"></i>
                  </a>
              </li>
            
              <li class="waves-block waves-effect">
                  <a href="/tags/"  >
                    <i class="icon icon-lg icon-tags"></i>
                    <span>标 签</span><i class="icon icon-lg icon-caret-left"></i>
                  </a>
              </li>
            
              <li class="waves-block waves-effect">
                  <a href="/about"  >
                    <i class="icon icon-lg icon-smile-o"></i>
                    <span>关 于</span><i class="icon icon-lg icon-caret-left"></i>
                  </a>
              </li>
            
      <div class="nav2">
          
              <a class="nav2item" data-title="Email" href="mailto:1520290900@qq.com" target="_parent"title="Email" >
                <i class="icon icon-lg icon-envelope-o envelope-o"></i>
              </a>
          
              <a class="nav2item" data-title="Github" href="https://github.com/qin12" target="_blank"title="Github" >
                <i class="icon icon-lg icon-github github"></i>
              </a>
          
              <a class="nav2item" data-title="微博" href="https://weibo.com/u/6415480382" target="_blank"title="微博" >
                <i class="icon icon-lg icon-weibo weibo"></i>
              </a>
          

            </div>
        
      </ul>
        
    </div>
  </div>
 
</aside>


    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">qin12的学习博客</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        <a href="../../atom.xml" target="_blank" class="header-icon waves-effect waves-circle waves-light" id="Rss">
            <i class="icon icon-lg icon-rss"></i>
        </a>
    </div>
</header>
<header class="content-header index-header">
    
    
    <div class="container fade-scale">
        <div id="myheader">
            <h1 class="title">
                 
                    qin12的学习博客
                
            </h1>
            <h5 class="subtitle">
                
                    业精于勤荒于嬉，行成于思毁于随
                
            </h5>
        </div>
    </div>

</header>

<div class="container body-wrap">
    <ul class="post-list">
    
        <li class="post-list-item fade">
            <article id="post-原型模式"
  class="article-card article-type-post" itemprop="blogPost">

    


  
    <h3 class="post-title" itemprop="name">
      <a href="/2018/07/20/原型模式/">原型模式</a>
    </h3>
  




     <div class="post-meta">
        <time class="post-time" title="2018-07-20 12:10:37" datetime="2018-07-20T04:10:37.801Z"  itemprop="datePublished">2018-07-20</time>

    </div>

    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>通过复制现有的对象实例来创建新的对象实例。</p>
<h4 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h4><h5 id="实现Cloneable接口："><a href="#实现Cloneable接口：" class="headerlink" title="实现Cloneable接口："></a>实现Cloneable接口：</h5><pre><code>Cloneable接口的作用是在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法。在java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出CloneNotSupportedException异常。
</code></pre><h5 id="重写Object类中的clone方法："><a href="#重写Object类中的clone方法：" class="headerlink" title="重写Object类中的clone方法："></a>重写Object类中的clone方法：</h5><pre><code>Java中，所有类的父类都是Object类，Object类中有一个clone方法，作用是返回对象的一个拷贝，但是其作用域protected类型的，一般的类无法调用，因此，原型类需要将clone方法的作用域修改为public类型。
</code></pre><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><p>例如，对于拿邮件发邀请函，邮件类大部分内容都是一样的：邀请原由、相邀地点，相聚时间等等，但对于被邀请者的名称和发送的邮件地址是不同的。</p>
<h5 id="定义Mail类："><a href="#定义Mail类：" class="headerlink" title="定义Mail类："></a>定义Mail类：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Mail implements Cloneable &#123;    </span><br><span class="line">    private String receiver;    </span><br><span class="line">    private String subject;    </span><br><span class="line">    private String content;    </span><br><span class="line">    private String tail;    </span><br><span class="line">    public Mail(EventTemplate et) &#123;        </span><br><span class="line">        this.tail = et.geteventContent();        </span><br><span class="line">        this.subject = et.geteventSubject();</span><br><span class="line">    &#125;    </span><br><span class="line">    @Override</span><br><span class="line">    public Mail clone() &#123;</span><br><span class="line">        Mail mail = null;        </span><br><span class="line">    try &#123;</span><br><span class="line">            mail = (Mail) super.clone();            </span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;            </span><br><span class="line">        // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;        return mail;</span><br><span class="line">    &#125;</span><br><span class="line">//get、set.....</span><br><span class="line">&#125;</span><br><span class="line">测试方法：</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int MAX_COUNT = 10;</span><br><span class="line">    EventTemplate et = </span><br><span class="line">new EventTemplate(&quot;邀请函（不变）&quot;, &quot;婚嫁生日啥的....（不变部分）&quot;);</span><br><span class="line">    Mail mail = new Mail(et);    </span><br><span class="line">    while (i &lt; MAX_COUNT) &#123;</span><br><span class="line">        Mail cloneMail = mail.clone();</span><br><span class="line">        cloneMail.setContent(&quot;XXX先生（女士）（变化部分）&quot;</span><br><span class="line">     + mail.getTail());</span><br><span class="line">        cloneMail.setReceiver(&quot;每个人的邮箱地址...com（变化部分）&quot;);</span><br><span class="line">        sendMail(cloneMail);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><pre><code>1、使用原型模型创建一个对象比直接new一个对象更有效率，因为它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。
2、隐藏了制造新实例的复杂性，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。
</code></pre><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><pre><code>1、由于使用原型模式复制对象时不会调用类的构造方法，所以原型模式无法和单例模式组合使用，因为原型类需要将clone方法的作用域修改为public类型，那么单例模式的条件就无法满足了。
2、使用原型模式时不能有final对象。
3、Object类的clone方法只会拷贝对象中的基本数据类型，对于数组，引用对象等只能另行拷贝。这里涉及到深拷贝和浅拷贝的概念。
</code></pre><h4 id="深拷贝与浅拷贝："><a href="#深拷贝与浅拷贝：" class="headerlink" title="深拷贝与浅拷贝："></a>深拷贝与浅拷贝：</h4><h5 id="浅拷贝："><a href="#浅拷贝：" class="headerlink" title="浅拷贝："></a>浅拷贝：</h5><pre><code>将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的（这样不安全）。
</code></pre><h5 id="深拷贝："><a href="#深拷贝：" class="headerlink" title="深拷贝："></a>深拷贝：</h5><pre><code>将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。
</code></pre><p>那么深拷贝如何具体实现呢？<br>继续上面的例子，增加了一个ArrayList属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private String receiver;</span><br><span class="line">private String subject;</span><br><span class="line">private String content;</span><br><span class="line">private String tail;</span><br><span class="line">private ArrayList&lt;String&gt; ars;</span><br><span class="line">此时，单mail = (Mail) super.clone();无法将ars指向的地址区域改变，必须另行拷贝：</span><br><span class="line">try &#123;</span><br><span class="line">       mail = (Mail) super.clone();       </span><br><span class="line">       mail.ars = (ArrayList&lt;String&gt;)this.ars.clone();</span><br><span class="line">      &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h4><pre><code>1、复制对象的结构和数据。
2、希望对目标对象的修改不影响既有的原型对象。
3、创建一个对象的成本比较大。
</code></pre>
    
        <div>
            <a href="/2018/07/20/原型模式/" class="post-more waves-button">
                阅读全文 »
            </a>
        </div>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-一、会话的概念"
  class="article-card article-type-post" itemprop="blogPost">

    


  
    <h3 class="post-title" itemprop="name">
      <a href="/2018/07/20/一、会话的概念/">javaweb (十 )</a>
    </h3>
  




     <div class="post-meta">
        <time class="post-time" title="2018-07-20 12:10:37" datetime="2018-07-20T04:10:37.801Z"  itemprop="datePublished">2018-07-20</time>

    </div>

    <div class="post-content" id="post-content" itemprop="postContent">

    
        <p>###一、会话的概念</p>
<ul>
<li>会话可简单理解为：用户开一个浏览器，点击多个超链接，访问服务器多个web资源，然后关闭浏览器，整个过程称之为一个会话。</li>
<li>有状态会话：一个同学来过教室，下次再来教室，我们会知道这个同学曾经来过，这称之为有状态会话。<h3 id="二、会话过程中要解决的一些问题？"><a href="#二、会话过程中要解决的一些问题？" class="headerlink" title="二、会话过程中要解决的一些问题？"></a>二、会话过程中要解决的一些问题？</h3>每个用户在使用浏览器与服务器进行会话的过程中，不可避免各自会产生一些数据，程序要想办法为每个用户保存这些数据。<h3 id="三、保存会话数据的两种技术"><a href="#三、保存会话数据的两种技术" class="headerlink" title="三、保存会话数据的两种技术"></a>三、保存会话数据的两种技术</h3>####3.1、Cookie</li>
<li>Cookie是客户端技术，程序把每个用户的数据以cookie的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务器中的web资源时，就会带着各自的数据去。这样，web资源处理的就是用户各自的数据了。<h4 id="3-2、Session"><a href="#3-2、Session" class="headerlink" title="3.2、Session"></a>3.2、Session</h4></li>
<li>Session是服务器端技术，利用这个技术，服务器在运行时可以为每一个用户的浏览器创建一个其独享的session对象，由于session为用户浏览器独享，所以用户在访问服务器的web资源时，可以把各自的数据放在各自的session中，当用户再去访问服务器中的其它web资源时，其它web资源再从用户各自的session中取出数据为用户服务。<br>####四、Java提供的操作Cookie的API<br>Java中的javax.servlet.http.Cookie类用于创建一个Cookie</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cookie(String name, String value)</td>
<td style="text-align:center">构造方法</td>
<td style="text-align:center">实例化Cookie对象，传入cooke名称和cookie的值</td>
</tr>
<tr>
<td>public String getName()</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">取得Cookie的名字</td>
</tr>
<tr>
<td>public String getValue()</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">取得Cookie的值</td>
</tr>
<tr>
<td>public void setValue(String newValue)</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">设置Cookie的值</td>
</tr>
<tr>
<td>ppublic void setMaxAge(int expiry)</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">取设置Cookie的最大保存时间，即cookie的有效期</td>
</tr>
<tr>
<td>public int getMaxAge()</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">获取Cookies的有效期</td>
</tr>
<tr>
<td>public void setPath(String uri)</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">设置cookie的有效路径，比如把cookie的有效路径设置为”/xdp”，那么浏览器访问”xdp”目录下的web资源时，都会带上cookie，再比如把cookie的有效路径设置为”/xdp/qgx”，那么浏览器只有在访问”xdp”目录下的”qgx”这个目录里面的web资源时才会带上cookie一起访问，而当访问”xdp”目录下的web资源时，浏览器是不带cookie的</td>
</tr>
<tr>
<td>public String getPath()</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">获取cookie的有效路径</td>
</tr>
<tr>
<td>public void setDomain(String pattern)</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">获 设置cookie的有效域</td>
</tr>
<tr>
<td>public String getDomain()</td>
<td style="text-align:center">普通方法</td>
<td style="text-align:center">获取cookie的有效域</td>
</tr>
</tbody>
</table>
<p>　response接口也中定义了一个addCookie方法，它用于在其响应头中增加一个相应的Set-Cookie头字段。 同样，request接口中也定义了一个getCookies方法，它用于获取客户端提交的Cookie。</p>
<h3 id="五、Cookie使用范例"><a href="#五、Cookie使用范例" class="headerlink" title="五、Cookie使用范例"></a>五、Cookie使用范例</h3><h4 id="5-1、使用cookie记录用户上一次访问的时间"><a href="#5-1、使用cookie记录用户上一次访问的时间" class="headerlink" title="5.1、使用cookie记录用户上一次访问的时间"></a>5.1、使用cookie记录用户上一次访问的时间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package qgx.cookie;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.Cookie;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * cookie实例  ：获取用户上一次访问的时间</span><br><span class="line"> */</span><br><span class="line">@WebServlet(name = &quot;CookieDemo1&quot;)</span><br><span class="line">public class CookieDemo1 extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">doGet(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        //设置服务器端以UTF-8编码进行输出</span><br><span class="line">        response.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">        //设置浏览器以UTF-8编码进行接收,解决中文乱码问题</span><br><span class="line">        response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        //如果用户是第一次访问，那么得到的cookies将是null</span><br><span class="line">        if (cookies!=null)&#123;</span><br><span class="line">            out.write(&quot;您上次访问的时间是：&quot;);</span><br><span class="line">            for (int i = 0; i &lt; cookies.length; i++) &#123;</span><br><span class="line">                Cookie cookie = cookies[i];</span><br><span class="line">                if (cookie.getName().equals(&quot;lastAccessTime&quot;)) &#123;</span><br><span class="line">                    Long lastAccessTime =Long.parseLong(cookie.getValue());</span><br><span class="line">                    Date date = new Date(lastAccessTime);</span><br><span class="line">                    out.write(date.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            out.write(&quot;首次来访！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //用户访问过之后重新设置用户的访问时间，存储到cookie中，然后发送到客户端浏览器</span><br><span class="line">        Cookie cookie = new Cookie(&quot;lastAccessTime&quot;, System.currentTimeMillis()+&quot;&quot;);//创建一个cookie，cookie的名字是lastAccessTime</span><br><span class="line">        //将cookie对象添加到response对象中，这样服务器在输出response对象中的内容时就会把cookie也输出到客户端浏览器</span><br><span class="line">           response.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/cookie.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>　在上面的例子中，在程序代码中并没有使用setMaxAge方法设置cookie的有效期，所以当关闭浏览器之后，cookie就失效了，要想在关闭了浏览器之后，cookie依然有效，那么在创建cookie时，就要为cookie设置一个有效期。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//用户访问过之后重新设置用户的访问时间，存储到cookie中，然后发送到客户端浏览器</span><br><span class="line"> Cookie cookie = new Cookie(&quot;lastAccessTime&quot;, System.currentTimeMillis()+&quot;&quot;);//创建一个cookie，cookie的名字是lastAccessTime</span><br><span class="line"> //设置Cookie的有效期为1天</span><br><span class="line">cookie.setMaxAge(24*60*60);</span><br><span class="line"> //将cookie对象添加到response对象中，这样服务器在输出response对象中的内容时就会把cookie也输出到客户端浏览器</span><br><span class="line"> response.addCookie(cookie);</span><br></pre></td></tr></table></figure></p>
<h3 id="六、Cookie注意细节"><a href="#六、Cookie注意细节" class="headerlink" title="六、Cookie注意细节"></a>六、Cookie注意细节</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个Cookie只能标识一种信息，它至少含有一个标识该信息的名称（NAME）和设置值（VALUE）。</span><br><span class="line">一个WEB站点可以给一个WEB浏览器发送多个Cookie，一个WEB浏览器也可以存储多个WEB站点提供的Cookie。</span><br><span class="line">浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为4KB。</span><br><span class="line">如果创建了一个cookie，并将他发送到浏览器，默认情况下它是一个会话级别的cookie（即存储在浏览器的内存中），用户退出浏览器之后即被删除。若希望浏览器将该cookie存储在磁盘上，则需要使用maxAge，并给出一个以秒为单位的时间。将最大时效设为0则是命令浏览器删除该cookie。</span><br></pre></td></tr></table></figure>
<h4 id="6-1、删除Cookie"><a href="#6-1、删除Cookie" class="headerlink" title="6.1、删除Cookie"></a>6.1、删除Cookie</h4><p>注意：删除cookie时，path必须一致，否则不会删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package qgx.cookie;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.Cookie;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">@WebServlet(name = &quot;CookieDemo2&quot;)</span><br><span class="line">public class CookieDemo2 extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        //创建一个名字为lastAccessTime的cookie</span><br><span class="line">        Cookie cookie = new Cookie(&quot;lastAccessTime&quot;, System.currentTimeMillis() + &quot;&quot;);</span><br><span class="line">        //将cookie的有效期设置为0，命令浏览器删除该cookie</span><br><span class="line">        cookie.setMaxAge(0);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="6-2、cookie中存取中文"><a href="#6-2、cookie中存取中文" class="headerlink" title="6.2、cookie中存取中文"></a>6.2、cookie中存取中文</h4><ul>
<li><p>要想在cookie中存储中文，那么必须使用URLEncoder类里面的encode(String s, String enc)方法进行中文转码，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = new Cookie(&quot;userName&quot;, URLEncoder.encode(&quot;刘俭梅&quot;, &quot;UTF-8&quot;));</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在获取cookie中的中文数据时，再使用URLDecoder类里面的decode(String s, String enc)进行解码，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URLDecoder.decode(cookies[i].getValue(), &quot;UTF-8&quot;)</span><br></pre></td></tr></table></figure></li>
</ul>

    
        <div>
            <a href="/2018/07/20/一、会话的概念/" class="post-more waves-button">
                阅读全文 »
            </a>
        </div>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cookie/">Cookie</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-引入web模块"
  class="article-card article-type-post" itemprop="blogPost">

    


  
    <h3 class="post-title" itemprop="name">
      <a href="/2018/07/20/引入web模块/">Spring Boot(三)</a>
    </h3>
  




     <div class="post-meta">
        <time class="post-time" title="2018-07-20 12:10:37" datetime="2018-07-20T04:10:37.801Z"  itemprop="datePublished">2018-07-20</time>

    </div>

    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h4 id="引入web模块"><a href="#引入web模块" class="headerlink" title="引入web模块"></a>引入web模块</h4><p><strong>1.pom.xml中添加支持web的模块（测试模块）：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--测试依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>pom.xml文件中默认有两个模块：</strong><br><strong>spring-boot-starter：</strong>核心模块，包括自动配置支持、日志和YAML；<br><strong>spring-boot-starter-test：</strong>测试模块，包括JUnit、Hamcrest、Mockito。</p>
<p>详细pom.xml文件内容，具体如下（注意parent配置，因为1.5.6.RELEASE配置了版本信息，所以所有子项目中的相对应包不需要再次配置版本号）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; </span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 </span><br><span class="line">    http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;com.example&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;Spring-Boot&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;demo&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;SpringBootDemo1 project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.5.6.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 编写controller</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">@RestController</span><br><span class="line"></span><br><span class="line">public class HelloWorldController &#123; </span><br><span class="line">   @RequestMapping(&quot;/hello&quot;) </span><br><span class="line">   public String index() &#123; </span><br><span class="line">       return &quot;Hello World&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">@RestController的含义是controller里面的方法都以json格式输出</span><br></pre></td></tr></table></figure>
<p><strong>3. 启动主程序</strong><br>打开浏览器访问<a href="http://localhost:8080/hello，就可以看到效果了，是不是感觉很简单！" target="_blank" rel="noopener">http://localhost:8080/hello，就可以看到效果了，是不是感觉很简单！</a></p>
<p><strong>如何做单元测试？</strong><br>打开的src/test/下的测试入口，编写简单的http请求来测试；使用mockmvc进行，利用MockMvcResultHandlers.print()打印出执行结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringApplicationConfiguration(classes = MockServletContext.class)</span><br><span class="line">@WebAppConfiguration</span><br><span class="line">public class HelloWorldControlerTests &#123;</span><br><span class="line">    private MockMvc mvc;</span><br><span class="line">    @Before</span><br><span class="line">    public void setUp() throws Exception &#123;</span><br><span class="line">        mvc = MockMvcBuilders.standaloneSetup(</span><br><span class="line">            new HelloWorldController()).build();</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void getHello() throws Exception &#123;</span><br><span class="line">    mvc.perform(MockMvcRequestBuilders.get(&quot;/hello&quot;)</span><br><span class="line">                .accept(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>开发环境的调试</strong><br>热启动在正常开发项目中已经很常见了吧，虽然平时开发web项目过程中，改动项目启重启总是报错；但springBoot对调试支持很好，修改之后可以实时生效，需要添加以下的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;fork&gt;true&lt;/fork&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">   &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></p>
<p>注意：该模块在完整的打包环境下运行的时候会被禁用。如果你使用java -jar启动应用或者用一个特定的classloader启动，它会认为这是一个“生产环境”。</p>
<h4 id="Spring-Boot-Maven插件"><a href="#Spring-Boot-Maven插件" class="headerlink" title="Spring Boot Maven插件"></a>Spring Boot Maven插件</h4><p>Spring Boot Maven插件提供了使用Spring Boot应用程序步骤如下:</p>
<p><strong>重新打包：</strong>创建一个可自动执行的jar或war文件。它可以替换常规工件，或者可以使用单独的分类器附加到构建生命周期。<br><strong>运行：</strong>运行您的Spring引导应用程序与几个选项传递参数。<br><strong>启动和停止：</strong>将Spring Boot应用程序集成到集成测试阶段，以便应用程序在其之前启动。<br><strong>构建信息：</strong>生成可由致动器使用的构建信息。</p>
<p><strong>重新打包一个应用程序</strong><br>为了重新打包应用程序，只需要在pom.xml中添加对插件的引用，具体配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.5.6.RELEASE&lt;/version&gt;</span><br><span class="line">      &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">          &lt;goals&gt;</span><br><span class="line">            &lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class="line">          &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">      &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></p>
<p>重新打包在Maven生命周期的包阶段中构建的jar或war，包括在项目中定义的任何提供的依赖关系。</p>
<p>默认情况下会自动排除Devtools（您可以使用excludeDevtools属性来控制）。为了使这些工作与war包装相匹配，“spring-boot-devtools”依赖关系必须设置为可选的或提供的范围。原始（即非可执行）文件默认情况下重命名为.original，但也可以使用自定义分类器保留原始工件。</p>
<p>Spring Boot Maven插件会重写配置，特别是它管理Main-Class和Start-Class条目，因此如果默认值不起作用，则必须配置它们（不在jar插件中）。主类实际上是由引导插件的布局属性控制的，实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.5.6.RELEASE&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;mainClass&gt;$&#123;start-class&#125;&lt;/mainClass&gt;</span><br><span class="line">        &lt;layout&gt;ZIP&lt;/layout&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">      &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">          &lt;goals&gt;</span><br><span class="line">            &lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class="line">          &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">      &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></p>
<p>该布局属性基归档类型（(jar或者war）。可以在以下布局中使用：<br><strong>JAR：</strong>常规可执行JAR布局。<br><strong>WAR：</strong>可执行WAR布局。提供的依赖关系放置在WEB-INF/lib中，以避免战争部署在servlet容器中时发生冲突。<br><strong>ZIP（DIR的别名）：</strong>类似于使用PropertiesLauncher的JAR布局。<br><strong>MODULE：</strong>捆绑依赖（不包括提供的范围）和项目资源，不捆绑引导加载程序。<br><strong>NONE：</strong>捆绑所有依赖项和资源，不捆绑引导加载程序。<br><strong>运行应用程序</strong><br>Spring Boot Maven插件可以用于从命令行启动应用程序，具体执行命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn spring-boot:run</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，该应用程序直接从Maven JVM执行。如果需要在分叉进程中运行，可以使用’fork’选项。如果指定了’jvmArguments’或’agent’选项，或者如果存在devtools，则也会发生分岔。</p>
<p>如果需要指定一些JVM参数（即用于调试目的），可以使用jvmArguments参数。为方便起见，要启用的配置文件由特定属性（配置文件）处理。</p>
<p><strong>使用集成测试</strong><br>为了确保Spring Boot应用程序的生命周期在集成测试中得到妥善管理，可以使用如下所述的启动和终止：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.5.6.RELEASE&lt;/version&gt;</span><br><span class="line">      &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">          &lt;id&gt;pre-integration-test&lt;/id&gt;</span><br><span class="line">          &lt;goals&gt;</span><br><span class="line">            &lt;goal&gt;start&lt;/goal&gt;</span><br><span class="line">          &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">          &lt;id&gt;post-integration-test&lt;/id&gt;</span><br><span class="line">          &lt;goals&gt;</span><br><span class="line">            &lt;goal&gt;stop&lt;/goal&gt;</span><br><span class="line">          &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">      &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></p>
<p>还可以配置更高级的设置，以便在设置特定属性时跳过集成测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">  &lt;it.skip&gt;false&lt;/it.skip&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;skip&gt;$&#123;it.skip&#125;&lt;/skip&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.5.6.RELEASE&lt;/version&gt;</span><br><span class="line">      &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">          &lt;id&gt;pre-integration-test&lt;/id&gt;</span><br><span class="line">          &lt;goals&gt;</span><br><span class="line">            &lt;goal&gt;start&lt;/goal&gt;</span><br><span class="line">          &lt;/goals&gt;</span><br><span class="line">          &lt;configuration&gt;</span><br><span class="line">            &lt;skip&gt;$&#123;it.skip&#125;&lt;/skip&gt;</span><br><span class="line">          &lt;/configuration&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">          &lt;id&gt;post-integration-test&lt;/id&gt;</span><br><span class="line">          &lt;goals&gt;</span><br><span class="line">            &lt;goal&gt;stop&lt;/goal&gt;</span><br><span class="line">          &lt;/goals&gt;</span><br><span class="line">          &lt;configuration&gt;</span><br><span class="line">            &lt;skip&gt;$&#123;it.skip&#125;&lt;/skip&gt;</span><br><span class="line">          &lt;/configuration&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">      &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></p>
<p>注意：如果运行mvn verify -Dit.skip=true，那么集成测试将被完全跳过。</p>

    
        <div>
            <a href="/2018/07/20/引入web模块/" class="post-more waves-button">
                阅读全文 »
            </a>
        </div>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-Boot-构建框架/">Spring Boot 构建框架</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-Toast为什么不可以在子线程里面运行"
  class="article-card article-type-post" itemprop="blogPost">

    


  
    <h3 class="post-title" itemprop="name">
      <a href="/2018/07/20/Toast为什么不可以在子线程里面运行/">我的第一个Android设计——登录和注册</a>
    </h3>
  




     <div class="post-meta">
        <time class="post-time" title="2018-07-20 12:10:37" datetime="2018-07-20T04:10:37.801Z"  itemprop="datePublished">2018-07-20</time>

    </div>

    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h3 id="Toast为什么不可以在子线程里面运行"><a href="#Toast为什么不可以在子线程里面运行" class="headerlink" title="Toast为什么不可以在子线程里面运行"></a>Toast为什么不可以在子线程里面运行</h3><p>Handler不能再子线程里运行的 因为子线程没有创建Looper.prepare(); 所以就报错了。主线程不需要调用，是因为主线程已经默认帮你调用了。</p>
<p>可以看到一个Toast的创建需要依赖Handler。那么 我不要 我不要 我一定要在子线程使用Toast那怎么办。<br>其实很简单，它却什么就给它什么。</p>
<h4 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">new Thread()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            super.run();</span><br><span class="line">            Looper.prepare();</span><br><span class="line">            try &#123;</span><br><span class="line">                Toast.makeText(LoginActivity.this,&quot;keshe&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;catch (Exception e) &#123;</span><br><span class="line">                Logger.e(&quot;error&quot;,e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            Looper.loop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br></pre></td></tr></table></figure>
<p>因为除了Activity ui线程默认创建之外，其他线程不会自动创建调用 Looper.prepare()来给线程创建消息循环，然后再通过，Looper.loop()来使消息循环起作用。</p>
<h4 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">runOnUiThread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            Toast.makeText(MainActivity.this,&quot;keshe23333&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    new Thread()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;.start();</span><br></pre></td></tr></table></figure>
<p>Toast的代码创建在Runnable中，然后在需要Toast时，把这个Runnable对象传给runOnUiThread(Runnable)。 这样Runnable对像就能在ui程序中被调用。如果当前线程是UI线程,那么行动是立即执行</p>
<h4 id="第三种方法"><a href="#第三种方法" class="headerlink" title="第三种方法"></a>第三种方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Handler mHandler = new Handler()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line">     //这里写你的Toast代码Toast.makeText(MainActivity.this,&quot;keshe23333&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    new Thread()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            super.run();</span><br><span class="line">          mHandler.sendEmptyMessage(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br></pre></td></tr></table></figure>

    
        <div>
            <a href="/2018/07/20/Toast为什么不可以在子线程里面运行/" class="post-more waves-button">
                阅读全文 »
            </a>
        </div>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-课设/">Android 课设</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-单一职责原则"
  class="article-card article-type-post" itemprop="blogPost">

    


  
    <h3 class="post-title" itemprop="name">
      <a href="/2018/07/20/单一职责原则/">单一职责原则</a>
    </h3>
  




     <div class="post-meta">
        <time class="post-time" title="2018-07-20 12:10:37" datetime="2018-07-20T04:10:37.801Z"  itemprop="datePublished">2018-07-20</time>

    </div>

    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。</p>
<h4 id="问题由来："><a href="#问题由来：" class="headerlink" title="问题由来："></a>问题由来：</h4><p>类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。</p>
<h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p>遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。<br>举例说明，用一个类描述动物呼吸这个场景：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;  </span><br><span class="line">       public void breathe(String animal)&#123;  </span><br><span class="line">           System.out.println(animal+&quot;呼吸空气&quot;);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   public class Client&#123;  </span><br><span class="line">       public static void main(String[] args)&#123;  </span><br><span class="line">           Animal animal = new Animal();  </span><br><span class="line">           animal.breathe(&quot;牛&quot;);  </span><br><span class="line">           animal.breathe(&quot;羊&quot;);  </span><br><span class="line">           animal.breathe(&quot;猪&quot;);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">牛呼吸空气</span><br><span class="line">羊呼吸空气</span><br><span class="line">猪呼吸空气</span><br></pre></td></tr></table></figure></p>
<p>   程序上线后，发现问题了，并不是所有的动物都呼吸空气的，比如鱼就是呼吸水的。修改时如果遵循单一职责原则，需要将Animal类细分为陆生动物类Terrestrial，水生动物Aquatic，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Terrestrial&#123;  </span><br><span class="line">   public void breathe(String animal)&#123;  </span><br><span class="line">       System.out.println(animal+&quot;呼吸空气&quot;);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">class Aquatic&#123;  </span><br><span class="line">   public void breathe(String animal)&#123;  </span><br><span class="line">       System.out.println(animal+&quot;呼吸水&quot;);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line">public class Client&#123;  </span><br><span class="line">   public static void main(String[] args)&#123;  </span><br><span class="line">       Terrestrial terrestrial = new Terrestrial();  </span><br><span class="line">       terrestrial.breathe(&quot;牛&quot;);  </span><br><span class="line">       terrestrial.breathe(&quot;羊&quot;);  </span><br><span class="line">       terrestrial.breathe(&quot;猪&quot;);  </span><br><span class="line">         </span><br><span class="line">       Aquatic aquatic = new Aquatic();  </span><br><span class="line">       aquatic.breathe(&quot;鱼&quot;);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">牛呼吸空气</span><br><span class="line">羊呼吸空气</span><br><span class="line">猪呼吸空气</span><br><span class="line">鱼呼吸水</span><br></pre></td></tr></table></figure></p>
<p>我们会发现如果这样修改花销是很大的，除了将原来的类分解之外，还需要修改客户端。而直接修改类Animal来达成目的虽然违背了单一职责原则，但花销却小的多，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;  </span><br><span class="line">       public void breathe(String animal)&#123;  </span><br><span class="line">           if(&quot;鱼&quot;.equals(animal))&#123;  </span><br><span class="line">               System.out.println(animal+&quot;呼吸水&quot;);  </span><br><span class="line">           &#125;else&#123;  </span><br><span class="line">               System.out.println(animal+&quot;呼吸空气&quot;);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">   public class Client&#123;  </span><br><span class="line">       public static void main(String[] args)&#123;  </span><br><span class="line">           Animal animal = new Animal();  </span><br><span class="line">           animal.breathe(&quot;牛&quot;);  </span><br><span class="line">           animal.breathe(&quot;羊&quot;);  </span><br><span class="line">           animal.breathe(&quot;猪&quot;);  </span><br><span class="line">           animal.breathe(&quot;鱼&quot;);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这种修改方式要简单的多。但是却存在着隐患：有一天需要将鱼分为呼吸淡水的鱼和呼吸海水的鱼，则又需要修改Animal类的breathe方法，而对原有代码的修改会对调用“猪”“牛”“羊”等相关功能带来风险，也许某一天你会发现程序运行的结果变为“牛呼吸水”了。这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;  </span><br><span class="line">       public void breathe(String animal)&#123;  </span><br><span class="line">           System.out.println(animal+&quot;呼吸空气&quot;);  </span><br><span class="line">       &#125;  </span><br><span class="line">     </span><br><span class="line">       public void breathe2(String animal)&#123;  </span><br><span class="line">           System.out.println(animal+&quot;呼吸水&quot;);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">   public class Client&#123;  </span><br><span class="line">       public static void main(String[] args)&#123;  </span><br><span class="line">           Animal animal = new Animal();  </span><br><span class="line">           animal.breathe(&quot;牛&quot;);  </span><br><span class="line">           animal.breathe(&quot;羊&quot;);  </span><br><span class="line">           animal.breathe(&quot;猪&quot;);  </span><br><span class="line">           animal.breathe2(&quot;鱼&quot;);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然也违背了单一职责原则，但在方法级别上却是符合单一职责原则的，因为它并没有动原来方法的代码。这三种方式各有优缺点，那么在实际编程中，采用哪一中呢？其实这真的比较难说，需要根据实际情况来确定。我的原则是：只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则；<br>        例如本文所举的这个例子，它太简单了，它只有一个方法，所以，无论是在代码级别上违反单一职责原则，还是在方法级别上违反，都不会造成太大的影响。实际应用中的类都要复杂的多，一旦发生职责扩散而需要修改类时，除非这个类本身非常简单，否则还是遵循单一职责原则的好。</p>
<h4 id="遵循单一职责原的优点有："><a href="#遵循单一职责原的优点有：" class="headerlink" title="遵循单一职责原的优点有："></a>遵循单一职责原的优点有：</h4><p>1、可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；<br>2、提高类的可读性，提高系统的可维护性；<br>3、变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。<br>        需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。</p>

    
        <div>
            <a href="/2018/07/20/单一职责原则/" class="post-more waves-button">
                阅读全文 »
            </a>
        </div>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-依赖倒置原则"
  class="article-card article-type-post" itemprop="blogPost">

    


  
    <h3 class="post-title" itemprop="name">
      <a href="/2018/07/20/依赖倒置原则/">依赖倒置原则</a>
    </h3>
  




     <div class="post-meta">
        <time class="post-time" title="2018-07-20 12:10:37" datetime="2018-07-20T04:10:37.801Z"  itemprop="datePublished">2018-07-20</time>

    </div>

    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p>
<h4 id="问题由来："><a href="#问题由来：" class="headerlink" title="问题由来："></a>问题由来：</h4><p>类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。</p>
<h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p>将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。</p>
<pre><code>依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。

依赖倒置原则的核心思想是面向接口编程，我们依旧用一个例子来说明面向接口编程比相对于面向实现编程好在什么地方。场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。代码如下：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Book&#123;  </span><br><span class="line">       public String getContent()&#123;  </span><br><span class="line">           return &quot;很久很久以前有一个阿拉伯的故事……&quot;;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">   class Mother&#123;  </span><br><span class="line">       public void narrate(Book book)&#123;  </span><br><span class="line">           System.out.println(&quot;妈妈开始讲故事&quot;);  </span><br><span class="line">           System.out.println(book.getContent());  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">   public class Client&#123;  </span><br><span class="line">       public static void main(String[] args)&#123;  </span><br><span class="line">           Mother mother = new Mother();  </span><br><span class="line">           mother.narrate(new Book());  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">运行结果：</span><br><span class="line">妈妈开始讲故事</span><br><span class="line">很久很久以前有一个阿拉伯的故事……</span><br><span class="line"></span><br><span class="line">        运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸，让这位母亲讲一下报纸上的故事，报纸的代码如下：</span><br><span class="line">class Newspaper&#123;  </span><br><span class="line">   public String getContent()&#123;  </span><br><span class="line">       return &quot;林书豪38+7领导尼克斯击败湖人……&quot;;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这位母亲却办不到，因为她居然不会读报纸上的故事，这太荒唐了，只是将书换成报纸，居然必须要修改Mother才能读。假如以后需求换成杂志呢？换成网页呢？还要不断地修改Mother，这显然不是好的设计。原因就是Mother与Book之间的耦合性太高了，必须降低他们之间的耦合度才行。</p>
<p>我们引入一个抽象的接口IReader。读物，只要是带字的都属于读物：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IReader&#123;  </span><br><span class="line">   public String getContent();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Mother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，他们各自都去实现IReader接口，这样就符合依赖倒置原则了，代码修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Newspaper implements IReader &#123;  </span><br><span class="line">       public String getContent()&#123;  </span><br><span class="line">           return &quot;林书豪17+9助尼克斯击败老鹰……&quot;;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   class Book implements IReader&#123;  </span><br><span class="line">       public String getContent()&#123;  </span><br><span class="line">           return &quot;很久很久以前有一个阿拉伯的故事……&quot;;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">   class Mother&#123;  </span><br><span class="line">       public void narrate(IReader reader)&#123;  </span><br><span class="line">           System.out.println(&quot;妈妈开始讲故事&quot;);  </span><br><span class="line">           System.out.println(reader.getContent());  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">   public class Client&#123;  </span><br><span class="line">       public static void main(String[] args)&#123;  </span><br><span class="line">           Mother mother = new Mother();  </span><br><span class="line">           mother.narrate(new Book());  </span><br><span class="line">           mother.narrate(new Newspaper());  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br><span class="line">运行结果：</span><br><span class="line">妈妈开始讲故事</span><br><span class="line">很久很久以前有一个阿拉伯的故事……</span><br><span class="line">妈妈开始讲故事</span><br><span class="line">林书豪17+9助尼克斯击败老鹰……</span><br></pre></td></tr></table></figure></p>
<p> 这样修改后，无论以后怎样扩展Client类，都不需要再修改Mother类了。这只是一个简单的例子，实际情况中，代表高层模块的Mother类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。</p>
<p>采用依赖倒置原则给多人并行开发带来了极大的便利，比如上例中，原本Mother类与Book类直接耦合时，Mother类必须等Book类编码完成后才可以进行编码，因为Mother类依赖于Book类。修改后的程序则可以同时开工，互不影响，因为Mother与Book类一点关系也没有。参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。</p>
<p>传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递，相信用过Spring框架的，对依赖的传递方式一定不会陌生。</p>
<p>在实际编程中，我们一般需要做到如下3点：</p>
<ul>
<li>低层模块尽量都要有抽象类或接口，或者两者都有。</li>
<li>变量的声明类型尽量是抽象类或接口。</li>
<li>使用继承时遵循里氏替换原则。<br>依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。</li>
</ul>

    
        <div>
            <a href="/2018/07/20/依赖倒置原则/" class="post-more waves-button">
                阅读全文 »
            </a>
        </div>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-策略模式"
  class="article-card article-type-post" itemprop="blogPost">

    


  
    <h3 class="post-title" itemprop="name">
      <a href="/2018/07/20/策略模式/">策略模式</a>
    </h3>
  




     <div class="post-meta">
        <time class="post-time" title="2018-07-20 12:10:37" datetime="2018-07-20T04:10:37.801Z"  itemprop="datePublished">2018-07-20</time>

    </div>

    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>定义一组算法，将每个算法都封装起来，并且使他们之间可以互换。</p>
<h4 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h4><p>行为类模式</p>
<h4 id="需求1，父类实现"><a href="#需求1，父类实现" class="headerlink" title="需求1，父类实现"></a>需求1，父类实现</h4><h5 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h5><p>现在要设计一只鸭子类，所有的鸭子都可以游泳，不同的鸭子样外貌可能不一样。</p>
<p>刚拿到这个需求，很简答的想法设计一个Duck类，拥有共有的方法swim，并且包含一个抽象方法display展示形态。</p>
<h5 id="Duck-java"><a href="#Duck-java" class="headerlink" title="Duck.java"></a>Duck.java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">abstract class Duck&#123;</span><br><span class="line">    </span><br><span class="line">    public void swim()&#123;</span><br><span class="line">        System.out.println(&quot;I am swimming&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public abstract void display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="GreenDuck-java"><a href="#GreenDuck-java" class="headerlink" title="GreenDuck.java"></a>GreenDuck.java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class GreenDuck extends Duck&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;my color is green&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="RedDuck-java"><a href="#RedDuck-java" class="headerlink" title="RedDuck.java"></a>RedDuck.java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class RedDuck extends Duck&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;my color is red&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="为什么swim-方法是普通方法，display-方法是抽象方法呢？"><a href="#为什么swim-方法是普通方法，display-方法是抽象方法呢？" class="headerlink" title="为什么swim()方法是普通方法，display() 方法是抽象方法呢？"></a>为什么swim()方法是普通方法，display() 方法是抽象方法呢？</h5><p>这里是为了体现，所有的都会游泳，并且都一样。所有鸭子都有外貌，但是是由各自决定，所以必须子类来重写。</p>
<h4 id="需求2，接口实现"><a href="#需求2，接口实现" class="headerlink" title="需求2，接口实现"></a>需求2，接口实现</h4><p>这时候需求变更，有些鸭子可以飞。</p>
<p>注意，这里的关键词是可以。如果这个时候我们把 fly() 方法写在子类 Duck 中，那就表示所有的鸭子都会飞。所以这个时候我们想到了接口，定义 Flyable 接口，让会飞的鸭子实现接口，并重写方法。</p>
<h5 id="Flyable-java"><a href="#Flyable-java" class="headerlink" title="Flyable.java"></a>Flyable.java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Flyable &#123;</span><br><span class="line">    </span><br><span class="line">    void fly();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="GreenDuck-java-1"><a href="#GreenDuck-java-1" class="headerlink" title="GreenDuck.java"></a>GreenDuck.java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class GreenDuck extends Duck implements Flyable&#123;</span><br><span class="line"></span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        System.out.println(&quot;I am flying with wing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;my color is green&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设GreenDuck会飞，那么它需要实现flyable接口，然后写自己会飞。RedDuck不会飞，所以不实现flyable接口。<br>看似问题解决了，但是如果这个时候我们系统中有几十种鸭子，而且会飞只分用翅膀飞，不能飞，用喷气式火箭飞3种，如果采用接口来实现，几十种鸭子都需要自己去实现方法，无法代码重用，这种设计是不是很不好呢，代码重用率太低。而且，如果后面我们还要添加其他的属性，比如说话Speakable，那我们需要添加一个新接口，并且以前的鸭子都要从新实现一遍，完全违反了开闭原则。<br>而且，如果后面我们还要添加其他的属性，比如说话Speakable，那我们需要添加一个新接口，并且以前的鸭子都要从新实现一遍，完全违反了开闭原则。</p>
<h4 id="需求3，策略模式实现"><a href="#需求3，策略模式实现" class="headerlink" title="需求3，策略模式实现"></a>需求3，策略模式实现</h4><p>策略模式说，我们需要把最公有的相同的方法放在父类中，将可以变化的方法抽取成接口，并通过组合的方式放到父类中，子类通过插入不同的接口实现，完成类的配置。<br>Duck类中，swim() 方法属于共有并且都相同的方法，display() 属于都有，但是需要自己去实现的方法。fly和speak是有些子类有的方法，并且实现有相同有不同，我们应该抽取成接口放在父类中。来看看代码：<br>修改Duck类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">abstract class Duck&#123;</span><br><span class="line">    </span><br><span class="line">    protected Flyable flyable;</span><br><span class="line">    </span><br><span class="line">    public void swim()&#123;</span><br><span class="line">        System.out.println(&quot;I am swimming&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public abstract void display();</span><br><span class="line">    </span><br><span class="line">    public void performFly()&#123;</span><br><span class="line">        // 通过多态机制，动态决定到底怎么飞</span><br><span class="line">        flyable.fly();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 设置飞的具体实现，并随时可以改变</span><br><span class="line">    public void setFlayable(Flyable flyable)&#123;</span><br><span class="line">        //TODO:添加非空判断</span><br><span class="line">        this.flyable = flyable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现3中飞的行为：</p>
<h5 id="Flyable-java-1"><a href="#Flyable-java-1" class="headerlink" title="Flyable.java"></a>Flyable.java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Flyable &#123;</span><br><span class="line">    void fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="FlyNoWay-java-不能飞"><a href="#FlyNoWay-java-不能飞" class="headerlink" title="FlyNoWay.java 不能飞"></a>FlyNoWay.java 不能飞</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class FlyNoWay implements Flyable&#123;</span><br><span class="line"></span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        System.out.println(&quot;can not fly&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="FlyWithWing-java-用翅膀飞"><a href="#FlyWithWing-java-用翅膀飞" class="headerlink" title="FlyWithWing.java 用翅膀飞"></a>FlyWithWing.java 用翅膀飞</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class FlyWithWing implements Flyable&#123;</span><br><span class="line"></span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        System.out.println(&quot;fly with wing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="FlyWithRocket-用火箭飞"><a href="#FlyWithRocket-用火箭飞" class="headerlink" title="FlyWithRocket 用火箭飞"></a>FlyWithRocket 用火箭飞</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class FlyWithRocket implements Flyable&#123;</span><br><span class="line"></span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        System.out.println(&quot;fly with rocket&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果现在要让 GreenDuck 有飞的属性，应该这样做：</p>
<h5 id="GreenDuck-java-2"><a href="#GreenDuck-java-2" class="headerlink" title="GreenDuck.java"></a>GreenDuck.java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class GreenDuck extends Duck&#123;</span><br><span class="line">    </span><br><span class="line">    public GreenDuck()&#123;</span><br><span class="line">        this.flyable = new FlyNoWay();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;my color is green&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Main-java"><a href="#Main-java" class="headerlink" title="Main.java"></a>Main.java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        GreenDuck gDuck = new GreenDuck();</span><br><span class="line">        gDuck.performFly();</span><br><span class="line">        gDuck.setFlayable(new FlyWithWing());</span><br><span class="line">        gDuck.performFly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认GreenDuck是不会飞的，然后可以通过动态的设置飞属性给鸭子，让他具有各种飞的属性。将飞与类解耦，并且也达到了飞实现重用的目的。</p>
<p>策略模式大概就是这样，如果这个时候我们要添加 Speak 属性，怎么做么？</p>
<h4 id="添加新功能"><a href="#添加新功能" class="headerlink" title="添加新功能"></a>添加新功能</h4><h5 id="step1-添加-Speakable接口，和两种实现"><a href="#step1-添加-Speakable接口，和两种实现" class="headerlink" title="step1: 添加 Speakable接口，和两种实现"></a>step1: 添加 Speakable接口，和两种实现</h5><h5 id="Speakable-java"><a href="#Speakable-java" class="headerlink" title="Speakable.java"></a>Speakable.java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Speakable &#123;</span><br><span class="line">    void speak();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="SpeakDuckLaguage-java"><a href="#SpeakDuckLaguage-java" class="headerlink" title="SpeakDuckLaguage .java"></a>SpeakDuckLaguage .java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class SpeakDuckLaguage implements Speakable &#123;</span><br><span class="line"></span><br><span class="line">    public void speak() &#123;</span><br><span class="line">        System.out.println(&quot;I can speak duck language&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="SpeakHumanLaguage-java"><a href="#SpeakHumanLaguage-java" class="headerlink" title="SpeakHumanLaguage.java"></a>SpeakHumanLaguage.java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class SpeakHumanLaguage implements Speakable &#123;</span><br><span class="line">    public void speak() &#123;</span><br><span class="line">        System.out.println(&quot;I can speak human language&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="step2-Duck类中添加Speakable属性，并且提供set方法，然后提供一个执行speak的方法"><a href="#step2-Duck类中添加Speakable属性，并且提供set方法，然后提供一个执行speak的方法" class="headerlink" title="step2: Duck类中添加Speakable属性，并且提供set方法，然后提供一个执行speak的方法"></a>step2: Duck类中添加Speakable属性，并且提供set方法，然后提供一个执行speak的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">abstract class Duck&#123;</span><br><span class="line">    </span><br><span class="line">    protected Flyable flyable;</span><br><span class="line">    protected Speakable speakable;</span><br><span class="line">    </span><br><span class="line">    //...</span><br><span class="line">    </span><br><span class="line">    public void performSpeak()&#123;</span><br><span class="line">        speakable.speak();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setSpeakable(Speakable speakable)&#123;</span><br><span class="line">        //TODO: 非空判断</span><br><span class="line">        this.speakable = speakable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="step3-给红鸭子添加会说话属性"><a href="#step3-给红鸭子添加会说话属性" class="headerlink" title="step3: 给红鸭子添加会说话属性"></a>step3: 给红鸭子添加会说话属性</h5><h5 id="RedDuck-java-默认说鸭子语言"><a href="#RedDuck-java-默认说鸭子语言" class="headerlink" title="RedDuck.java 默认说鸭子语言"></a>RedDuck.java 默认说鸭子语言</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class RedDuck extends Duck&#123;</span><br><span class="line">    </span><br><span class="line">    // 默认说鸭子语言</span><br><span class="line">    public RedDuck()&#123;</span><br><span class="line">        this.speakable = new SpeakDuckLaguage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;my color is red&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Main-java-客户端调用"><a href="#Main-java-客户端调用" class="headerlink" title="Main.java 客户端调用"></a>Main.java 客户端调用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        GreenDuck gDuck = new GreenDuck();</span><br><span class="line">        gDuck.performFly();</span><br><span class="line">        gDuck.setFlayable(new FlyWithWing());</span><br><span class="line">        gDuck.performFly();</span><br><span class="line">        </span><br><span class="line">        RedDuck rDuck = new RedDuck();</span><br><span class="line">        rDuck.performSpeak();</span><br><span class="line">        rDuck.setSpeakable(new SpeakHumanLaguage());</span><br><span class="line">        rDuck.performSpeak();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="策略模式的优缺点"><a href="#策略模式的优缺点" class="headerlink" title="策略模式的优缺点"></a>策略模式的优缺点</h4><h5 id="策略模式的主要优点有："><a href="#策略模式的主要优点有：" class="headerlink" title="策略模式的主要优点有："></a>策略模式的主要优点有：</h5><ul>
<li>策略类之间可以自由切换，由于策略类实现自同一个抽象，所以他们之间可以自由切换。</li>
<li>易于扩展，增加一个新的策略对策略模式来说非常容易，基本上可以在不改变原有代码的基础上进行扩展。</li>
<li>避免使用多重条件，如果不使用策略模式，对于所有的算法，必须使用条件语句进行连接，通过条件判断来决定使用哪一种算法，在上一篇文章中我们已经提到，使用多重条件判断是非常不容易维护的。</li>
</ul>
<h5 id="策略模式的缺点主要有两个："><a href="#策略模式的缺点主要有两个：" class="headerlink" title="策略模式的缺点主要有两个："></a>策略模式的缺点主要有两个：</h5><ul>
<li>维护各个策略类会给开发带来额外开销，可能大家在这方面都有经验：一般来说，策略类的数量超过5个，就比较令人头疼了。</li>
<li>必须对客户端（调用者）暴露所有的策略类，因为使用哪种策略是由客户端来决定的，因此，客户端应该知道有什么策略，并且了解各种策略之间的区别，否则，后果很严重。例如，有一个排序算法的策略模式，提供了快速排序、冒泡排序、选择排序这三种算法，客户端在使用这些算法之前，是不是先要明白这三种算法的适用情况？再比如，客户端要使用一个容器，有链表实现的，也有数组实现的，客户端是不是也要明白链表和数组有什么区别？就这一点来说是有悖于迪米特法则的。</li>
</ul>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>做面向对象设计的，对策略模式一定很熟悉，因为它实质上就是面向对象中的继承和多态，在看完策略模式的通用代码后，我想，即使之前从来没有听说过策略模式，在开发过程中也一定使用过它吧？至少在在以下两种情况下，大家可以考虑使用策略模式：</li>
<li>几个类的主要逻辑相同，只在部分逻辑的算法和行为上稍有区别的情况。</li>
<li>有几种相似的行为，或者说算法，客户端需要动态地决定使用哪一种，那么可以使用策略模式，将这些算法封装起来供客户端调用。</li>
<li>策略模式是一种简单常用的模式，我们在进行开发的时候，会经常有意无意地使用它，一般来说，策略模式不会单独使用，跟模版方法模式、工厂模式等混合使用的情况比较多。</li>
</ul>

    
        <div>
            <a href="/2018/07/20/策略模式/" class="post-more waves-button">
                阅读全文 »
            </a>
        </div>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-单例模式"
  class="article-card article-type-post" itemprop="blogPost">

    


  
    <h3 class="post-title" itemprop="name">
      <a href="/2018/07/20/单例模式/">单例模式</a>
    </h3>
  




     <div class="post-meta">
        <time class="post-time" title="2018-07-20 12:10:37" datetime="2018-07-20T04:10:37.801Z"  itemprop="datePublished">2018-07-20</time>

    </div>

    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例。即一个类只有一个对象实例。</p>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>1、单例类只能有一个实例。</li>
<li>2、单例类必须自己自己创建自己的唯一实例。</li>
<li>3、单例类必须给所有其他对象提供这一实例</li>
</ul>
<h4 id="单例模式的要点："><a href="#单例模式的要点：" class="headerlink" title="单例模式的要点："></a>单例模式的要点：</h4><ul>
<li>1、私有的构造方法</li>
<li>2、指向自己实例的私有静态引用</li>
<li>3、以自己实例为返回值的静态的公有的方法</li>
</ul>
<h4 id="单例模式根据实例化对象时机的不同分为两种："><a href="#单例模式根据实例化对象时机的不同分为两种：" class="headerlink" title="单例模式根据实例化对象时机的不同分为两种："></a>单例模式根据实例化对象时机的不同分为两种：</h4><ul>
<li>一种是饿汉式单例，一种是懒汉式单例。</li>
<li>饿汉式单例在单例类被加载时候，就实例化一个对象交给自己的引用；而懒汉式在调用取得实例方法的时候才会实例化对象。<br>代码如下：<h5 id="饿汉式单例："><a href="#饿汉式单例：" class="headerlink" title="饿汉式单例："></a>饿汉式单例：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package SheJiMoShi;</span><br><span class="line">//饿汉式单例</span><br><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton singleton = new Singleton();</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public  static Singleton getSingletonInstance()&#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package SheJiMoShi;</span><br><span class="line"></span><br><span class="line">//懒汉式单例</span><br><span class="line">public class Singleton2 &#123;</span><br><span class="line">    private static Singleton2 singleton2;</span><br><span class="line">    private Singleton2()&#123;&#125;</span><br><span class="line">    public static synchronized Singleton2 getSingleton2()&#123;</span><br><span class="line">        if (singleton2 == null)&#123;</span><br><span class="line">            singleton2 = new Singleton2();</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="单例模式还有一种比较常见的形式：双重锁的形式"><a href="#单例模式还有一种比较常见的形式：双重锁的形式" class="headerlink" title="单例模式还有一种比较常见的形式：双重锁的形式"></a>单例模式还有一种比较常见的形式：双重锁的形式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package SheJiMoShi;</span><br><span class="line">//双重锁的形式单例</span><br><span class="line">public class Singleton3 &#123;</span><br><span class="line">    private static volatile Singleton3 singleton3 =null;</span><br><span class="line">    private Singleton3()&#123;&#125;</span><br><span class="line">    public static Singleton3 getSingleton3()&#123;</span><br><span class="line">        if (singleton3 == null)&#123;</span><br><span class="line">            synchronized (Singleton3.class)&#123;</span><br><span class="line">                if (singleton3 == null)&#123;</span><br><span class="line">                    singleton3 = new Singleton3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个模式将同步内容下方到if内部，提高了执行的效率，不必每次获取对象时都进行同步，只有第一次才同步，创建了以后就没必要了。<br>        这种模式中双重判断加同步的方式，比第一个例子中的效率大大提升，因为如果单层if判断，在服务器允许的情况下，假设有一百个线程，耗费的时间为100*（同步判断时间+if判断时间），而如果双重if判断，100的线程可以同时if判断，理论消耗的时间只有一个if判断的时间。<br>        所以如果面对高并发的情况，而且采用的是懒汉模式，最好的选择就是双重判断加同步的方式。</p>
<h4 id="单例模式的优点："><a href="#单例模式的优点：" class="headerlink" title="单例模式的优点："></a>单例模式的优点：</h4><ul>
<li>1、在内存中只有一个对象，节省内存空间。</li>
<li>2、避免频繁的创建销毁对象，可以提高性能。</li>
<li>3、避免对共享资源的多重占用。</li>
<li>4、可以全局访问。</li>
</ul>
<h4 id="单例模式的缺点："><a href="#单例模式的缺点：" class="headerlink" title="单例模式的缺点："></a>单例模式的缺点：</h4><ul>
<li>1、扩展困难，由于getInstance静态函数没有办法生成子类的实例。如果要拓展，只有重写那个类。</li>
<li>2、隐式使用引起类结构不清晰。</li>
<li>3、导致程序内存泄露的问题。</li>
</ul>
<h4 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h4><p>   由于单例模式的以上优点，所以是编程中用的比较多的一种设计模式。以下为使用单例模式的场景：</p>
<ul>
<li>1、需要频繁实例化然后销毁的对象。</li>
<li>2、创建对象时耗时过多或者耗资源过多，但又经常用到的对象。</li>
<li>3、资源共享的情况下，避免由于资源操作时导致的性能或损耗等</li>
<li>4、控制资源的情况下，方便资源之间的互相通信。</li>
</ul>
<h4 id="单例模式注意事项："><a href="#单例模式注意事项：" class="headerlink" title="单例模式注意事项："></a>单例模式注意事项：</h4><pre><code>只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。
    不要做断开单例类对象与类中静态引用的危险操作。
    多线程使用单例使用共享资源时，注意线程安全问题。
</code></pre><h4 id="关于Java中单例模式的一些常见问题："><a href="#关于Java中单例模式的一些常见问题：" class="headerlink" title="关于Java中单例模式的一些常见问题："></a>关于Java中单例模式的一些常见问题：</h4><h5 id="单例模式的对象长时间不用会被jvm垃圾收集器收集吗？"><a href="#单例模式的对象长时间不用会被jvm垃圾收集器收集吗？" class="headerlink" title="单例模式的对象长时间不用会被jvm垃圾收集器收集吗？"></a>单例模式的对象长时间不用会被jvm垃圾收集器收集吗？</h5><p> 除非人为地断开单例中静态引用到单例对象的联接，否则jvm垃圾收集器是不会回收单例对象的。<br>jvm卸载类的判定条件如下：<br>        1、该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。<br>        2、加载该类的ClassLoader已经被回收。<br>        3、该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。<br>        只有三个条件都满足，jvm才会在垃圾收集的时候卸载类。显然，单例的类不满足条件一，因此单例类也不会被回收。</p>
<h5 id="在一个jvm中会出现多个单例吗"><a href="#在一个jvm中会出现多个单例吗" class="headerlink" title="在一个jvm中会出现多个单例吗"></a>在一个jvm中会出现多个单例吗</h5><p>在分布式系统、多个类加载器、以及序列化的的情况下，会产生多个单例，这一点是无庸置疑的。那么在同一个jvm中，会不会产生单例呢？使用单例提供的getInstance()方法只能得到同一个单例，除非是使用反射方式，将会得到新的单例。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forName(Singleton.class.getName());  </span><br><span class="line">Constructor ct = c.getDeclaredConstructor();  </span><br><span class="line">ct.setAccessible(true);  </span><br><span class="line">Singleton singleton = (Singleton)ct.newInstance();</span><br></pre></td></tr></table></figure></p>
<p>这样，每次运行都会产生新的单例对象。所以运用单例模式时，一定注意不要使用反射产生新的单例对象。</p>
<h5 id="在getInstance-方法上同步有优势还是仅同步必要的块更优优势？"><a href="#在getInstance-方法上同步有优势还是仅同步必要的块更优优势？" class="headerlink" title="在getInstance()方法上同步有优势还是仅同步必要的块更优优势？"></a>在getInstance()方法上同步有优势还是仅同步必要的块更优优势？</h5><p> 因为锁定仅仅在创建实例时才有意义，然后其他时候实例仅仅是只读访问的，因此只同步必要的块的性能更优，并且是更好的选择。<br>        缺点：只有在第一次调用的时候，才会出现生成2个对象，才必须要求同步。而一旦singleton 不为null，系统依旧花费同步锁开销，有点得不偿失。</p>
<h5 id="单例类可以被继承吗"><a href="#单例类可以被继承吗" class="headerlink" title="单例类可以被继承吗"></a>单例类可以被继承吗</h5><p> 根据单例实例构造的时机和方式不同，单例模式还可以分成几种。但对于这种通过私有化构造函数，静态方法提供实例的单例类而言，是不支持继承的。<br>        这种模式的单例实现要求每个具体的单例类自身来维护单例实例和限制多个实例的生成。但可以采用另外一种实现单例的思路：登记式单例，来使得单例对继承开放。</p>

    
        <div>
            <a href="/2018/07/20/单例模式/" class="post-more waves-button">
                阅读全文 »
            </a>
        </div>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-组合模式"
  class="article-card article-type-post" itemprop="blogPost">

    


  
    <h3 class="post-title" itemprop="name">
      <a href="/2018/07/20/组合模式/">组合模式</a>
    </h3>
  




     <div class="post-meta">
        <time class="post-time" title="2018-07-20 12:10:37" datetime="2018-07-20T04:10:37.797Z"  itemprop="datePublished">2018-07-20</time>

    </div>

    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式的设计动机：组合模式定义了如何将容器对象和叶子对象进行递归组合，使得客户在使用的过程中无须进行区分，可以对他们进行一致的处理。</p>
<h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>  组合模式组合多个对象形成树形结构以表示“整体-部分”的结构层次。</p>
<pre><code>组合模式对单个对象(叶子对象)和组合对象(组合对象)具有一致性，它将对象组织到树结构中，可以用来描述整体与部分的关系。同时它也模糊了简单元素(叶子对象)和复杂元素(容器对象)的概念，使得客户能够像处理简单元素一样来处理复杂元素，从而使客户程序能够与复杂元素的内部结构解耦。
</code></pre><h4 id="结构："><a href="#结构：" class="headerlink" title="结构："></a>结构：</h4><p>  组合模式主要包含如下几个角色：</p>
<pre><code>  1.Component ：组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component子部件。 
2.Leaf：叶子对象。叶子结点没有子结点。 
3.Composite：容器对象，定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关操作，如增加(add)和删除(remove)等。
</code></pre><p>  从模式结构中我们看出了叶子节点和容器对象都实现Component接口，这也是能够将叶子对象和容器对象一致对待的关键所在。</p>
<h4 id="模式实现："><a href="#模式实现：" class="headerlink" title="模式实现："></a>模式实现：</h4><p> 在文件系统中，可能存在很多种格式的文件，如果图片，文本文件、视频文件等等，这些不同的格式文件的浏览方式都不同，同时对文件夹的浏览就是对文件夹中文件的浏览，但是对于客户而言都是浏览文件，两者之间不存在什么差别，现在只用组合模式来模拟浏览文件</p>
<h5 id="首先是文件类：File-java"><a href="#首先是文件类：File-java" class="headerlink" title="首先是文件类：File.java"></a>首先是文件类：File.java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public abstract class File &#123;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    public File(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="然后是文件夹类：Folder-java，该类包含对文件的增加、删除和浏览三个方法"><a href="#然后是文件夹类：Folder-java，该类包含对文件的增加、删除和浏览三个方法" class="headerlink" title="然后是文件夹类：Folder.java，该类包含对文件的增加、删除和浏览三个方法"></a>然后是文件夹类：Folder.java，该类包含对文件的增加、删除和浏览三个方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class Folder extends File&#123;</span><br><span class="line">    private List&lt;File&gt; files;</span><br><span class="line">    </span><br><span class="line">    public Folder(String name)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">        files = new ArrayList&lt;File&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 浏览文件夹中的文件</span><br><span class="line">     */</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        for(File file : files)&#123;</span><br><span class="line">            file.display();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * @desc 向文件夹中添加文件</span><br><span class="line">     * @param file</span><br><span class="line">     * @return void</span><br><span class="line">     */</span><br><span class="line">    public void add(File file)&#123;</span><br><span class="line">        files.add(file);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * @desc 从文件夹中删除文件</span><br><span class="line">     * @param file</span><br><span class="line">     * @return void</span><br><span class="line">     */</span><br><span class="line">    public void remove(File file)&#123;</span><br><span class="line">        files.remove(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="然后是三个文件类：TextFile-java、ImageFile-java、VideoFile-java"><a href="#然后是三个文件类：TextFile-java、ImageFile-java、VideoFile-java" class="headerlink" title="然后是三个文件类：TextFile.java、ImageFile.java、VideoFile.java"></a>然后是三个文件类：TextFile.java、ImageFile.java、VideoFile.java</h5><h5 id="TextFile-java"><a href="#TextFile-java" class="headerlink" title="TextFile.java"></a>TextFile.java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class TextFile extends File&#123;</span><br><span class="line"></span><br><span class="line">    public TextFile(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;这是文本文件，文件名：&quot; + super.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ImageFile-java"><a href="#ImageFile-java" class="headerlink" title="ImageFile.java"></a>ImageFile.java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ImagerFile extends File&#123;</span><br><span class="line"></span><br><span class="line">    public ImagerFile(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;这是图像文件，文件名：&quot; + super.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="VideoFile-java"><a href="#VideoFile-java" class="headerlink" title="VideoFile.java"></a>VideoFile.java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class VideoFile extends File&#123;</span><br><span class="line"></span><br><span class="line">    public VideoFile(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;这是影像文件，文件名：&quot; + super.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最后是客户端"><a href="#最后是客户端" class="headerlink" title="最后是客户端"></a>最后是客户端</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 我们先建立一个这样的文件系统</span><br><span class="line">         *                  总文件</span><br><span class="line">         *                  </span><br><span class="line">         *   a.txt    b.jpg                   c文件夹              </span><br><span class="line">         *                      c_1.text  c_1.rmvb    c_1.jpg   </span><br><span class="line">         *                                                       </span><br><span class="line">         */ </span><br><span class="line">        //总文件夹</span><br><span class="line">        Folder zwjj = new Folder(&quot;总文件夹&quot;);</span><br><span class="line">        //向总文件夹中放入三个文件：1.txt、2.jpg、1文件夹</span><br><span class="line">        TextFile aText= new TextFile(&quot;a.txt&quot;);</span><br><span class="line">        ImagerFile bImager = new ImagerFile(&quot;b.jpg&quot;);</span><br><span class="line">        Folder cFolder = new Folder(&quot;C文件夹&quot;);</span><br><span class="line">        </span><br><span class="line">        zwjj.add(aText);</span><br><span class="line">        zwjj.add(bImager);</span><br><span class="line">        zwjj.add(cFolder);</span><br><span class="line">        </span><br><span class="line">        //向C文件夹中添加文件：c_1.txt、c_1.rmvb、c_1.jpg </span><br><span class="line">        TextFile cText = new TextFile(&quot;c_1.txt&quot;);</span><br><span class="line">        ImagerFile cImage = new ImagerFile(&quot;c_1.jpg&quot;);</span><br><span class="line">        VideoFile cVideo = new VideoFile(&quot;c_1.rmvb&quot;);</span><br><span class="line">        </span><br><span class="line">        cFolder.add(cText);</span><br><span class="line">        cFolder.add(cImage);</span><br><span class="line">        cFolder.add(cVideo);</span><br><span class="line">        </span><br><span class="line">        //遍历C文件夹</span><br><span class="line">        cFolder.display();</span><br><span class="line">        //将c_1.txt删除</span><br><span class="line">        cFolder.remove(cText);</span><br><span class="line">        System.out.println(&quot;-----------------------&quot;);</span><br><span class="line">        cFolder.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>1、可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，使得增加新构件也更容易。</li>
<li>2、客户端调用简单，客户端可以一致的使用组合结构或其中单个对象。</li>
<li>3、定义了包含叶子对象和容器对象的类层次结构，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，可以形成复杂的树形结构。</li>
<li>4、更容易在组合体内加入对象构件，客户端不必因为加入了新的对象构件而更改原有代码。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><pre><code>1，你想表示对象的部分-整体层次结构
2，你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。
</code></pre><h4 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h4><pre><code>1、 组合模式用于将多个对象组合成树形结构以表示“整体-部分”的结构层次。组合模式对单个对象（叶子对象）和组合对象（容器对象）的使用具有一致性。

2、 组合对象的关键在于它定义了一个抽象构建类，它既可表示叶子对象，也可表示容器对象，客户仅仅需要针对这个抽象构建进行编程，无须知道他是叶子对象还是容器对象，都是一致对待。

3、 组合模式虽然能够非常好地处理层次结构，也使得客户端程序变得简单，但是它也使得设计变得更加抽象，而且也很难对容器中的构件类型进行限制，这会导致在增加新的构件时会产生一些问题。
</code></pre>
    
        <div>
            <a href="/2018/07/20/组合模式/" class="post-more waves-button">
                阅读全文 »
            </a>
        </div>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-集合框架二"
  class="article-card article-type-post" itemprop="blogPost">

    


  
    <h3 class="post-title" itemprop="name">
      <a href="/2018/07/20/集合框架二/">java 基础知识</a>
    </h3>
  




     <div class="post-meta">
        <time class="post-time" title="2018-07-20 12:10:37" datetime="2018-07-20T04:10:37.797Z"  itemprop="datePublished">2018-07-20</time>

    </div>

    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h3 id="集合框架二"><a href="#集合框架二" class="headerlink" title="集合框架二"></a>集合框架二</h3><h4 id="7、集合类各容器方法："><a href="#7、集合类各容器方法：" class="headerlink" title="7、集合类各容器方法："></a>7、集合类各容器方法：</h4><p>接口Collection方法摘要(没有构造方法)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a)添加：</span><br><span class="line">i.  boolean add(E e)</span><br><span class="line"></span><br><span class="line">j.  boolean addAll(Collection c)</span><br><span class="line">b)删除：</span><br><span class="line">i.  void clear():清空容器</span><br><span class="line">j.  boolean remove(Objec object):</span><br><span class="line">k.  boolean removeAll(Collection c):</span><br><span class="line">c)判断：</span><br><span class="line">i.  boolean contains(Object object):判断是否包含此元素</span><br><span class="line">j.  boolean containsAll(Collection c):判断是否包含一堆元素</span><br><span class="line">k.  boolean equals(Object object):比较此collection与指定对象是否相等</span><br><span class="line">m.  boolean isEmpty():判断是否集合为空</span><br><span class="line">d)获取：</span><br><span class="line">h.  Iterator iterator():取出</span><br><span class="line">i.  int hashCode():返回此collection的哈希值</span><br><span class="line">j.  int size():返回此collection中元素的个数</span><br><span class="line">k.  boolean retainAll(Collection c):取交集</span><br><span class="line">m.  Object toArray():返回此collection中所有元素的数组</span><br><span class="line">n.  T[] toArray(T[] a):返回包含此collection中所有元素的数值。</span><br></pre></td></tr></table></figure></p>
<h4 id="List集合子类及其方法"><a href="#List集合子类及其方法" class="headerlink" title="List集合子类及其方法"></a>List集合子类及其方法</h4><ul>
<li>(1)List接口是Collection接口的一个子接口。</li>
<li>(2)List接口中的元素有如下特点(对角标的操作都是特有方法，因为有序)：<br>A:元素有序(存储顺序和取出顺序一致)<br>B:元素可以重复</li>
<li>(3)List接口中的特有方法<br>A:add(int index,Object obj):在指定位置加入元素<br>B:remove(int index):移除指定位置的元素<br>C:set(int index,Object obj):修改指定位置的元素<br>D:get(int index):获取指定位置的元素<br>E:indexOf(Object obj):获取指定元素的位置<br>F:subList(int start,int end):从一个大的List中截取一个小的List<br>G:listIterator():返回一个List接口特有的迭代器</li>
</ul>
<h4 id="1-、ArrayList："><a href="#1-、ArrayList：" class="headerlink" title="(1)、ArrayList："></a>(1)、ArrayList：</h4><p>构造方法摘要：(少用，不是重点)<br>ArrayList()：构造一个初始容量为 10 的空列表。<br>ArrayList(Collection&lt;? extends E&gt; c)： 构造一个包含指定 collection 的元素的列表，</p>
<p>ArrayList(int initialCapacity)： 构造一个具有指定初始容量的空列表。<br>    方法摘要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">添加：</span><br><span class="line">boolean add(E e)： 将指定的元素添加到此列表的尾部。</span><br><span class="line">void add(int index, E element)： 将指定的元素插入此列表中的指定位置。</span><br><span class="line">boolean addAll(Collection&lt;? extends E&gt; c):按照指定 collection 的迭代器所返回的元素顺序，</span><br><span class="line">将该 collection 中的所有元素添加到此列表的尾部 </span><br><span class="line">boolean addAll(int index, Collection&lt;? extends E&gt; c)： 从指定的位置开始，将指定 collection</span><br><span class="line">      中的所有元素插入到此列表中。 </span><br><span class="line">删除：</span><br><span class="line">void clear(): 移除此列表中的所有元素。</span><br><span class="line"> remove(int index): 移除此列表中指定位置上的元素。 </span><br><span class="line">boolean remove(Object o): 移除此列表中首次出现的指定元素（如果存在）。</span><br><span class="line">protected  void removeRange(int fromIndex, int toIndex): </span><br><span class="line">移除列表中索引在 fromIndex（包括）和 toIndex（不包括）之间的所有元素。</span><br><span class="line">boolean removeAll(Collection&lt;?&gt; c): 从列表中移除指定 collection 中包含的其所有元素 </span><br><span class="line">|获取：</span><br><span class="line"> get(int index): 返回此列表中指定位置上的元素。</span><br><span class="line">int indexOf(Object o): 返回此列表中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1。</span><br><span class="line">int lastIndexOf(Object o) 返回此列表中最后一次出现的指定元素的索引，或如果此列表不包含索引，则返回 -1。   </span><br><span class="line">public List&lt;E&gt; subList(int fromIndex,int toIndex): 返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的部分视图。</span><br><span class="line">Iterator&lt;E&gt; iterator(): 返回按适当顺序在列表的元素上进行迭代的迭代器。</span><br><span class="line">ListIterator&lt;E&gt; listIterator(int index):返回列表中元素的列表迭代器(按适当顺序),从列表的指定位置开始。</span><br><span class="line">修改：(特有方法！！)</span><br><span class="line"> set(int index, E element): 用指定的元素替代此列表中指定位置上的元素。</span><br></pre></td></tr></table></figure></p>
<h4 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="(2)LinkedList:"></a>(2)LinkedList:</h4><p>构造方法摘要：<br>LinkedList(): 构造一个空列表。<br>LinkedList(Collection&lt;? extends E&gt; c): 构造一个包含指定 collection 中的元素的列表，<br>      这些元素按其 collection 的迭代器返回的顺序排列。<br>方法摘要:(特有的)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">添加</span><br><span class="line">void addFirst(E e): 将指定元素插入此列表的开头。 </span><br><span class="line">void addLast(E e): 将指定元素添加到此列表的结尾。 </span><br><span class="line">获取元素，但不删除元素</span><br><span class="line"> get(int index): 返回此列表中指定位置处的元素。           </span><br><span class="line"> getFirst(): 返回此列表的第一个元素。          </span><br><span class="line"> getLast(): 返回此列表的最后一个元素。</span><br><span class="line">获取元素且删除元素</span><br><span class="line"> remove()： 获取并移除此列表的头（第一个元素）。          </span><br><span class="line"> remove(int index)： 移除此列表中指定位置处的元素。         </span><br><span class="line">boolean remove(Object o)： 从此列表中移除首次出现的指定元素（如果存在）。         </span><br><span class="line"> removeFirst()： 移除并返回此列表的第一个元素。 </span><br><span class="line"> removeLast(): 移除并返回此列表的最后一个元素。</span><br><span class="line">修改</span><br><span class="line"> set(int index, E element) 将此列表中指定位置的元素替换为指定的元素。 </span><br><span class="line">#### (3)Vector</span><br><span class="line">构造方法摘要：</span><br><span class="line">Vector(): 构造一个空向量，使其内部数据数组的大小为 10，其标准容量增量为零。          </span><br><span class="line">Vector(Collection&lt;? extends E&gt; c):  构造一个包含指定 collection 中的元素的向量，</span><br><span class="line">   这些元素按其 collection 的迭代器返回元素的顺序排列。</span><br></pre></td></tr></table></figure></p>
<p>方法摘要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">添加：</span><br><span class="line">boolean add(E e): 将指定元素添加到此向量的末尾。</span><br><span class="line">void add(int index, E element): 在此向量的指定位置插入指定的元素。         </span><br><span class="line">boolean addAll(Collection&lt;? extends E&gt; c):</span><br><span class="line">将指定 Collection 中的所有元素添加到此向量的末尾， </span><br><span class="line">按照指定 collection 的迭代器所返回的顺序添加这些元素。 </span><br><span class="line">boolean addAll(int index, Collection&lt;? extends E&gt; c): 在指定位置将指定 Collection 中的所有元素插入到此向量中。</span><br><span class="line">获取:</span><br><span class="line">Enumeration&lt;E&gt; elements(): 返回此向量的组件的枚举。</span><br><span class="line">  Vector特有的取出方式:</span><br><span class="line">  枚举和迭代器很像，其实枚举和迭代器是一样的，只是因为枚举的名称和方法的名称</span><br><span class="line">  名字都过长，所以枚举被迭代器取代了。</span><br><span class="line">枚举Enumeration的方法摘要：</span><br><span class="line">boolean hasMoreElements(): 测试此枚举是否包含更多的元素。 </span><br><span class="line"> nextElement(): 如果此枚举对象至少还有一个可提供的元素，</span><br><span class="line"> 则返回此枚举的下一个元素。</span><br></pre></td></tr></table></figure></p>
<h4 id="Set集合子类及其方法"><a href="#Set集合子类及其方法" class="headerlink" title="Set集合子类及其方法"></a>Set集合子类及其方法</h4><p>(1)HashSet:它不保证set的迭代顺序;特别是它不保证该顺序恒久不变.此类允许使用null元素。<br>构造方法：<br>HashSet() 构造一个新的空 set，其底层 HashMap 实例的默认初始容量是 16，加载因子是 0.75。<br>HashSet(Collection&lt;? extends E&gt; c) 构造一个包含指定 collection 中的元素的新 set。<br>方法摘要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">boolean add(E e) 如果此 set 中尚未包含指定元素，则添加指定元素。   </span><br><span class="line">void clear() 从此 set 中移除所有元素。</span><br><span class="line"> </span><br><span class="line">Object clone() 返回此 HashSet 实例的浅表副本：并没有复制这些元素本身。  </span><br><span class="line">boolean contains(Object o) 如果此 set 包含指定元素，则返回 true。  </span><br><span class="line">boolean isEmpty() 如果此 set 不包含任何元素，则返回 true。 </span><br><span class="line"> </span><br><span class="line">Iterator&lt;E&gt; iterator() 返回对此 set 中元素进行迭代的迭代器。  </span><br><span class="line">boolean remove(Object o) 如果指定元素存在于此 set 中，则将其移除。</span><br><span class="line">  </span><br><span class="line">int size() 返回此 set 中的元素的数量（set 的容量）。  </span><br><span class="line">(2)TreeSet:使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的 Comparator 进行排序.</span><br><span class="line">构造方法：</span><br><span class="line">TreeSet() 构造一个新的空 set，该set根据其元素的自然顺序进行排序。          </span><br><span class="line">TreeSet(Collection&lt;? extends E&gt; c) </span><br><span class="line">构造一个包含指定 collection 元素的新 TreeSet，它按照其元素的自然顺序进行排序。 </span><br><span class="line">TreeSet(Comparator&lt;? super E&gt; comparator)  构造一个新的空 TreeSet，它根据指定比较器进行排序。</span><br></pre></td></tr></table></figure></p>
<p>方法摘要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">添加：</span><br><span class="line">boolean add(E e)  将指定的元素添加到此 set（如果该元素尚未存在于 set 中）。</span><br><span class="line">boolean addAll(Collection&lt;? extends E&gt; c) 将指定 collection 中的所有元素添加到此 set 中。</span><br><span class="line">删除：</span><br><span class="line"> void clear() 移除此 set 中的所有元素。 </span><br><span class="line"> boolean remove(Object o)  将指定的元素从 set 中移除（如果该元素存在于此 set 中）。 </span><br><span class="line">  pollFirst() 获取并移除第一个（最低）元素；如果此 set 为空，则返回 null。 </span><br><span class="line">  pollLast() 获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。 </span><br><span class="line">获取：</span><br><span class="line"> Iterator&lt;E&gt; iterator()  返回在此 set 中的元素上按升序进行迭代的迭代器。</span><br><span class="line"> first() 返回此 set 中当前第一个（最低）元素。</span><br><span class="line">  last() 返回此 set 中当前最后一个（最高）元素。</span><br><span class="line"> int size()  返回 set 中的元素数（set 的容量）。</span><br><span class="line">判断：</span><br><span class="line">boolean isEmpty()  如果此 set 不包含任何元素，则返回 true。 </span><br><span class="line">boolean contains(Object o) 如果此 set 包含指定的元素，则返回 true。 </span><br><span class="line">Map:将键映射到值的对象。Map集合没有迭代器！Map集合特点：该集合存储键值对。而且键是唯一的。</span><br><span class="line">方法摘要：</span><br></pre></td></tr></table></figure></p>
<p>   添加：<br>     V put(K key, V value) 将指定的值与此映射中的指定键关联（可选操作）。<br>     void putAll(Map&lt;? extends K,? extends V&gt; m) 从指定映射中将所有映射关系复制到此映射中<br>   删除：<br>              void clear()  从此映射中移除所有映射关系（可选操作）。<br>     V remove(Object key) 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。<br>   判断<br>     boolean containsKey(Object key) 如果此映射包含指定键的映射关系，则返回 true。<br>              boolean containsValue(Object value) 如果此映射将一个或多个键映射到指定值，则返回 true。<br>              boolean isEmpty() 如果此映射未包含键-值映射关系，则返回 true。<br>           获取<br>     int size() 返回此映射中的键-值映射关系数。<br>              Collection<v> values()  返回此映射中包含的值的 Collection 视图。<br><code>`</code></v></p>
<h5 id="重点：Map集合没有迭代器，以下是Map的两种取出方式："><a href="#重点：Map集合没有迭代器，以下是Map的两种取出方式：" class="headerlink" title="重点：Map集合没有迭代器，以下是Map的两种取出方式："></a>重点：Map集合没有迭代器，以下是Map的两种取出方式：</h5><ul>
<li>第一种：Set<k> keySet()<br>返回此映射中包含的键的Set视图，将Map集合中所有的键存入Set集合，然后再通过Set集合的<br>迭代器取出所有的键，再根据get方法获取每个键的值；</k></li>
<li>第二种：Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()<br>返回此映射中包含的映射关系的Set视图，将Map集合中的映射关系存入到Set集合中，<br>这个映射关系的数据类型是Map.entry,再通过Map.Entry类的方法再要取出关系里面的键和值<br>Map.Entry的方法摘要：<br>boolean equals(Object o)  比较指定对象与此项的相等性。</li>
</ul>
<p>K getKey()  返回与此项对应的键。</p>
<p>V getValue() 返回与此项对应的值。</p>
<p>int hashCode() 返回此映射项的哈希码值。<br>V setValue(V value) 用指定的值替换与此项对应的值(特有！！！)。</p>

    
        <div>
            <a href="/2018/07/20/集合框架二/" class="post-more waves-button">
                阅读全文 »
            </a>
        </div>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/集合框架二/">集合框架二</a></li></ul>

    </div>
    
</article>

        </li>
    
    </ul>

    
<nav id="page-nav">
    <div class="inner">
    <a class="extend prev" rel="prev" href="/page/5/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/7/">下一页</a>
    </div>
</nav>


</div>

        <footer class="footer">
    <div class="footer-content">
        <span class="power">
            <i class="icon icon-lg icon-copyright"></i>
            2018
            <i class="icon icon-lg icon-heart"></i>
            <a href="http://yoursite.com">qin12.github.io</a>
            <br/>
            Power by
            <a href="https://hexo.io/" target="_blank" rel="external nofollow">Hexo</a>&nbsp;·&nbsp;
            Theme
            <a class="tomotoeslink" href="https://github.com/tomotoes/hexo-theme-tomotoes/" target="_blank" rel="external nofollow">tomotoes</a>
        </span>

        <br/>

        <span id="RunTime" style="color:#a7a7a2;"></span>
        <br/>

        <span>
            
	<i class="icon icon-lg icon-user">
<span id="busuanzi_container_site_uv" style='display:none'>
       访问用户：<span id="busuanzi_value_site_uv"></span>
    </span>人</i>
    ·
    <i class="icon icon-lg icon-eye">
    <span id="busuanzi_container_site_pv" style='display:none'>
      访问次数：<span id="busuanzi_value_site_pv"></span>
    </span>次
    </i>


        </span>
        <br/>

        <span class="license"><a  target="_blank" rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">博客内容遵循 知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
    </div>
</footer>

    </main>
    
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>


    <!-- waves按钮特效 -->
<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<!-- 主题配置脚本 -->
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };
</script>

<!-- jquery -->
<script src="/js/jquery.min.js?v=3.0"></script>

<!-- 搜索 -->

<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item waves-block waves-effect" onclick="location.href='{path}'">
    <div class="title ellipsis" title="{title}">{title}</div>
</li>
</template>


<!-- main博客脚本 -->
<script src="/js/main.min.js?v=3.0" ></script>

<!-- 动画&配置 -->
<script src="/js/script.min.js?v=3.0" ></script>

<!-- 脚本管理 -->
<script>

if(window.innerWidth > 800){
	/* 3D标题 */
	$(".content-header").on("mousemove", threedee);

	/* 底部追随鼠标 */
	$(".footer").hover(2);

	/* gotop键的涟漪 */
	$("#gotop").hover(1);

	/* 赞赏的粒子雨 */
	$("#reward").hover(3);

	/* 微信公众号的底部渲染 */
	$("#wechat").hover(4);

    /* 标题跳动 */
    $(".archivestitle").bumpyText();

	/* 图片点击放大 */
	const postimg = jQuery(".post-content img:not(.github-emoji)");
	postimg.on("click",function(){

		mask.classList.add("in");
		main.classList.add("Mask");
		menu.classList.add("Mask");
		var myimg = this.cloneNode(true);
		myimg.classList.add("imgShow");

		setTimeout(function(){
			jQuery(myimg).animate({
				opacity:"1"
			},1000);
		},0);

		document.body.appendChild(myimg);

		myimg.onclick=function(){
			document.body.removeChild(myimg);
			mask.classList.remove("in");
			main.classList.remove("Mask");
			menu.classList.remove("Mask");
		};

	});

}

/* 名字跳动 */
$("#name").bumpyText();


/* 网站运行时间 */
setInterval(function () {
	setTime("2017/10/11");
}, 1000);

/* 文章块的淡出 */
postshow();

/* 座右铭 */

   getHitokoto();



/* 粘贴提示 */
G($(".post-content"), location.href, "Qgx");


/* 控制台 */
if (window.console && window.console.log) {
	setTimeout(function () {
		console.log("\n %c 一个坏掉的番茄 %c  © Simon Ma  http://tomotoes.com \n\n", "color:#FFFFFB;background:#1abc9c;padding:5px 0;border-radius:.5rem 0 0 .5rem;", "color:#FFFFFB;background:#080808;padding:5px 0;border-radius:0 .5rem .5rem 0;");
	}, 0);
}

</script>




<!-- 公式渲染 -->



<!-- 不蒜子 -->

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script>


</body>
</html>
