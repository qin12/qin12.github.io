<!DOCTYPE html>






  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.2.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.jpg?v=6.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.2.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="漫漫长路，伴你同行">
<meta property="og:type" content="website">
<meta property="og:title" content="qin12的学习博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="qin12的学习博客">
<meta property="og:description" content="漫漫长路，伴你同行">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="qin12的学习博客">
<meta name="twitter:description" content="漫漫长路，伴你同行">



  <link rel="alternate" href="/atom.xml" title="qin12的学习博客" type="application/atom+xml" />




  <link rel="canonical" href="http://yoursite.com/page/2/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>qin12的学习博客</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">qin12的学习博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">只为成功找方法，不为失败找借口！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>




<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-photo">
    <a href="/photo/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-photo"></i> <br />摄影</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-music">
    <a href="/music/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-music"></i> <br />音乐</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/20/Apache下https服务的配置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qgx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qin12的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/Apache下https服务的配置/" itemprop="url">
                  Apache下https服务的配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-20 12:10:37" itemprop="dateCreated datePublished" datetime="2018-07-20T12:10:37+08:00">2018-07-20</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/javaEE/" itemprop="url" rel="index"><span itemprop="name">javaEE</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Apache下https服务的配置"><a href="#Apache下https服务的配置" class="headerlink" title="Apache下https服务的配置"></a>Apache下https服务的配置</h3><h4 id="1-下载证书，一般为四个文件"><a href="#1-下载证书，一般为四个文件" class="headerlink" title="1.下载证书，一般为四个文件"></a>1.下载证书，一般为四个文件</h4><p>注意：服务器不一样，证书的数量可能不一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">214132021230522.key</span><br><span class="line">214132021230522.pem</span><br><span class="line">chain.pem</span><br><span class="line">public.pem</span><br></pre></td></tr></table></figure></p>
<h4 id="2-在apache的配置文件-httpd-conf-中-对以下两句话取消注释"><a href="#2-在apache的配置文件-httpd-conf-中-对以下两句话取消注释" class="headerlink" title="2.在apache的配置文件(httpd.conf)中,对以下两句话取消注释"></a>2.在apache的配置文件(httpd.conf)中,对以下两句话取消注释</h4><p>注意：第一条加载ssl，第二天引入配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LoadModule ssl_module modules/mod_ssl.so</span><br><span class="line">Include conf/extra/httpd-ssl.conf</span><br></pre></td></tr></table></figure></p>
<h4 id="3-配置httpd-ssl-conf文件，加入主机信息和证书路径"><a href="#3-配置httpd-ssl-conf文件，加入主机信息和证书路径" class="headerlink" title="3.配置httpd-ssl.conf文件，加入主机信息和证书路径"></a>3.配置httpd-ssl.conf文件，加入主机信息和证书路径</h4><p>注意: 路径配置错误可能打不开服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Listen 443</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SSLPassPhraseDialog  builtin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SSLSessionCache        &quot;shmcb:/Apache24/logs/ssl_scache(512000)&quot;</span><br><span class="line">SSLSessionCacheTimeout  300</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;VirtualHost _default_:443&gt;</span><br><span class="line"></span><br><span class="line">DocumentRoot &quot;E:\web\public&quot;</span><br><span class="line">ServerName www.abc.com:443</span><br><span class="line">ServerAdmin admin@example.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SSLEngine on</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SSLCipherSuite ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP:+eNULL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SSLCertificateFile &quot;C:\Apache24\cert\www\public.pem&quot;</span><br><span class="line"></span><br><span class="line">SSLCertificateKeyFile &quot;C:\Apache24\cert\www\214132021230522.key&quot;</span><br><span class="line"></span><br><span class="line">SSLCertificateChainFile &quot;C:\Apache24\cert\www\chain.pem&quot;</span><br><span class="line"></span><br><span class="line">&lt;FilesMatch &quot;\.(cgi|shtml|phtml|php)$&quot;&gt;</span><br><span class="line">    SSLOptions +StdEnvVars</span><br><span class="line">&lt;/FilesMatch&gt;</span><br><span class="line">&lt;Directory &quot;/Apache24/cgi-bin&quot;&gt;</span><br><span class="line">    SSLOptions +StdEnvVars</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BrowserMatch &quot;.*MSIE.*&quot; \</span><br><span class="line">         nokeepalive ssl-unclean-shutdown \</span><br><span class="line">         downgrade-1.0 force-response-1.0</span><br><span class="line"></span><br><span class="line">#   Per-Server Logging:</span><br><span class="line">#   The home of a custom SSL log file. Use this when you want a</span><br><span class="line">#   compact non-error SSL logfile on a virtual host basis.</span><br><span class="line">CustomLog &quot;/Apache24/logs/ssl_request.log&quot; \</span><br><span class="line">          &quot;%t %h %&#123;SSL_PROTOCOL&#125;x %&#123;SSL_CIPHER&#125;x \&quot;%r\&quot; %b&quot;</span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>
<h4 id="4-在网站根目录的-htaccess文件中配置跳转"><a href="#4-在网站根目录的-htaccess文件中配置跳转" class="headerlink" title="4.在网站根目录的.htaccess文件中配置跳转"></a>4.在网站根目录的.htaccess文件中配置跳转</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line">RewriteEngine on</span><br><span class="line">RewriteBase /</span><br><span class="line">RewriteCond %&#123;SERVER_PORT&#125; !^443$</span><br><span class="line">RewriteRule ^.*$ https://%&#123;SERVER_NAME&#125;%&#123;REQUEST_URI&#125; [L,R]</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/20/一、HttpServletRequest介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qgx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qin12的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/一、HttpServletRequest介绍/" itemprop="url">
                  javaweb (九 )
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-20 12:10:37" itemprop="dateCreated datePublished" datetime="2018-07-20T12:10:37+08:00">2018-07-20</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/javaEE/" itemprop="url" rel="index"><span itemprop="name">javaEE</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、HttpServletRequest介绍"><a href="#一、HttpServletRequest介绍" class="headerlink" title="一、HttpServletRequest介绍"></a>一、HttpServletRequest介绍</h3><p>&amp;#8195&amp;#8195HttpServletRequest对象代表客户端的请求，当客户端通过HTTP协议访问服务器时，HTTP请求头中的所有信息都封装在这个对象中，通过这个对象提供的方法，可以获得客户端请求的所有信息。</p>
<h3 id="二、Request常用方法"><a href="#二、Request常用方法" class="headerlink" title="二、Request常用方法"></a>二、Request常用方法</h3><h4 id="2-1、获得客户机信息"><a href="#2-1、获得客户机信息" class="headerlink" title="2.1、获得客户机信息"></a>2.1、获得客户机信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　getRequestURL方法返回客户端发出请求时的完整URL。</span><br><span class="line">　　getRequestURI方法返回请求行中的资源名部分。</span><br><span class="line">　　getQueryString 方法返回请求行中的参数部分。</span><br><span class="line">　　getPathInfo方法返回请求URL中的额外路径信息。额外路径信息是请求URL中的位于Servlet的路径之后和查询参数之前的内容，它以“/”开头。</span><br><span class="line">　　getRemoteAddr方法返回发出请求的客户机的IP地址。</span><br><span class="line">　　getRemoteHost方法返回发出请求的客户机的完整主机名。</span><br><span class="line">　　getRemotePort方法返回客户机所使用的网络端口号。</span><br><span class="line">　　getLocalAddr方法返回WEB服务器的IP地址。</span><br><span class="line">　　getLocalName方法返回WEB服务器的主机名。</span><br></pre></td></tr></table></figure>
<p>范例：通过request对象获取客户端请求信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package qgx.request.study;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line">public class RequestDemo1 extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        //1.获取客户机信息</span><br><span class="line">        String requestUrl = req.getRequestURL().toString();//请求的URL地址</span><br><span class="line">        String requestUri = req.getRequestURI();//得到请求的资源</span><br><span class="line">        String queryString = req.getQueryString();//得到请求的URL地址中附带的参数</span><br><span class="line">        String remoteAddr = req.getRemoteAddr();//IP地址</span><br><span class="line">        String remoteHost = req.getRemoteHost();</span><br><span class="line">        int remotePort = req.getRemotePort();</span><br><span class="line">        String remoteUser = req.getRemoteUser();</span><br><span class="line">        String method = req.getMethod();//得到请求URL地址时使用的方法</span><br><span class="line">        String pathInfo = req.getPathInfo();</span><br><span class="line">        String localAddr = req.getLocalAddr();//获取WEB服务器的IP地址</span><br><span class="line">        String localName = req.getLocalName();//获取WEB服务器的主机名</span><br><span class="line">        resp.setCharacterEncoding(&quot;UTF-8&quot;);//设置将字符以&quot;UTF-8&quot;编码输出到客户端浏览器</span><br><span class="line">        //通过设置响应头控制浏览器以UTF-8的编码显示数据，如果不加这句话，那么浏览器显示的将是乱码</span><br><span class="line">       //2.显示数据</span><br><span class="line">        resp.setHeader(&quot;content-type&quot;, &quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        out.write(&quot;获取到的客户机信息如下：&quot;);</span><br><span class="line">        out.write(&quot;&lt;hr/&gt;&quot;);</span><br><span class="line">        out.write(&quot;请求的URL地址：&quot; + requestUrl);</span><br><span class="line">        out.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">        out.write(&quot;请求的资源：&quot; + requestUri);</span><br><span class="line">        out.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">        out.write(&quot;请求的URL地址中附带的参数：&quot; + queryString);</span><br><span class="line">        out.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">        out.write(&quot;来访者的IP地址：&quot; + remoteAddr);</span><br><span class="line">        out.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">        out.write(&quot;来访者的主机名：&quot; + remoteHost);</span><br><span class="line">        out.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">        out.write(&quot;使用的端口号：&quot; + remotePort);</span><br><span class="line">        out.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">        out.write(&quot;remoteUser：&quot; + remoteUser);</span><br><span class="line">        out.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">        out.write(&quot;请求使用的方法：&quot; + method);</span><br><span class="line">        out.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">        out.write(&quot;pathInfo：&quot; + pathInfo);</span><br><span class="line">        out.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">        out.write(&quot;localAddr：&quot; + localAddr);</span><br><span class="line">        out.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">        out.write(&quot;localName：&quot; + localName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/request.png" alt=""></p>
<h4 id="2-2、获得客户机请求头"><a href="#2-2、获得客户机请求头" class="headerlink" title="2.2、获得客户机请求头"></a>2.2、获得客户机请求头</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　getHeader(string name)方法:String </span><br><span class="line">　　getHeaders(String name)方法:Enumeration </span><br><span class="line">　　getHeaderNames()方法</span><br></pre></td></tr></table></figure>
<p>范例：通过request对象获取客户端请求头信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package qgx.request.study;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.util.Enumeration;</span><br><span class="line"></span><br><span class="line">@WebServlet(name = &quot;RequestDemo2&quot;)</span><br><span class="line">public class RequestDemo2 extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        response.setCharacterEncoding(&quot;UTF-8&quot;);//设置将字符以&quot;UTF-8&quot;编码输出到客户端浏览器</span><br><span class="line">        //通过设置响应头控制浏览器以UTF-8的编码显示数据</span><br><span class="line">        response.setHeader(&quot;content-type&quot;, &quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        Enumeration&lt;String&gt; reqHeadInfos = request.getHeaderNames();//获取所有的请求头</span><br><span class="line">        out.write(&quot;获取到的客户端所有的请求头信息如下：&quot;);</span><br><span class="line">        out.write(&quot;&lt;hr/&gt;&quot;);</span><br><span class="line">        while (reqHeadInfos.hasMoreElements()) &#123;</span><br><span class="line">            String headName = (String) reqHeadInfos.nextElement();</span><br><span class="line">            String headValue = request.getHeader(headName);//根据请求头的名字获取对应的请求头的值</span><br><span class="line">            out.write(headName + &quot;:--------:&quot; + headValue);</span><br><span class="line">            out.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        out.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">        out.write(&quot;获取到的客户端Accept-Encoding请求头的值：&quot;);</span><br><span class="line">        out.write(&quot;&lt;hr/&gt;&quot;);</span><br><span class="line">        String value = request.getHeader(&quot;Accept-Encoding&quot;);//获取Accept-Encoding请求头对应的值</span><br><span class="line">        out.write(value);</span><br><span class="line"></span><br><span class="line">        Enumeration&lt;String&gt; e = request.getHeaders(&quot;Accept-Encoding&quot;);</span><br><span class="line">        while (e.hasMoreElements()) &#123;</span><br><span class="line">            String string = (String) e.nextElement();</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/request2.png" alt=""></p>
<h4 id="获得客户机请求参数-客户端提交的数据"><a href="#获得客户机请求参数-客户端提交的数据" class="headerlink" title="获得客户机请求参数(客户端提交的数据)"></a>获得客户机请求参数(客户端提交的数据)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getParameter(String)方法(常用)</span><br><span class="line">getParameterValues(String name)方法(常用)</span><br><span class="line">getParameterNames()方法(不常用)</span><br><span class="line">getParameterMap()方法(编写框架时常用)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: qgx</span><br><span class="line">  Date: 2018/5/16</span><br><span class="line">  Time: 22:38</span><br><span class="line">  To change this template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Html的From表单元素&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;fieldset style=&quot;width:500px;&quot;&gt;</span><br><span class="line">    &lt;legend&gt;Html的Form表单元素&lt;/legend&gt;</span><br><span class="line">    &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/RequestDemo3&quot; method=&quot;post&quot;&gt;</span><br><span class="line">        编&amp;nbsp;&amp;nbsp;号(文本框)：</span><br><span class="line">        &lt;!--输入文本框，SIZE表示显示长度，maxlength表示最多输入长度--&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;userid&quot; value=&quot;NO.1&quot; size=&quot;2&quot; maxlength=&quot;2&quot;&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;!--输入文本框，通过value指定其显示的默认值--&gt;</span><br><span class="line">        用户名(文本框)：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;刘俭梅&quot;&gt;&lt;br&gt;</span><br><span class="line">        &lt;!--密码框，其中所有输入的内容都以密文的形式显示--&gt;</span><br><span class="line">        密&amp;nbsp;&amp;nbsp;码(密码框)：</span><br><span class="line">        &lt;input type=&quot;password&quot; name=&quot;userpassword&quot; value=&quot;请输入密码&quot;&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;!--单选按钮，通过checked指定默认选中，名称必须一样，其中value为真正需要的内容--&gt;</span><br><span class="line">        性&amp;nbsp;&amp;nbsp;别(单选框)：</span><br><span class="line">        &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; &gt;男</span><br><span class="line">        &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;checked&gt;女</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;!--下拉列表框，通过&lt;option&gt;元素指定下拉的选项--&gt;</span><br><span class="line">        学&amp;nbsp;&amp;nbsp;校(下拉框)：</span><br><span class="line">        &lt;select name=&quot;dept&quot;&gt;</span><br><span class="line">            &lt;option value=&quot;衢州学院&quot;SELECTED&gt;衢州学院&lt;/option&gt;</span><br><span class="line">            &lt;option value=&quot;中北大学&quot; &gt;中北大学&lt;/option&gt;</span><br><span class="line">            &lt;option value=&quot;衢职&quot;&gt;衢职&lt;/option&gt;</span><br><span class="line">        &lt;/select&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;!--复选框，可以同时选择多个选项，名称必须一样，其中value为真正需要的内容--&gt;</span><br><span class="line">        兴&amp;nbsp;&amp;nbsp;趣(复选框)：</span><br><span class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;inst&quot; value=&quot;唱歌&quot; checked&gt;唱歌</span><br><span class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;inst&quot; value=&quot;游泳&quot;&gt;游泳</span><br><span class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;inst&quot; value=&quot;跳舞&quot;&gt;跳舞</span><br><span class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;inst&quot; value=&quot;编程&quot;&gt;编程</span><br><span class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;inst&quot; value=&quot;上网&quot;&gt;上网</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;!--大文本输入框，宽度为34列，高度为5行--&gt;</span><br><span class="line">        备&amp;nbsp;&amp;nbsp;注(文本域)：</span><br><span class="line">        &lt;textarea name=&quot;note&quot; cols=&quot;34&quot; rows=&quot;5&quot;&gt;</span><br><span class="line">     &lt;/textarea&gt;</span><br><span class="line">           &lt;br&gt;</span><br><span class="line">            &lt;!--隐藏域，在页面上无法看到，专门用来传递参数或者保存参数--&gt;</span><br><span class="line">           &lt;input type=&quot;hidden&quot; name=&quot;hiddenField&quot; value=&quot;hiddenvalue&quot;/&gt;</span><br><span class="line">            &lt;!--提交表单按钮，当点击提交后，所有填写的表单内容都会被传输到服务器端--&gt;</span><br><span class="line">             &lt;input type=&quot;submit&quot; value=&quot;提交(提交按钮)&quot;&gt;</span><br><span class="line">            &lt;!--重置表单按钮，当点击重置后，所有表单恢复原始显示内容--&gt;</span><br><span class="line">            &lt;input type=&quot;reset&quot; value=&quot;重置(重置按钮)&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">    &lt;!--表单结束--&gt;</span><br><span class="line">&lt;/fieldset&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/img/request3.png" alt=""><br>在服务器端使用getParameter方法和getParameterValues方法接收表单参数，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package qgx.request.study;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.text.MessageFormat;</span><br><span class="line"></span><br><span class="line">@WebServlet(name = &quot;RequestDemo3&quot;)</span><br><span class="line">public class RequestDemo3 extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        request.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        String userid = request.getParameter(&quot;userid&quot;);//获取填写的编号</span><br><span class="line">        String username = request.getParameter(&quot;username&quot;);</span><br><span class="line">        String userpass = request.getParameter(&quot;userpass&quot;);</span><br><span class="line">        String sex = request.getParameter(&quot;sex&quot;);//获取选中的性别</span><br><span class="line">        String school = request.getParameter(&quot;school&quot;);//获取选中的学校</span><br><span class="line">        String[] insts = request.getParameterValues(&quot;inst&quot;);</span><br><span class="line">        String note = request.getParameter(&quot;note&quot;);//获取填写的说明信息</span><br><span class="line">        String hiddenField = request.getParameter(&quot;hiddenField&quot;);//获取隐藏域的内容</span><br><span class="line">        String instStr = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 获取数组数据的技巧，可以避免insts数组为null时引发的空指针异常错误！</span><br><span class="line">         */</span><br><span class="line">        for (int i = 0; insts != null &amp;&amp; i &lt; insts.length; i++) &#123;</span><br><span class="line">            if (i == insts.length - 1) &#123;</span><br><span class="line">                instStr += insts[i];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                instStr += insts[i] + &quot;,&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String htmlStr = &quot;&lt;table&gt;&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;&lt;td&gt;填写的编号：&lt;/td&gt;&lt;td&gt;&#123;0&#125;&lt;/td&gt;&lt;/tr&gt;&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;&lt;td&gt;填写的用户名：&lt;/td&gt;&lt;td&gt;&#123;1&#125;&lt;/td&gt;&lt;/tr&gt;&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;&lt;td&gt;填写的密码：&lt;/td&gt;&lt;td&gt;&#123;2&#125;&lt;/td&gt;&lt;/tr&gt;&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;&lt;td&gt;选中的性别：&lt;/td&gt;&lt;td&gt;&#123;3&#125;&lt;/td&gt;&lt;/tr&gt;&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;&lt;td&gt;选中的学校：&lt;/td&gt;&lt;td&gt;&#123;4&#125;&lt;/td&gt;&lt;/tr&gt;&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;&lt;td&gt;选中的兴趣：&lt;/td&gt;&lt;td&gt;&#123;5&#125;&lt;/td&gt;&lt;/tr&gt;&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;&lt;td&gt;填写的说明：&lt;/td&gt;&lt;td&gt;&#123;6&#125;&lt;/td&gt;&lt;/tr&gt;&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;&lt;td&gt;隐藏域的内容：&lt;/td&gt;&lt;td&gt;&#123;7&#125;&lt;/td&gt;&lt;/tr&gt;&quot; +</span><br><span class="line">                &quot;&lt;/table&gt;&quot;;</span><br><span class="line">        htmlStr = MessageFormat.format(htmlStr, userid, username, userpass, sex, school, instStr, note, hiddenField);</span><br><span class="line">        response.setCharacterEncoding(&quot;UTF-8&quot;);//设置服务器端以UTF-8编码输出数据到客户端</span><br><span class="line">        response.setContentType(&quot;text/html;charset=UTF-8&quot;);//设置客户端浏览器以UTF-8编码解析数据</span><br><span class="line">        response.getWriter().write(htmlStr);//输出htmlStr里面的内容到客户端浏览器显示</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/request4.png" alt=""></p>
<h5 id="在服务器端使用getParameterNames方法接收表单参数，代码如下："><a href="#在服务器端使用getParameterNames方法接收表单参数，代码如下：" class="headerlink" title="在服务器端使用getParameterNames方法接收表单参数，代码如下："></a>在服务器端使用getParameterNames方法接收表单参数，代码如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Enumeration&lt;String&gt; paramNames = request.getParameterNames();//获取所有的参数名</span><br><span class="line">        while (paramNames.hasMoreElements()) &#123;</span><br><span class="line">            String name = paramNames.nextElement();//得到参数名</span><br><span class="line">            String value = request.getParameter(name);//通过参数名获取对应的值</span><br><span class="line">            System.out.println(MessageFormat.format(&quot;&#123;0&#125;=&#123;1&#125;&quot;, name,value));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h5 id="在服务器端使用getParameterMap方法接收表单参数，代码如下"><a href="#在服务器端使用getParameterMap方法接收表单参数，代码如下" class="headerlink" title="在服务器端使用getParameterMap方法接收表单参数，代码如下:"></a>在服务器端使用getParameterMap方法接收表单参数，代码如下:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//request对象封装的参数是以Map的形式存储的</span><br><span class="line">        Map&lt;String, String[]&gt; paramMap = request.getParameterMap();</span><br><span class="line">       for(Map.Entry&lt;String, String[]&gt; entry :paramMap.entrySet())&#123;</span><br><span class="line">            String paramName = entry.getKey();</span><br><span class="line">            String paramValue = &quot;&quot;;</span><br><span class="line">            String[] paramValueArr = entry.getValue();</span><br><span class="line">             for (int i = 0; paramValueArr!=null &amp;&amp; i &lt; paramValueArr.length; i++) &#123;</span><br><span class="line">                if (i == paramValueArr.length-1) &#123;</span><br><span class="line">                    paramValue+=paramValueArr[i];</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    paramValue+=paramValueArr[i]+&quot;,&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;             System.out.println(MessageFormat.format(&quot;&#123;0&#125;=&#123;1&#125;&quot;, paramName,paramValue));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、request接收表单提交中文参数乱码问题"><a href="#三、request接收表单提交中文参数乱码问题" class="headerlink" title="三、request接收表单提交中文参数乱码问题"></a>三、request接收表单提交中文参数乱码问题</h3><h4 id="3-1、以POST方式提交表单中文参数的乱码问题"><a href="#3-1、以POST方式提交表单中文参数的乱码问题" class="headerlink" title="3.1、以POST方式提交表单中文参数的乱码问题"></a>3.1、以POST方式提交表单中文参数的乱码问题</h4><p>index2.jsp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: qgx</span><br><span class="line">  Date: 2018/5/25</span><br><span class="line">  Time: 22:17</span><br><span class="line">  To change this template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;request接收中文参数乱码问题&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;&lt;%=request.getContextPath()%&gt;/RequestDemo4&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;/&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;post方式提交表单&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/request5.png" alt=""><br>服务器端接受代码和结果显示如下：<br><img src="/img/request6.png" alt=""></p>
<h4 id="3-2、post方式提交中文数据乱码产生的原因和解决办法"><a href="#3-2、post方式提交中文数据乱码产生的原因和解决办法" class="headerlink" title="3.2、post方式提交中文数据乱码产生的原因和解决办法"></a>3.2、post方式提交中文数据乱码产生的原因和解决办法</h4><ul>
<li>之所以会产生乱码，就是因为服务器和客户端沟通的编码不一致造成的，因此解决的办法是：在客户端和服务器之间设置一个统一的编码，之后就按照此编码进行数据的传输和接收。</li>
<li>由于客户端是以UTF-8字符编码将表单数据传输到服务器端的，因此服务器也需要设置以UTF-8字符编码进行接收，要想完成此操作，服务器可以直接使用从ServletRequest接口继承而来的”setCharacterEncoding(charset)”方法进行统一的编码设置。修改后的代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">       request.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">       String  username = request.getParameter(&quot;userName&quot;);</span><br><span class="line">       System.out.println(&quot;userName&quot;+username);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/request7.png" alt=""></p>
<h4 id="3-3、以GET方式提交表单中文参数的乱码问题"><a href="#3-3、以GET方式提交表单中文参数的乱码问题" class="headerlink" title="3.3、以GET方式提交表单中文参数的乱码问题"></a>3.3、以GET方式提交表单中文参数的乱码问题</h4><p>index3.jsp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: qgx</span><br><span class="line">  Date: 2018/5/25</span><br><span class="line">  Time: 22:17</span><br><span class="line">  To change this template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;request接收中文参数乱码问题&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;&lt;%=request.getContextPath()%&gt;/RequestDemo4&quot; method=&quot;get&quot;&gt;</span><br><span class="line">    用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;/&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;Get方式提交表单&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/request8.png" alt=""><br>那么这个中文乱码问题又该如何解决呢，是否可以通过request.setCharacterEncoding(“UTF-8”);设置服务器以UTF-8的编码进行接收这种方式来解决中文乱码问题呢，注意，对于以get方式传输的中文数据，通过request.setCharacterEncoding(“UTF-8”);这种方式是解决不了中文乱码问题，如下所示：<br><img src="/img/request9.png" alt=""></p>
<h4 id="3-4、get方式提交中文数据乱码产生的原因和解决办法"><a href="#3-4、get方式提交中文数据乱码产生的原因和解决办法" class="headerlink" title="3.4、get方式提交中文数据乱码产生的原因和解决办法"></a>3.4、get方式提交中文数据乱码产生的原因和解决办法</h4><p>对于以get方式传输的数据，request即使设置了以指定的编码接收数据也是无效的(至于为什么无效我也没有弄明白)，默认的还是使用ISO8859-1这个字符编码来接收数据，客户端以UTF-8的编码传输数据到服务器端，而服务器端的request对象使用的是ISO8859-1这个字符编码来接收数据，服务器和客户端沟通的编码不一致因此才会产生中文乱码的。解决办法：在接收到数据后，先获取request对象以ISO8859-1字符编码接收到的原始数据的字节数组，然后通过字节数组以指定的编码构建字符串，解决乱码问题。<br><img src="/img/request10.png" alt=""></p>
<h4 id="3-5、以超链接形式传递中文参数的乱码问题"><a href="#3-5、以超链接形式传递中文参数的乱码问题" class="headerlink" title="3.5、以超链接形式传递中文参数的乱码问题"></a>3.5、以超链接形式传递中文参数的乱码问题</h4><ul>
<li>客户端想传输数据到服务器，可以通过表单提交的形式，也可以通过超链接后面加参数的形式，例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/RequestDemo4?userName=&quot;刘俭梅&quot;&gt;点击&lt;/a&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>　　点击超链接，数据是以get的方式传输到服务器的，所以接收中文数据时也会产生中文乱码问题，而解决中文乱码问题的方式与上述的以get方式提交表单中文数据乱码处理问题的方式一致，如下所示：</p>
<p>1 String name = request.getParameter(“name”);<br>2 name =new String(name.getBytes(“ISO8859-1”), “UTF-8”);<br>　　另外，需要提的一点就是URL地址后面如果跟了中文数据，那么中文参数最好使用URL编码进行处理，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/RequestDemo4?userName=&lt;%=URLEncoder.encode(&quot;刘俭梅&quot;, &quot;UTF-8&quot;)%&gt;&quot;&gt;点击&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-6、提交中文数据乱码问题总结"><a href="#3-6、提交中文数据乱码问题总结" class="headerlink" title="3.6、提交中文数据乱码问题总结"></a>3.6、提交中文数据乱码问题总结</h4><ul>
<li><p>1、如果提交方式为post，想不乱码，只需要在服务器端设置request对象的编码即可，客户端以哪种编码提交的，服务器端的request对象就以对应的编码接收，比如客户端是以UTF-8编码提交的，那么服务器端request对象就以UTF-8编码接收(request.setCharacterEncoding(“UTF-8”))</p>
</li>
<li><p>2、如果提交方式为get，设置request对象的编码是无效的，request对象还是以默认的ISO8859-1编码接收数据，因此要想不乱码，只能在接收到数据后再手工转换，步骤如下：</p>
<ul>
<li><p>1).获取获取客户端提交上来的数据，得到的是乱码字符串,data=”???è?????”<br>String data = request.getParameter(“paramName”); </p>
</li>
<li><p>2).查找ISO8859-1码表，得到客户机提交的原始数据的字节数组</p>
</li>
</ul>
</li>
</ul>
<p>　　 byte[] source = data.getBytes(“ISO8859-1”); </p>
<ul>
<li>3).通过字节数组以指定的编码构建字符串，解决乱码<br>　　 data = new String(source, “UTF-8”);<br>　　通过字节数组以指定的编码构建字符串，这里指定的编码是根据客户端那边提交数据时使用的字符编码来定的，如果是GB2312，那么就设置成data = new String(source, “GB2312”)，如果是UTF-8，那么就设置成data = new String(source, “UTF-8”)<h3 id="四、Request对象实现请求转发"><a href="#四、Request对象实现请求转发" class="headerlink" title="四、Request对象实现请求转发"></a>四、Request对象实现请求转发</h3><h4 id="4-1、请求转发的基本概念"><a href="#4-1、请求转发的基本概念" class="headerlink" title="4.1、请求转发的基本概念"></a>4.1、请求转发的基本概念</h4>请求转发：指一个web资源收到客户端请求后，通知服务器去调用另外一个web资源进行处理。<br>请求转发的应用场景：MVC设计模式<br>在Servlet中实现请求转发的两种方式：<ul>
<li>1、通过ServletContext的getRequestDispatcher(String path)方法，该方法返回一个RequestDispatcher对象，调用这个对象的forward方法可以实现请求转发。<br>例如：将请求转发的test.jsp页面<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RequestDispatcher reqDispatcher =this.getServletContext().getRequestDispatcher(&quot;/test.jsp&quot;);</span><br><span class="line"> reqDispatcher.forward(request, response);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li>2、通过request对象提供的getRequestDispatche(String path)方法，该方法返回一个RequestDispatcher对象，调用这个对象的forward方法可以实现请求转发。<br>例如：将请求转发的test.jsp页面<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(&quot;/test.jsp&quot;).forward(request, response);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>request对象同时也是一个域对象(Map容器)，开发人员通过request对象在实现转发时，把数据通过request对象带给其它web资源处理。</p>
<p>例如：请求RequestDemo5 Servlet，RequestDemo5将请求转发到test.jsp页面<br>RequestDemo5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package qgx.request.study;</span><br><span class="line"></span><br><span class="line">import javax.servlet.RequestDispatcher;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">@WebServlet(name = &quot;RequestDemo5&quot;)</span><br><span class="line">public class RequestDemo5 extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        String data = &quot;情不知所起，一往而情深&quot;;</span><br><span class="line">        request.setAttribute(&quot;data&quot;, data);</span><br><span class="line">        RequestDispatcher requestDispatcher = this.getServletContext().getRequestDispatcher(&quot;/test.jsp&quot;);</span><br><span class="line">        requestDispatcher.forward(request, response);</span><br><span class="line">//request.setAttribute(&quot;data&quot;,data);</span><br><span class="line">//request.getRequestDispatcher(&quot;/test.jsp&quot;).forward(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>test.jsp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: qgx</span><br><span class="line">  Date: 2018/5/27</span><br><span class="line">  Time: 10:55</span><br><span class="line">  To change this template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Request对象实现请求转发&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">       使用普通方式取出存储在request对象中的数据：</span><br><span class="line">      &lt;h3 style=&quot;color:red;&quot;&gt;&lt;%=(String)request.getAttribute(&quot;data&quot;)%&gt;&lt;/h3&gt;</span><br><span class="line">      使用EL表达式取出存储在request对象中的数据：</span><br><span class="line">      &lt;h3 style=&quot;color:red;&quot;&gt;$&#123;data&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/request11.png" alt=""></p>
<h5 id="request对象作为一个域对象-Map容器-使用时，主要是通过以下的四个方法来操作"><a href="#request对象作为一个域对象-Map容器-使用时，主要是通过以下的四个方法来操作" class="headerlink" title="request对象作为一个域对象(Map容器)使用时，主要是通过以下的四个方法来操作"></a>request对象作为一个域对象(Map容器)使用时，主要是通过以下的四个方法来操作</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setAttribute(String name,Object o)方法，将数据作为request对象的一个属性存放到request对象中，例如：request.setAttribute(&quot;data&quot;, data);</span><br><span class="line">getAttribute(String name)方法，获取request对象的name属性的属性值，例如：request.getAttribute(&quot;data&quot;)</span><br><span class="line">removeAttribute(String name)方法，移除request对象的name属性，例如：request.removeAttribute(&quot;data&quot;)</span><br><span class="line">getAttributeNames方法，获取request对象的所有属性名，返回的是一个，例如：Enumeration&lt;String&gt; attrNames = request.getAttributeNames();</span><br></pre></td></tr></table></figure>
<p>####4.2、请求重定向和请求转发的区别</p>
<ul>
<li>一个web资源收到客户端请求后，通知服务器去调用另外一个web资源进行处理，称之为请求转发/307。</li>
<li>一个web资源收到客户端请求后，通知浏览器去访问另外一个web资源进行处理，称之为请求重定向/302。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/20/Spring Boot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qgx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qin12的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/Spring Boot/" itemprop="url">
                  Spring Boot(一)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-20 12:10:37" itemprop="dateCreated datePublished" datetime="2018-07-20T12:10:37+08:00">2018-07-20</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Boot致力于在蓬勃发展的快速应用开发领域（rapid application development）成为领导者。</p>
<h4 id="Spring-Boot的特点"><a href="#Spring-Boot的特点" class="headerlink" title="Spring Boot的特点"></a>Spring Boot的特点</h4><ol>
<li>创建独立的Spring应用程序</li>
<li>直接嵌入Tomcat，Jetty或Undertow，无需部署WAR文件</li>
<li>提供推荐的基础POM文件来简化Apache Maven配置</li>
<li>尽可能的根据项目依赖来自动配置Spring框架</li>
<li>提供生产就绪型功能，如指标，运行状况检查和外部配置</li>
<li>绝对没有代码生成和对XML没有要求配置</li>
</ol>
<h4 id="Spring-Boot的优点"><a href="#Spring-Boot的优点" class="headerlink" title="Spring Boot的优点"></a>Spring Boot的优点</h4><p>spring boot可以支持开发人员快速的开发出restful风格的微服务架构；<br>spring boot自动化确实方便，做微服务再合适不过了，单一jar包部署和管理都非常方便。只要系统架构设计合理，大型项目也能用，加上nginx负载均衡，轻松实现横向扩展；<br>spring boot要解决的问题, 精简配置是一方面, 另外一方面是如何方便的让spring生态圈和其他工具链整合（比如Redis，email，elasticsearch）。</p>
<h4 id="Spring-Boot运行环境"><a href="#Spring-Boot运行环境" class="headerlink" title="Spring Boot运行环境"></a>Spring Boot运行环境</h4><p>Spring Boot（2017-08-18）版本Spring Boot 1.5.6运行环境，Spring官方建议使用JDK1.8<br>        Spring Boot使开发独立的，产品级别的基于Spring的应用变得非常简单，你只需”just run”。 为Spring平台及第三方库提供开箱即用的设置，这样就可以有条不紊地开始。多数Spring Boot应用需要很少的Spring配置。</p>
<p>使用Spring Boot创建Java应用，使用Spring启动或采用传统的war部署方式。Spring Boot提供了一个运行”Spring脚本”的命令行工具。<br>Spring Boot推荐基础POM文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">spring-boot-starter	核心 POM，包含自动配置支持、日志库和对 YAML 配置文件的支持。</span><br><span class="line">spring-boot-starter-amqp	通过 spring-rabbit 支持 AMQP。</span><br><span class="line">spring-boot-starter-aop	包含 spring-aop 和 AspectJ 来支持面向切面编程（AOP）。</span><br><span class="line">spring-boot-starter-batch	支持 Spring Batch，包含 HSQLDB。</span><br><span class="line">spring-boot-starter-data-jpa	包含 spring-data-jpa、spring-orm 和 Hibernate 来支持 JPA。</span><br><span class="line">spring-boot-starter-data-mongodb	包含 spring-data-mongodb 来支持 MongoDB。</span><br><span class="line">spring-boot-starter-data-rest	通过 spring-data-rest-webmvc 支持以 REST 方式暴露 Spring Data 仓库。</span><br><span class="line">spring-boot-starter-jdbc	支持使用 JDBC 访问数据库。</span><br><span class="line">spring-boot-starter-security	包含 spring-security。</span><br><span class="line">spring-boot-starter-test	包含常用的测试所需的依赖，如 JUnit、Hamcrest、Mockito 和 spring-test 等。</span><br><span class="line">spring-boot-starter-velocity	支持使用 Velocity 作为模板引擎。</span><br><span class="line">spring-boot-starter-web	支持 Web 应用开发，包含 Tomcat 和 spring-mvc。</span><br><span class="line">spring-boot-starter-websocket	支持使用 Tomcat 开发 WebSocket 应用。</span><br><span class="line">spring-boot-starter-ws	支持 Spring Web Services。</span><br><span class="line">spring-boot-starter-actuator	添加适用于生产环境的功能，如性能指标和监测等功能。</span><br><span class="line">spring-boot-starter-remote-shell	添加远程 SSH 支持。</span><br><span class="line">spring-boot-starter-jetty	使用 Jetty 而不是默认的 Tomcat 作为应用服务器。</span><br><span class="line">spring-boot-starter-log4j	添加 Log4j 的支持。</span><br><span class="line">spring-boot-starter-logging	使用 Spring Boot 默认的日志框架 Logback。</span><br><span class="line">spring-boot-starter-tomcat	使用 Spring Boot 默认的 Tomcat 作为应用服务器。</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/20/Untitled22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qgx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qin12的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/Untitled22/" itemprop="url">
                  java 基础题(三)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-20 12:10:37" itemprop="dateCreated datePublished" datetime="2018-07-20T12:10:37+08:00">2018-07-20</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>21、ArrayList和Vector的区别</p>
<pre><code>这两个类都实现了List接口（List接口继承了Collection接口），他们都是有序集合，即存储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引号取出某个元素，并且其中的数据是允许重复的，这是与HashSet之类的集合的最大不同处，HashSet之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素。
 ArrayList与Vector的区别主要包括两个方面：.
</code></pre><p>（1）同步性：</p>
<pre><code>Vector是线程安全的，也就是说是它的方法之间是线程同步的，而ArrayList是线程序不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是使用Vector，因为不需要我们自己再去考虑和编写线程安全的代码。
</code></pre><p>（2）数据增长：</p>
<pre><code>ArrayList与Vector都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加ArrayList与Vector的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。Vector默认增长为原来两倍，而ArrayList的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的1.5倍）。ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。
</code></pre><p>  总结：即Vector增长原来的一倍，ArrayList增加原来的0.5倍。</p>
</li>
<li><p>22、HashMap和Hashtable的区别</p>
<pre><code>HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，在只有一个线程访问的情况下，效率要高于Hashtable。
HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。
</code></pre><p>HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。</p>
<pre><code>Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。
最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap就必须为之提供同步。
</code></pre><p>   就HashMap与HashTable主要从三方面来说。</p>
<pre><code>一.历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现
二.同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的
三.值：只有HashMap可以让你将空值作为一个表的条目的key或value
</code></pre></li>
<li><p>23、List和 Map区别?</p>
<pre><code>一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合，List中存储的数据是有顺序，并且允许重复；Map中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的。
</code></pre></li>
<li><p>24、List,Set, Map是否继承自Collection接口?<br> List，Set是，Map不是</p>
</li>
<li><p>25、List、Map、Set三个接口，存取元素时，各有什么特点？<br>（这样的题比较考水平，两个方面的水平：一是要真正明白这些内容，二是要有较强的总结和表述能力。）</p>
<pre><code> 首先，List与Set具有相似性，它们都是单列元素的集合，所以，它们有一个共同的父接口，叫Collection。Set里面不允许有重复的元素，即不能有两个相等（注意，不是仅仅是相同）的对象，即假设Set集合中有了一个A对象，现在我要向Set集合再存入一个B对象，但B对象与A对象equals相等，则B对象存储不进去，所以，Set集合的add方法有一个boolean的返回值，当集合中没有某个元素，此时add方法可成功加入该元素时，则返回true，当集合含有与某个元素equals相等的元素时，此时add方法无法加入该元素，返回结果为false。Set取元素时，不能细说要取第几个，只能以Iterator接口取得所有的元素，再逐一遍历各个元素。
List表示有先后顺序的集合，注意，不是那种按年龄、按大小、按价格之类的排序。当我们多次调用add(Obje)方法时，每次加入的对象就像火车站买票有排队顺序一样，按先来后到的顺序排序。有时候，也可以插队，即调用add(intindex,Obj e)方法，就可以指定当前对象在集合中的存放位置。一个对象可以被反复存储进List中，每调用一次add方法，这个对象就被插入进集合中一次，其实，并不是把这个对象本身存储进了集合中，而是在集合中用一个索引变量指向这个对象，当这个对象被add多次时，即相当于集合中有多个索引指向了这个对象，如图x所示。List除了可以用Iterator接口取得所有的元素，再逐一遍历各个元素之外，还可以调用get(index i)来明确说明取第几个。
Map与List和Set不同，它是双列的集合，其中有put方法，定义如下：put(obj key,obj value)，每次存储时，要存储一对key/value，不能存储重复的key，这个重复的规则也是按equals比较相等。取则可以根据key获得相应的value，即get(Object key)返回值为key所对应的value。另外，也可以获得所有的key的结合，还可以获得所有的value的结合，还可以获得key和value组合成的Map.Entry对象的集合。
</code></pre><p>List以特定次序来持有元素，可有重复元素。Set无法拥有重复元素,内部排序。Map保存key-value值，value可多值。</p>
</li>
<li><p>26、说出ArrayList,Vector,LinkedList的存储性能和特性</p>
<pre><code>ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差。而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，索引就变慢了，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。
LinkedList也是线程不安全的，LinkedList提供了一些方法，使得LinkedList可以被当作堆栈和队列来使用。
</code></pre></li>
<li><p>27、去掉一个Vector集合中重复的元素<br>Vector newVector = new Vector();<br>For (int i=0;i&lt;vector.size();i++)<br>{<br>Object obj = vector.get(i);</p>
<pre><code>if(!newVector.contains(obj);
      newVector.add(obj);
</code></pre><p>}<br>还有一种简单的方式，利用了Set不允许重复元素：<br>HashSetset = new HashSet(vector);</p>
</li>
<li><p>28、Collection和Collections的区别。</p>
<pre><code>Collection是集合类的上级接口，继承他的接口主要有Set和List.
Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。
</code></pre></li>
<li><p>29、Set里的元素是不能重复的，那么用什么方法来区分重复与否呢?是用==还是equals()?它们有何区别?</p>
<pre><code>Set里的元素是不能重复的，元素重复与否是使用equals()方法进行判断的。
==和equal区别也是考烂了的题，这里说一下：==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符。
equals方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较的两个对象是独立的。 
比如：两条new语句创建了两个对象，然后用a/b这两个变量分别指向了其中一个对象，这是两个不同的对象，它们的首地址是不同的，即a和b中存储的数值是不相同的，所以，表达式a==b将返回false，而这两个对象中的内容是相同的，所以，表达式a.equals(b)将返回true。
</code></pre></li>
<li><p>30、你所知道的集合类都有哪些？主要方法？</p>
<pre><code>最常用的集合类是 List 和 Map。 List的具体实现包括 ArrayList和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。 List适用于按数值索引访问元素的情形。
Map 提供了一个更通用的元素存储方法。 Map集合类用于存储元素对（称作&quot;键&quot;和&quot;值&quot;），其中每个键映射到一个值。
它们都有增删改查的方法。
对于set，大概的方法是add,remove, contains等
对于map，大概的方法就是put,remove，contains等
List类会有get(int index)这样的方法，因为它可以按顺序取元素，而set类中没有get(int index)这样的方法。List和set都可以迭代出所有元素，迭代时先要得到一个iterator对象，所以，set和list类都有一个iterator方法，用于返回那个iterator对象。map可以返回三个集合，一个是返回所有的key的集合，另外一个返回的是所有value的集合，再一个返回的key和value组合成的EntrySet对象的集合，map也有get方法，参数是key，返回值是key对应的value
</code></pre></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/20/小程序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qgx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qin12的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/小程序/" itemprop="url">
                  关于微信小程序webview的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-20 12:10:37" itemprop="dateCreated datePublished" datetime="2018-07-20T12:10:37+08:00">2018-07-20</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/杂七杂八/" itemprop="url" rel="index"><span itemprop="name">杂七杂八</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h3><p>微信小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。同时提供一系列工具帮助开发者快速接入并完成小程序开发。关于如何注册配置就不多言了，本文主要还是体验了下web-view的功能。</p>
<h4 id="web-view详解"><a href="#web-view详解" class="headerlink" title="web-view详解"></a>web-view详解</h4><p>有了这个组件之后，小程序可以很好的嵌入一些页面，可以环境小程序size告急的问题，同样也使开发更加便捷，毕竟小程序开发者基本都对前端开发较为了解。</p>
<h4 id="web-view能力"><a href="#web-view能力" class="headerlink" title="web-view能力"></a>web-view能力</h4><p>说再多还是需要去看官方文档，web-view文档,</p>
<h4 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h4><p>首先就需要注意：兼容问题，版本库和对应版本比例</p>
<p>基础库 1.6.4 开始支持，低版本需做兼容处理，<br>个人类型与海外类型的小程序暂不支持使用。</p>
<p>目前而言，基本80%的用户会升级微信，所以其实不必担心版本问题，官方截止2017-12-01提供的数据也说明88%的用户支持web-view。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>web-view 组件是一个可以用来承载网页的容器，会自动铺满整个小程序页面；</p>
<p>####属性：<br>src 是String类型，是一个网站的url，默认值是none，webview 指向网页的链接。需登录小程序管理后台配置域名白名单。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- wxml --&gt;</span><br><span class="line">&lt;!-- 指向微信公众平台首页的web-view --&gt;</span><br><span class="line">&lt;web-view src=&quot;https://mp.weixin.qq.com/&quot;&gt;&lt;/web-view&gt;</span><br><span class="line">可以配合Page实例的onLoad方法来获取url的具体值，也就是一个微信小程序页面中只有一个web-view，但是这个web-view的内容可以根据上一个页面传递的参数来获取页面URL，后面会讲如何实践，</span><br></pre></td></tr></table></figure></p>
<p>官方提供如下接口：</p>
<h4 id="web-view和小程序的通信"><a href="#web-view和小程序的通信" class="headerlink" title="web-view和小程序的通信"></a>web-view和小程序的通信</h4><p>由小程序到web-view,其实本质上WEB-VIEW也是小程序的一个页面，所以小程序到web-view是正常的小程序间的通信，通过wx.navigateTo、wx.redirectTo，带上url参数,query参数就像正常url的参数一样跟着后面，然后在web-view的页面的Page实例里面通过onLoad的方法的参数来获取url的值，设置给web-view的src属性为改值即可。<br>由web-view到小程序，由于在web-view的跳转通常是在src对应的网页中的操作来处理的，所以需要结合jssdk来处理，不需要wx.config配置，直接通过script标签来引入<a href="https://res.wx.qq.com/open/js/jweixin-1.3.0.js，就可以使用wx.miniProgram.navigateTo、wx.miniProgram.navigateBack、wx.miniProgram.switchTab、wx.miniProgram.reLaunch、wx.miniProgram.redirectTo接口，就像小程序之间的跳转一样，单是只能在当前小程序页面内跳转。" target="_blank" rel="noopener">https://res.wx.qq.com/open/js/jweixin-1.3.0.js，就可以使用wx.miniProgram.navigateTo、wx.miniProgram.navigateBack、wx.miniProgram.switchTab、wx.miniProgram.reLaunch、wx.miniProgram.redirectTo接口，就像小程序之间的跳转一样，单是只能在当前小程序页面内跳转。</a><br>支持以下部分JSSDK接口图像、音频、摇一摇、地理位置等信息，具体可以查看web-view文档,不过这些需要通过wx.config来授权，就和服务号开发类似。<br>用户分享时可获取当前<web-view>的URL，即在onShareAppMessage回调中返回webViewUrl参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  onShareAppMessage(options) &#123;</span><br><span class="line">    console.log(options.webViewUrl)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">在网页内可通过window.__wxjs_environment变量判断是否在小程序环境。</span><br><span class="line"></span><br><span class="line">// web-view下的页面内</span><br><span class="line">console.log(window.__wxjs_environment === &apos;miniprogram&apos;) // true</span><br><span class="line">web-view实践</span><br><span class="line">在目前实践了部分web-view的功能，</span><br><span class="line"></span><br><span class="line">//index.js</span><br><span class="line">Page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">       url: &apos;https://test.com&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    onLoad: function(options)&#123;</span><br><span class="line">        options.url ? this.setData(&#123;url: options.url&#125;) : wx.navigateBack(&#123;delta: 2&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//index.wxml</span><br><span class="line">&lt;web-view src=&quot;&#123;&#123;url&#125;&#125;&quot;&gt;&lt;/web-view&gt;</span><br><span class="line">在这个web-view中，指向的就是https://test.com的内容，所以在在https://test.com中跳转出回到小程序，需要修改https://test.com中的JavaScript,</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;test&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://test.com/index.css&quot; /&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">        &lt;h1&gt;webview-wechat-detail&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            detail</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;button type=&quot;button&quot; id=&quot;btn&quot;&gt;返回小程序&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;https://test.com/jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;https://res.wx.qq.com/open/js/jweixin-1.3.0.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        /* eslint-disable */</span><br><span class="line">$(function()&#123;</span><br><span class="line">    doucument.cookie = &apos;bb=bbbbbb&apos;;</span><br><span class="line">    $(&apos;#btn&apos;).on(&apos;click&apos;,function(s) &#123;</span><br><span class="line">        document.cookie = &apos;aa=ssssss&apos;;</span><br><span class="line">        wx.miniProgram.navigateTo(&#123;</span><br><span class="line">            url:&apos;/pages/index?test=testtest&apos;,</span><br><span class="line">            success: function()&#123;</span><br><span class="line">                console.log(&apos;success&apos;)</span><br><span class="line">            &#125;,</span><br><span class="line">            fail: function()&#123;</span><br><span class="line">                console.log(&apos;fail&apos;);</span><br><span class="line">            &#125;,</span><br><span class="line">            complete:function()&#123;</span><br><span class="line">                console.log(&apos;complete&apos;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">如果需要使用一些其他的的jssdk的方法，那就需要参照公众号的开发配置了。</span><br></pre></td></tr></table></figure></web-view></p>
<h4 id="web-view采坑"><a href="#web-view采坑" class="headerlink" title="web-view采坑"></a>web-view采坑</h4><p>由于很多使用中的一些问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.打开的域名没有在小程序管理后台设置业务域名（注意是业务域名，不是服务器域名）</span><br><span class="line">2.打开的页面必须为https服务</span><br><span class="line">3.打开的页面302过去的地址也必须设置过业务域名</span><br><span class="line">4.web-view空白问题，请升级微信客户端到 6.5.16</span><br><span class="line">5.页面可以包含iframe，但是iframe的地址必须为业务域名</span><br><span class="line">6.web-view不支持支付能力，web-view的API能力见web-view的文档说明</span><br><span class="line">7.开发者自己检查自己的https服务是否正常，测试方法：普通浏览器打开对应的地址</span><br><span class="line">8.如果web-view使用了公众号授权的服务，开发者工具提示网页开发者的问题，请见：公众号开发</span><br></pre></td></tr></table></figure></p>
<p>其他的问题注意：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">每个页面只能有一个&lt;web-view/&gt;，&lt;web-view/&gt;会自动铺满整个页面，并覆盖其他组件，小程序对webview的监控状态基本没有，只能设置src设置url。</span><br><span class="line">关于小程序和web-view的通信，&lt;web-view/&gt; → 小程序只能通过JSSDK 1.3.0提供的接口返回小程序页面，设置参数来传值，反之，小程序到webview也是一样的，只能是src的路径带上参数；</span><br><span class="line">web-view不支持支付能力,是指无法唤起小程序的直接支付窗口，对于h5的那套支付应该是支持的，但是web-view 里边没法使用 微信支付的 JSAPI，也就是可能可以h5的相关的的支付中心来支付；</span><br><span class="line">关于层级，在webview中可以无限跳转，对于导航条返回和物理键返回都会回到上一个页面直到退出webview，就像history.back。</span><br><span class="line">webview中的html的title会自动放到小程序的头部作为标题；</span><br><span class="line">webview中可以正常使用ajax之类的操作。</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/20/1、IO流概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qgx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qin12的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/1、IO流概述/" itemprop="url">
                  java 基础知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-20 12:10:37" itemprop="dateCreated datePublished" datetime="2018-07-20T12:10:37+08:00">2018-07-20</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1、IO流概述"><a href="#1、IO流概述" class="headerlink" title="1、IO流概述"></a>1、IO流概述</h3><ul>
<li><p>(1)用来处理设备(硬盘，控制台，内存)间的数据。</p>
</li>
<li><p>(2)java中对数据的操作都是通过流的方式。</p>
</li>
<li><p>(3)java用于操作流的类都在io包中。</p>
</li>
<li><p>(4)按照流操作的数据的类型不同：分为字节流和字符流。字符流是为了方便中文的操作而来的。</p>
</li>
<li><p>(5)按照流的流向不同分为：输入流，输出流</p>
</li>
</ul>
<h3 id="2、IO流常用基类："><a href="#2、IO流常用基类：" class="headerlink" title="2、IO流常用基类："></a>2、IO流常用基类：</h3><h4 id="1-字节流"><a href="#1-字节流" class="headerlink" title="(1)字节流"></a>(1)字节流</h4><p>输出字节流：OutputStream：字节写入流抽象类</p>
<p>|—&gt;FileOutputStream：<br>字节写入流<br>|—&gt;BufferedOutputStream：</p>
<p>字节写入流缓冲区<br>|—&gt;PrintStream：</p>
<p>打印流<br>输入字节流：InputStream：字节读取流抽象类</p>
<p>|—&gt;FileInputStream：<br>字节读取流</p>
<p>|—&gt;BufferedInputStream：<br>字节读取流缓冲区</p>
<h4 id="2-字符流"><a href="#2-字符流" class="headerlink" title="(2)字符流"></a>(2)字符流</h4><p>输出字符流：Writer：字符写入流的抽象<br>|—&gt;FileWriter：<br>字符写入流</p>
<p>|—&gt;BufferedWriter：<br>字符写入流缓冲区</p>
<p>|—&gt;OutputStreamWriter：<br>字符通向字节的转换流(涉及键盘录入时用)</p>
<p>|—&gt;OutputStreamWriter：<br>打印流，可处理各种类型的数据</p>
<p>输入字符流：Reader: 字符读取流的抽象类</p>
<p>|—&gt;FileReader：<br>字符读取流<br>|—&gt;LineNumberReader：</p>
<p>跟踪行号的缓冲字符读取流<br>|—&gt;BufferedReader：<br>字符读取流缓冲区</p>
<p>|—&gt;InputStreamReader：<br>字节通向字符的转换流(涉及键盘录入时用)</p>
<h4 id="3-IO流常用基类方法摘要："><a href="#3-IO流常用基类方法摘要：" class="headerlink" title="(3)IO流常用基类方法摘要："></a>(3)IO流常用基类方法摘要：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">字节写入流：OutputStream：</span><br><span class="line">void close() 关闭此输出流并释放与此流有关的所有系统资源。</span><br><span class="line"></span><br><span class="line">void flush()刷新此输出流并强制写出所有缓冲的输出字节。</span><br><span class="line"></span><br><span class="line">abstract  void write(int b)  将指定的字节写入此输出流。</span><br><span class="line"></span><br><span class="line">void write(byte[] b) 将 b.length 个字节从指定的 byte 数组写入此输出流。    </span><br><span class="line"></span><br><span class="line">void write(byte[] b, int off, int len) </span><br><span class="line"></span><br><span class="line">将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。 </span><br><span class="line"></span><br><span class="line">字节读取流：InputStream：</span><br><span class="line"></span><br><span class="line">void close() 关闭此输入流并释放与该流关联的所有系统资源。</span><br><span class="line"></span><br><span class="line">int available() (特有方法！！)</span><br><span class="line"></span><br><span class="line">返回此输入流下一个方法调用可以不受阻塞地从此输入流读取（或跳过）的估计字节数。 </span><br><span class="line"></span><br><span class="line">abstract  int read() 从输入流中读取数据的下一个字节。 </span><br><span class="line"></span><br><span class="line">int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。</span><br><span class="line"></span><br><span class="line">int read(byte[] b, int off, int len)  将输入流中最多 len 个数据字节读入 byte 数组。</span><br><span class="line"></span><br><span class="line">long skip(long n) 跳过和丢弃此输入流中数据的 n 个字节。</span><br><span class="line">  </span><br><span class="line">字符写入流：Writer：</span><br><span class="line">abstract  void close() 关闭此流，但要先刷新它。</span><br><span class="line"></span><br><span class="line">abstract  void flush() 刷新该流的缓冲。</span><br><span class="line"></span><br><span class="line">void write(int c) 写入单个字符。</span><br><span class="line"></span><br><span class="line">void write(char[] cbuf) 写入字符数组。          </span><br><span class="line"></span><br><span class="line">abstract  void write(char[] cbuf, int off, int len) 写入字符数组的某一部分。 </span><br><span class="line"></span><br><span class="line">void write(String str) 写入字符串。 </span><br><span class="line"></span><br><span class="line">void write(String str, int off, int len) 写入字符串的某一部分。 </span><br><span class="line"></span><br><span class="line">字符读取流：Reader：</span><br><span class="line">abstract  void close() 关闭该流并释放与之关联的所有资源。</span><br><span class="line"></span><br><span class="line">int read() 读取单个字符。</span><br><span class="line"></span><br><span class="line">int read(char[] cbuf)  将字符读入数组</span><br><span class="line"></span><br><span class="line">abstract  int read(char[] cbuf, int off, int len) 将字符读入数组的某一部分。</span><br><span class="line"></span><br><span class="line">long skip(long n)  跳过字符。</span><br></pre></td></tr></table></figure>
<h3 id="3、IO流常用字节流基类的子类："><a href="#3、IO流常用字节流基类的子类：" class="headerlink" title="3、IO流常用字节流基类的子类："></a>3、IO流常用字节流基类的子类：</h3><p>写入流：</p>
<h4 id="1-FileOutputStream："><a href="#1-FileOutputStream：" class="headerlink" title="(1)FileOutputStream："></a>(1)FileOutputStream：</h4><p>构造方法：</p>
<p>FileOutputStream(String name) </p>
<p>创建一个向具有指定名称的文件中写入数据的输出文件流。</p>
<p>FileOutputStream(String name, boolean append) </p>
<p>创建一个向具有指定 name 的文件中写入数据的输出文件流。</p>
<p>FileOutputStream(File file) </p>
<p>创建一个向指定 File 对象表示的文件中写入数据的文件输出流。 </p>
<p>FileOutputStream(File file, boolean append) </p>
<p>创建一个向指定 File 对象表示的文件中写入数据的文件输出流。</p>
<p>方法摘要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void flush()</span><br><span class="line"></span><br><span class="line">void close() 关闭此文件输出流并释放与此流有关的所有系统资源。</span><br><span class="line"></span><br><span class="line">void write(int b) 将指定字节写入此文件输出流。</span><br><span class="line"></span><br><span class="line">void write(byte[] b, int off, int len) </span><br><span class="line"></span><br><span class="line">将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此文件输出流。 </span><br><span class="line"></span><br><span class="line">void write(int b) 将指定字节写入此文件输出流。</span><br></pre></td></tr></table></figure></p>
<h4 id="2-BufferedOutputStream："><a href="#2-BufferedOutputStream：" class="headerlink" title="(2)BufferedOutputStream："></a>(2)BufferedOutputStream：</h4><p>构造方法：<br>BufferedOutputStream(OutputStream out) </p>
<p>创建一个新的缓冲输出流，以将数据写入指定的底层输出流。 </p>
<p>BufferedOutputStream(OutputStream out, int size) </p>
<p>创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。 </p>
<p>方法摘要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void flush() 刷新此缓冲的输出流。          </span><br><span class="line"></span><br><span class="line">void write(byte[] b, int off, int len) </span><br><span class="line"></span><br><span class="line">将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此缓冲的输出流。 void write(int b) 将指定的字节写入此缓冲的输出流。</span><br></pre></td></tr></table></figure></p>
<h4 id="3-PrintStream：打印流，可将各种类型的数据原样打印，有自动刷新功能"><a href="#3-PrintStream：打印流，可将各种类型的数据原样打印，有自动刷新功能" class="headerlink" title="(3)PrintStream：打印流，可将各种类型的数据原样打印，有自动刷新功能"></a>(3)PrintStream：打印流，可将各种类型的数据原样打印，有自动刷新功能</h4><p>构造方法：</p>
<p>PrintStream(String fileName)<br>创建具有指定文件名称且不带自动行刷新的新打印流。</p>
<p>PrintStream(File file) 创建具有指定文件且不带自动行刷新的新打印流。<br>PrintStream(OutputStream out) </p>
<p>创建新的打印流。</p>
<p>PrintStream(OutputStream out, boolean autoFlush) (当autoFlush为true时具有自动刷新功能)<br>创建新的打印流。</p>
<p>方法摘要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PrintStream append(char c) 将指定字符添加到此输出流。</span><br><span class="line">void close() </span><br><span class="line"></span><br><span class="line">关闭流。 void flush() 刷新该流的缓冲。void print(各种类型的数据：) 打印各种类型的数据 void println(各种类型的数据：)：自动换行打印各种类型的数据 void write(byte[] buf, int off, int len) 将 len 字节从指定的初始偏移量为 off 的 byte 数组写入此流。 void write(int b) 将指定的字节写入此流。</span><br></pre></td></tr></table></figure></p>
<h3 id="读取流："><a href="#读取流：" class="headerlink" title="读取流："></a>读取流：</h3><h4 id="1-FileInputStream："><a href="#1-FileInputStream：" class="headerlink" title="(1)FileInputStream："></a>(1)FileInputStream：</h4><p>构造方法：FileInputStream(String name) 通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的路径名 name 指定。FileInputStream(File file) 通过打开一个到实际文件的连接来创建一个 FileInputStream，<br>该文件通过文件系统中的 File 对象 file 指定。</p>
<p>方法摘要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int available() (字节读取流特有方法！！！)返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取（或跳过）的估计剩余字节数。int read() 从此输入流中读取一个数据字节。 int read(byte[] b) 从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。 int read(byte[] b, int off, int len) 从此输入流中将最多 len 个字节的数据读入一个 byte 数组中。 long skip(long n) </span><br><span class="line">从输入流中跳过并丢弃 n 个字节的数据。</span><br></pre></td></tr></table></figure></p>
<h4 id="2-BufferedInputStream"><a href="#2-BufferedInputStream" class="headerlink" title="(2)BufferedInputStream:"></a>(2)BufferedInputStream:</h4><p>构造方法：BufferedInputStream(InputStream in) 创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。 BufferedInputStream(InputStream in, int size)<br>创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。</p>
<p>方法摘要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int available() (字节读取流特有方法！！！)返回可以从此输入流读取（或跳过）、且不受此输入流接下来的方法调用阻塞的估计字节数。 int read() 参见 InputStream 的 read 方法的常规协定。 int read(byte[] b, int off, int len) 从此字节输入流中给定偏移量处开始将各字节读取到指定的 byte 数组中。 long skip(long n) </span><br><span class="line">参见 InputStream 的 skip 方法的常规协定。</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/20/Servlet 的线程安全问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qgx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qin12的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/Servlet 的线程安全问题/" itemprop="url">
                  javaweb (二)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-20 12:10:37" itemprop="dateCreated datePublished" datetime="2018-07-20T12:10:37+08:00">2018-07-20</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/javaEE/" itemprop="url" rel="index"><span itemprop="name">javaEE</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Servlet-的线程安全问题"><a href="#Servlet-的线程安全问题" class="headerlink" title="Servlet 的线程安全问题"></a>Servlet 的线程安全问题</h3><ul>
<li>当多个客户端并发访问同一个Servlet时，web服务器会为每一个客户端的访问请求创建一个线程，并在这个线程上调用Servlet的service方法，因此service方法内如果访问了同一个资源的话，就有可能引发线程安全问题。例如下面的代码：</li>
<li>不存在线程安全问题的代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">@WebServlet(name = &quot;Servlet&quot;)</span><br><span class="line">public class ServletDemo3 extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">doGet(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">/** * 当多线程并发访问这个方法里面的代码时，会存在线程安全问题吗</span><br><span class="line">  * i变量被多个线程并发访问，但是没有线程安全问题，因为i是doGet方法里面的局部变量，</span><br><span class="line">  * 当有多个线程并发访问doGet方法时，每一个线程里面都有自己的i变量，</span><br><span class="line">  * 各个线程操作的都是自己的i变量，所以不存在线程安全问题</span><br><span class="line">  * 多线程并发访问某一个方法的时候，如果在方法内部定义了一些资源(变量，集合等)</span><br><span class="line">  * 那么每一个线程都有这些东西，所以就不存在线程安全问题了</span><br><span class="line">  */</span><br><span class="line">        int i=1;</span><br><span class="line">        i++;        response.getWriter().write(i+&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>存在线程安全问题的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">@WebServlet(name = &quot;ServletDemo4&quot;)</span><br><span class="line">public class ServletDemo4 extends HttpServlet &#123;</span><br><span class="line">    int i=1;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">doGet(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        i++;</span><br><span class="line">        try &#123;</span><br><span class="line">             Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">            &#125;    response.getWriter().write(i+&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　把i定义成全局变量，当多个线程并发访问变量i时，就会存在线程安全问题了，如下图所示：同时开启两个浏览器模拟并发访问同一个Servlet，本来正常来说，第一个浏览器应该看到2，而第二个浏览器应该看到3的，结果两个浏览器都看到了3，这就不正常。<br>　线程安全问题只存在多个线程并发操作同一个资源的情况下，所以在编写Servlet的时候，如果并发访问某一个资源(变量，集合等)，就会存在线程安全问题，那么该如何解决这个问题呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">             throws ServletException, IOException &#123;</span><br><span class="line">         /**</span><br><span class="line">          * 加了synchronized后，并发访问i时就不存在线程安全问题了，</span><br><span class="line">          * 为什么加了synchronized后就没有线程安全问题了呢？</span><br><span class="line">          * 假如现在有一个线程访问Servlet对象，那么它就先拿到了Servlet对象的那把锁</span><br><span class="line">          * 等到它执行完之后才会把锁还给Servlet对象，由于是它先拿到了Servlet对象的那把锁，</span><br><span class="line">          * 所以当有别的线程来访问这个Servlet对象时，由于锁已经被之前的线程拿走了，后面的线程只能排队等候了</span><br><span class="line">          * </span><br><span class="line">          */</span><br><span class="line">         synchronized (this) &#123;//在java中，每一个对象都有一把锁，这里的this指的就是Servlet对象</span><br><span class="line">             i++;</span><br><span class="line">             try &#123;</span><br><span class="line">                 Thread.sleep(1000*4);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">             response.getWriter().write(i+&quot;&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>现在这种做法是给Servlet对象加了一把锁，保证任何时候都只有一个线程在访问该Servlet对象里面的资源，这样就不存在线程安全问题了，如下图所示：<br><img src="/img/线程结果.png" alt=""><br>这种做法虽然解决了线程安全问题，但是编写Servlet却万万不能用这种方式处理线程安全问题，假如有9999个人同时访问这个Servlet，那么这9999个人必须按先后顺序排队轮流访问。<br>针对Servlet的线程安全问题，Sun公司是提供有解决方案的：让Servlet去实现一个SingleThreadModel接口，如果某个Servlet实现了SingleThreadModel接口，那么Servlet引擎将以单线程模式来调用其service方法。<br>查看Sevlet的API可以看到，SingleThreadModel接口中没有定义任何方法和常量，在Java中，把没有定义任何方法和常量的接口称之为标记接口，经常看到的一个最典型的标记接口就是”Serializable”，这个接口也是没有定义任何方法和常量的，标记接口在Java中有什么用呢？主要作用就是给某个对象打上一个标志，告诉JVM，这个对象可以做什么，比如实现了”Serializable”接口的类的对象就可以被序列化，还有一个”Cloneable”接口，这个也是一个标记接口，在默认情况下，Java中的对象是不允许被克隆的，就像现实生活中的人一样，不允许克隆，但是只要实现了”Cloneable”接口，那么对象就可以被克隆了。</p>
<p>　　让Servlet实现了SingleThreadModel接口，只要在Servlet类的定义中增加实现SingleThreadModel接口的声明即可。<br>　　对于实现了SingleThreadModel接口的Servlet，Servlet引擎仍然支持对该Servlet的多线程并发访问，其采用的方式是产生多个Servlet实例对象，并发的每个线程分别调用一个独立的Servlet实例对象。<br>　　实现SingleThreadModel接口并不能真正解决Servlet的线程安全问题，因为Servlet引擎会创建多个Servlet实例对象，而真正意义上解决多线程安全问题是指一个Servlet实例对象被多个线程同时调用的问题。事实上，在Servlet API 2.4中，已经将SingleThreadModel标记为Deprecated（过时的）。  </p>
<ul>
<li>实现 SingleThreadModel 接口（已过时）</li>
<li>同步对共享数据的操作<br>　　使用synchronized 关键字能保证一次只有一个线程可以访问被保护的区段，在本论文中的Servlet可以通过同步块操作来保证线程的安全。</li>
<li>避免使用实例变量—-最佳选择。<br>　　本实例中的线程安全问题是由实例变量造成的，只要在Servlet里面的任何方法里面都不使用实例变量，那么该Servlet就是线程安全的。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/20/深入理解Tomcat系列之一：系统架构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qgx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qin12的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/深入理解Tomcat系列之一：系统架构/" itemprop="url">
                  深入理解Tomcat系列之一
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-20 12:10:37" itemprop="dateCreated datePublished" datetime="2018-07-20T12:10:37+08:00">2018-07-20</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/javaEE/" itemprop="url" rel="index"><span itemprop="name">javaEE</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="深入理解Tomcat系列之一：系统架构"><a href="#深入理解Tomcat系列之一：系统架构" class="headerlink" title="深入理解Tomcat系列之一：系统架构"></a>深入理解Tomcat系列之一：系统架构</h2><h3 id="Tomcat的系统架构"><a href="#Tomcat的系统架构" class="headerlink" title="Tomcat的系统架构"></a>Tomcat的系统架构</h3><p><img src="/img/tomcat_architect.jpg" alt=""><br>首先我们从一个宏观的角度来看一下Tomcat的系统的架构：从这张图中可以看到，Tomcat的核心组件就两个Connector和Container（后面还有详细说明），一个Connector+一个Container构成一个Service，Service就是对外提供服务的组件，有了Service组件Tomcat就可以对外提供服务了，但是光有服务还不行，还得有环境让你提供服务才行，所以最外层的Server就为Service提供了生存的土壤。那么这些个组件到底是干嘛用的呢？Connector是一个连接器，主要负责接收请求并把请求交给Container，Container就是一个容器，主要装的是具体处理请求的组件。Service主要是为了关联Container与Connector，一个单独的Container或者一个单独的Connector都不能完整处理一个请求，只有两个结合在一起才能完成一个请求的处理。Server这是负责管理Service集合，从图中我们看到一个Tomcat可以提供多种服务，那么这些Serice就是由Server来管理的，具体的工作包括：对外提供一个接口访问Service，对内维护Service集合，维护Service集合又包括管理Service的生命周期、寻找一个请求的Service、结束一个Service等。以上就是对Tomcat的核心组件的简要说明，下面我们详细看看每一个组件的执行流程：</p>
<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>上面说Server是管理Service接口的，Server是Tomcat的顶级容器，是一个接口，Server接口的标准实现类是StandardServer类，在Server接口中有许多方法，我们重点关注两个方法：addService()和findService(String)。我们先来看看Server接口的全貌：<br><img src="/img/Server2.jpg" alt=""><br>接着看看addService()和findService(String)的实现代码：<br>代码清单1-1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Add a new Service to the set of defined Services.</span><br><span class="line"> *</span><br><span class="line"> * @param service The Service to be added</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void addService(Service service) &#123;</span><br><span class="line"></span><br><span class="line">    service.setServer(this);</span><br><span class="line"></span><br><span class="line">    synchronized (services) &#123;</span><br><span class="line">        Service results[] = new Service[services.length + 1];</span><br><span class="line">        System.arraycopy(services, 0, results, 0, services.length);</span><br><span class="line">        results[services.length] = service;</span><br><span class="line">        services = results;</span><br><span class="line"></span><br><span class="line">        if (getState().isAvailable()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                service.start();</span><br><span class="line">            &#125; catch (LifecycleException e) &#123;</span><br><span class="line">                // Ignore</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Report this property change to interested listeners</span><br><span class="line">        support.firePropertyChange(&quot;service&quot;, null, service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，Server使用一个数组来管理Service的，每添加一个Service就把原来的Service拷贝到一个新的数组中，再把新的Service放入Service数组中。所以Server与Service是关联在一起的，那么后面的getState().isAvailable()是干嘛的呢？判断状态是否无效，从而决定是否执行service方法。这里说到了状态，就不得不说Tomcat管理各组件生命周期的Lifecycle接口了：</p>
<h4 id="Lifecycle接口"><a href="#Lifecycle接口" class="headerlink" title="Lifecycle接口"></a>Lifecycle接口</h4><p>Tomcat中的组件都交给这个接口管理，但是具体组件的生命周期是由包含组件的父容器来管理的，Tomcat中顶级容器管理着Service的生命周期，Service容器又是Connector和Container的父容器，所以这两个组件的生命周期是由Service管理的，Container也有子容器，所以管理着这些子容器的生命周期。这样，只要所有组件都实现了Lifecycle接口，从顶层容器Server开始，就可以控制所有容器的生命周期了。Lifecycle接口中定义了很多状态，在api中详细说明了调用不同方法后的状态转变，同时定义了不同的方法，这些方法在执行后状态会发生相应的改变，在Lifecycle接口中定义了如下方法：<br><img src="/img/Lifecycle.jpg" alt=""><br>在StandServer中实现了startInernal()方法，就是循环启动StandServer管理的Service的过程，Tomcat的Service都实现了Lifecycle接口，所以被管理的Service都将被通知到，从而执行start()方法，startIntenal()方法是这样的：<br>代码清单1-2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Start nested components (&#123;@link Service&#125;s) and implement the requirements</span><br><span class="line"> * of &#123;@link org.apache.catalina.util.LifecycleBase#startInternal()&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @exception LifecycleException if this component detects a fatal error</span><br><span class="line"> *  that prevents this component from being used</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">protected void startInternal() throws LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">    fireLifecycleEvent(CONFIGURE_START_EVENT, null);</span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">    globalNamingResources.start();</span><br><span class="line"></span><br><span class="line">    // Start our defined Services</span><br><span class="line">    synchronized (services) &#123;</span><br><span class="line">        for (int i = 0; i &lt; services.length; i++) &#123;</span><br><span class="line">            services[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在所有的Service就会收到通知继而执行start方法。如果一个Service不允许被使用将会抛出一个LifecycleException异常。</p>
<p>stopIntenal()会通知所有Service执行stop方法，具体处理流程与startIntenal()方法类似。这个执行过程涉及一个非常重要的设计模式，就是观察者模式。</p>
<p>现在我们已经能够知道了容器通过Lifecycle接口管理容器的生命周期，那么在父容器的状态改变具体是怎么样通知给子容器的呢？回到代码清单1-2，我们注意到有一个fireLifecycleEvent()方法，fireLifecycleEvent()的执行流程如下：</p>
<ul>
<li>调用LifecycleBase的fireLifecycleEvent(LifecycleListener listener)方法，LifecycleBase是一个抽象类，实现了Lifecycle接口</li>
<li>继续调用LifecycleSupport（是一个辅助完成对已经注册监听器的事件通知类，不可被继承，使用final)的fireLifecycleEvent(String type, Object data)方法</li>
<li>完成事件通知</li>
</ul>
<p>fireLifecycleEvent(String type, Object data)的方法如下：</p>
<p>代码清单1-3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Notify all lifecycle event listeners that a particular event has</span><br><span class="line"> * occurred for this Container.  The default implementation performs</span><br><span class="line"> * this notification synchronously using the calling thread.</span><br><span class="line"> *</span><br><span class="line"> * @param type Event type</span><br><span class="line"> * @param data Event data</span><br><span class="line"> */</span><br><span class="line">public void fireLifecycleEvent(String type, Object data) &#123;</span><br><span class="line"></span><br><span class="line">    LifecycleEvent event = new LifecycleEvent(lifecycle, type, data);</span><br><span class="line">    LifecycleListener interested[] = listeners;</span><br><span class="line">    for (int i = 0; i &lt; interested.length; i++)</span><br><span class="line">        interested[i].lifecycleEvent(event);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，具体事件的通知是由LifecycleListener接口的lifecycleEvent方法完成的，各实现类可以根据不同的情况实现不同的事件监听逻辑</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Service是具体提供服务的接口，一个Service包装了Connector和一个Container，在Tomcat中这点是如何实现的呢？Service是一个接口，其标准实现类是StandardService，下面是这两个类的鸟瞰图：<br><img src="/img/Service.jpg" alt=""><br><img src="/img/StandardService.jpg" alt=""><br>这里，我们只关心与Connector和Container最紧密的方法：setContainer()和addConnector()方法，先看一下setContainer()方法的源码：<br>代码清单2-1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Set the &lt;code&gt;Container&lt;/code&gt; that handles requests for all</span><br><span class="line"> * &lt;code&gt;Connectors&lt;/code&gt; associated with this Service.</span><br><span class="line"> *</span><br><span class="line"> * @param container The new Container</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void setContainer(Container container) &#123;</span><br><span class="line"></span><br><span class="line">    Container oldContainer = this.container;</span><br><span class="line">    if ((oldContainer != null) &amp;&amp; (oldContainer instanceof Engine))</span><br><span class="line">        ((Engine) oldContainer).setService(null);</span><br><span class="line">    this.container = container;</span><br><span class="line">    if ((this.container != null) &amp;&amp; (this.container instanceof Engine))</span><br><span class="line">        ((Engine) this.container).setService(this);</span><br><span class="line">    if (getState().isAvailable() &amp;&amp; (this.container != null)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.container.start();</span><br><span class="line">        &#125; catch (LifecycleException e) &#123;</span><br><span class="line">            // Ignore</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (getState().isAvailable() &amp;&amp; (oldContainer != null)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            oldContainer.stop();</span><br><span class="line">        &#125; catch (LifecycleException e) &#123;</span><br><span class="line">            // Ignore</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Report this property change to interested listeners</span><br><span class="line">    support.firePropertyChange(&quot;container&quot;, oldContainer, this.container);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码中可以看到这个方法主要的任务是设置一个Container容器来处理一个或者多个Connector传送过来的请求。首先判断当前的Service是否已经关联了Container容器，如果已经关联了就去除这个关联关系。如果原来的Container容器已经启动了就终止其生命周期，结束运行并设置新的关联关系，这个新的Container容器开始新的生命周期。最后把这个过程通知给感兴趣的事件监听程序。</p>
<p>下面看看addConnector的方法：</p>
<p>代码清单2-2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Add a new Connector to the set of defined Connectors, and associate it</span><br><span class="line"> * with this Service&apos;s Container.</span><br><span class="line"> *</span><br><span class="line"> * @param connector The Connector to be added</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void addConnector(Connector connector) &#123;</span><br><span class="line"></span><br><span class="line">    synchronized (connectors) &#123;</span><br><span class="line">        connector.setService(this);</span><br><span class="line">        Connector results[] = new Connector[connectors.length + 1];</span><br><span class="line">        System.arraycopy(connectors, 0, results, 0, connectors.length);</span><br><span class="line">        results[connectors.length] = connector;</span><br><span class="line">        connectors = results;</span><br><span class="line"></span><br><span class="line">        if (getState().isAvailable()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                connector.start();</span><br><span class="line">            &#125; catch (LifecycleException e) &#123;</span><br><span class="line">                log.error(sm.getString(</span><br><span class="line">                        &quot;standardService.connector.startFailed&quot;,</span><br><span class="line">                        connector), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Report this property change to interested listeners</span><br><span class="line">        support.firePropertyChange(&quot;connector&quot;, null, connector);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行过程也比较清楚：用一个同步代码块包住connectors数组，首先设置connector与container和service的关联关系，然后让connector开始新的生命周期，最后通知感兴趣的事件监听程序。注意到Connector的管理和Server管理Service一样都使用了数组拷贝并把新的数组赋给当前的数组，从而间接实现了动态数组。之所以使用数组我想可能是出于性能的考虑吧。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/20/装饰者模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qgx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qin12的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/装饰者模式/" itemprop="url">
                  装饰者模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-20 12:10:37" itemprop="dateCreated datePublished" datetime="2018-07-20T12:10:37+08:00">2018-07-20</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/设计模式/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><pre><code>在不必改变原类文件和原类使用的继承的情况下，动态地扩展一个对象的功能。
它是通过创建一个包装对象，也就是用装饰来包裹真实的对象来实现。
</code></pre><h4 id="角色："><a href="#角色：" class="headerlink" title="角色："></a>角色：</h4><p>######抽象构件角色（Project）：<br>给出一个接口，以规范准备接收附加责任的对象。</p>
<h5 id="具体构件角色（Employe）："><a href="#具体构件角色（Employe）：" class="headerlink" title="具体构件角色（Employe）："></a>具体构件角色（Employe）：</h5><p>定义一个将要接收附加责任的类。</p>
<h5 id="装饰角色（Manager）："><a href="#装饰角色（Manager）：" class="headerlink" title="装饰角色（Manager）："></a>装饰角色（Manager）：</h5><p>持有一个构件对象的实例，并定义一个与抽象构件接口一致的接口。</p>
<h5 id="具体装饰角色（ManagerA、ManagerB）："><a href="#具体装饰角色（ManagerA、ManagerB）：" class="headerlink" title="具体装饰角色（ManagerA、ManagerB）："></a>具体装饰角色（ManagerA、ManagerB）：</h5><p>负责给构件对象“贴上”附加的责任。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><h4 id="公共接口："><a href="#公共接口：" class="headerlink" title="公共接口："></a>公共接口：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public interface Person &#123;  </span><br><span class="line">    void eat();  </span><br><span class="line">&#125;</span><br><span class="line">被装饰对象：</span><br><span class="line">public class OldPerson implements Person &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void eat() &#123;  </span><br><span class="line">        System.out.println(&quot;吃饭&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line">装饰对象：</span><br><span class="line">public class NewPerson implements Person &#123;  </span><br><span class="line">    private OldPerson p;  </span><br><span class="line"></span><br><span class="line">    NewPerson(OldPerson p) &#123;  </span><br><span class="line">        this.p = p;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    @Override  </span><br><span class="line">    public void eat() &#123;  </span><br><span class="line">        System.out.println(&quot;生火&quot;);  </span><br><span class="line">        System.out.println(&quot;做饭&quot;);  </span><br><span class="line">        p.eat();  </span><br><span class="line">        System.out.println(&quot;刷碗&quot;);   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class PersonDemo &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        OldPerson old = new OldPerson();  </span><br><span class="line">        //old.eat(); </span><br><span class="line">        NewPerson np = new NewPerson(old);  </span><br><span class="line">        np.eat();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>通过例子可以看到，没有改变原来的OldPerson类，同时也没有定义他的子类而实现了Person的扩展，这就是装饰者模式的作用。
</code></pre><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><pre><code>1，使用装饰者模式比使用继承更加灵活，因为它选择通过一种动态的方式来扩展一个对象的功能，在运行时可以选择不同的装饰器，从而实现不同的行为。
2，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。
3，具体构件类与具体装饰类可以独立变化，他能是低耦合的。用户可以根据需要来增加新的具体构件类和具体装饰类，在使用时再对其进行各种组合，原有代码无须改变，符合“开闭原则”。
</code></pre><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><pre><code>1，会产生很多的小对象，增加了系统的复杂性
2，这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。
</code></pre><h4 id="装饰者与适配者模式的区别："><a href="#装饰者与适配者模式的区别：" class="headerlink" title="装饰者与适配者模式的区别："></a>装饰者与适配者模式的区别：</h4><p>   1，适配器模式主要用来兼容那些不能在一起工作的类，使他们转化为可以兼容目标接口，虽然也可以实现和装饰者一样的增加新职责，但目的不在此。<br>        装饰者模式主要是给被装饰者增加新职责的。<br>   2，适配器模式是用新接口来调用原接口，原接口对新系统是不可见或者说不可用的。<br>        装饰者模式原封不动的使用原接口，系统对装饰的对象也通过原接口来完成使用。<br>   3，适配器是知道被适配者的详细情况的（就是那个类或那个接口）。<br>        装饰者只知道其接口是什么，至于其具体类型（是基类还是其他派生类）只有在运行期间才知道。</p>
<h4 id="装饰者和继承的区别："><a href="#装饰者和继承的区别：" class="headerlink" title="装饰者和继承的区别："></a>装饰者和继承的区别：</h4><h5 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h5><p>　　优点：代码结构清晰，而且实现简单<br>　　缺点：对于每一个的需要增强的类都要创建具体的子类来帮助其增强，这样会导致继承体系过于庞大。</p>
<h5 id="装饰者："><a href="#装饰者：" class="headerlink" title="装饰者："></a>装饰者：</h5><p>　　优点：内部可以通过多态技术对多个需要增强的类进行增强<br>       缺点：需要内部通过多态技术维护需要增强的类的实例。进而使得代码稍微复杂。</p>
<h5 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h5><pre><code>1，需要扩展一个类的功能，或给一个类添加附加职责。
2，需要动态的给一个对象添加功能，这些功能可能不明确或者暂时的，可以随时很方便的动态撤销掉。
3，需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。
      4. 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/20/apache和tomcat区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qgx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qin12的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/apache和tomcat区别/" itemprop="url">
                  apache和tomcat区别
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-20 12:10:37" itemprop="dateCreated datePublished" datetime="2018-07-20T12:10:37+08:00">2018-07-20</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/javaEE/" itemprop="url" rel="index"><span itemprop="name">javaEE</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="apache和tomcat区别"><a href="#apache和tomcat区别" class="headerlink" title="apache和tomcat区别"></a>apache和tomcat区别</h3><p>经常在用apache和tomcat等这些服务器，可是总感觉还是不清楚他们之间有什么关系，在用tomcat的时候总出现apache，总感到迷惑，到底谁是主谁是次，因此特意在网上查询了一些这方面的资料，总结了一下： </p>
<h4 id="解析一-："><a href="#解析一-：" class="headerlink" title="解析一 ："></a>解析一 ：</h4><p>apache支持静态页，tomcat支持动态的，比如servlet等，<br>一般使用apache+tomcat的话，apache只是作为一个转发，对jsp的处理是由tomcat来处理的。<br>apche可以支持php cgi perl,但是要使用java的话，你需要tomcat在apache后台支撑，将java请求由apache转发给tomcat处理。<br>apache是web服务器，tomcat是应用（java）服务器，它只是一个servlet(jsp也翻译成servlet)容器，可以认为是apache的扩展，但是可以独立于apache运行。 </p>
<h5 id="这两个有以下几点可以比较的："><a href="#这两个有以下几点可以比较的：" class="headerlink" title="这两个有以下几点可以比较的："></a>这两个有以下几点可以比较的：</h5><p>1、两者都是apache组织开发的<br>2、两者都有HTTP服务的功能<br>3、两者都是免费的 </p>
<h5 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h5><p>Apache是专门用了提供HTTP服务的，以及相关配置的（例如虚拟主机、URL转发等等）<br>Tomcat是Apache组织在符合J2EE的JSP、Servlet标准下开发的一个JSP服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Runtime r=Runtime.getRuntime(); </span><br><span class="line">Process p=null; </span><br><span class="line">try</span><br><span class="line">&#123; </span><br><span class="line">p=r.exec(&quot;notepad&quot;); </span><br><span class="line">&#125; </span><br><span class="line">catch(Exception ex) </span><br><span class="line">&#123; </span><br><span class="line">System.out.println(&quot;fffff&quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="解析二："><a href="#解析二：" class="headerlink" title="解析二："></a>解析二：</h4><p>APACHE是一个web服务器环境程序 启用他可以作为web服务器使用 不过只支持静态网页 如(asp,php,cgi,jsp)等动态网页的就不行<br>如果要在APACHE环境下运行jsp 的话就需要一个解释器来执行jsp网页 而这个jsp解释器就是TOMCAT, 为什么还要JDK呢？因为jsp需要连接数据库的话 就要jdk来提供连接数据库的驱程，所以要运行jsp的web服务器平台就需要APACHE+TOMCAT+JDK </p>
<h5 id="整合的好处是："><a href="#整合的好处是：" class="headerlink" title="整合的好处是："></a>整合的好处是：</h5><p>如果客户端请求的是静态页面，则只需要Apache服务器响应请求<br>如果客户端请求动态页面，则是Tomcat服务器响应请求<br>因为jsp是服务器端解释代码的，这样整合就可以减少Tomcat的服务开销<br>C是一个结构化语言，如谭老爷子所说：它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。 </p>
<h4 id="解析三："><a href="#解析三：" class="headerlink" title="解析三："></a>解析三：</h4><ul>
<li>apache:侧重于http server </li>
<li>tomcat:侧重于servlet引擎，如果以standalone方式运行，功能上与apache等效 ， 支持JSP，但对静态网页不太理想； </li>
<li>apache是web服务器，tomcat是应用（java）服务器，它只是一个servlet(jsp也翻译成servlet)容器，可以认为是apache的扩展，但是可以独立于apache运行。<br>换句话说，apache是一辆卡车，上面可以装一些东西如html等。但是不能装水，要装水必须要有容器（桶），而这个桶也可以不放在卡车上。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="Qgx" />
            
              <p class="site-author-name" itemprop="name">Qgx</p>
              <p class="site-description motion-element" itemprop="description">漫漫长路，伴你同行</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">79</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">53</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/qin12" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:1520290900@qq.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=1520290900&website=www.oicqzone.com" target="_blank" title="QQ"><i class="fa fa-fw fa-QQ"></i>QQ</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Qgx</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Mist</a> v6.2.0</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.2.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.2.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.2.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
