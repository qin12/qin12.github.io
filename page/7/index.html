<!DOCTYPE html>






  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.2.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.jpg?v=6.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.2.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="漫漫长路，伴你同行">
<meta property="og:type" content="website">
<meta property="og:title" content="qin12的学习博客">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="qin12的学习博客">
<meta property="og:description" content="漫漫长路，伴你同行">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="qin12的学习博客">
<meta name="twitter:description" content="漫漫长路，伴你同行">



  <link rel="alternate" href="/atom.xml" title="qin12的学习博客" type="application/atom+xml" />




  <link rel="canonical" href="http://yoursite.com/page/7/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>qin12的学习博客</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">qin12的学习博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">只为成功找方法，不为失败找借口！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>




<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-photo">
    <a href="/photo/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-photo"></i> <br />摄影</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-music">
    <a href="/music/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-music"></i> <br />音乐</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/20/文件下载/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qgx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qin12的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/文件下载/" itemprop="url">
                  javaweb (六 )
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-20 12:10:37" itemprop="dateCreated datePublished" datetime="2018-07-20T12:10:37+08:00">2018-07-20</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/javaEE/" itemprop="url" rel="index"><span itemprop="name">javaEE</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><p>文件下载功能是web开发中经常使用到的功能，使用HttpServletResponse对象就可以实现文件的下载<br>文件下载功能的实现思路：</p>
<ul>
<li>1.获取要下载的文件的绝对路径</li>
<li>2.获取要下载的文件名</li>
<li>3.设置content-disposition响应头控制浏览器以下载的形式打开文件</li>
<li>4.获取要下载的文件输入流</li>
<li>5.创建数据缓冲区</li>
<li>6.通过response对象获取OutputStream流</li>
<li>7.将FileInputStream流写入到buffer缓冲区</li>
<li><p>8.使用OutputStream将缓冲区的数据输出到客户端浏览器<br>范例：使用Response实现文件下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package qgx.response.study;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.net.URLEncoder;</span><br><span class="line"></span><br><span class="line">@WebServlet(name = &quot;ResponseDemo2&quot;)</span><br><span class="line">public class ResponseDemo2 extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        downloadChineseFileByOutputStream(response);//下载中文文件</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void downloadChineseFileByOutputStream(HttpServletResponse response) throws IOException &#123;</span><br><span class="line">        String realPath = this.getServletContext().getRealPath(&quot;/download/自由.jpg&quot;);//获取要下载的文件的绝对路径</span><br><span class="line">        String fileName = realPath.substring(realPath.lastIndexOf(&quot;\\&quot;)+1);//获取要下载的文件名</span><br><span class="line">        //设置content-disposition响应头控制浏览器以下载的形式打开文件，中文文件名要使用URLEncoder.encode方法进行编码，否则会出现文件名乱码</span><br><span class="line">        response.setHeader(&quot;content-disposition&quot;, &quot;attachment;filename=&quot;+ URLEncoder.encode(fileName, &quot;UTF-8&quot;));</span><br><span class="line">        InputStream in = new FileInputStream(realPath);//获取文件输入流</span><br><span class="line">        int len = 0;</span><br><span class="line">        byte[] buffer = new byte[1024];</span><br><span class="line">        OutputStream out = response.getOutputStream();</span><br><span class="line">        while ((len = in.read(buffer)) &gt; 0) &#123;</span><br><span class="line">            out.write(buffer,0,len);//将缓冲区的数据输出到客户端浏览器</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载中文文件时，需要注意的地方就是中文文件名要使用URLEncoder.encode方法进行编码(URLEncoder.encode(fileName, “字符编码”))，否则会出现文件名乱码。</p>
</li>
<li>文件下载注意事项：编写文件下载功能时推荐使用OutputStream流，避免使用PrintWriter流，因为OutputStream流是字节流，可以处理任意类型的数据，而PrintWriter流是字符流，只能处理字符数据，如果用字符流处理字节数据，会导致数据丢失。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/20/一、commons-dbutils简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qgx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qin12的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/一、commons-dbutils简介/" itemprop="url">
                  Apache的DBUtils框架学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-20 12:10:37" itemprop="dateCreated datePublished" datetime="2018-07-20T12:10:37+08:00">2018-07-20</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/javaEE/" itemprop="url" rel="index"><span itemprop="name">javaEE</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、commons-dbutils简介"><a href="#一、commons-dbutils简介" class="headerlink" title="一、commons-dbutils简介"></a>一、commons-dbutils简介</h3><p>commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。因此dbutils成为很多不喜欢hibernate的公司的首选。</p>
<h4 id="commons-dbutilsAPI介绍："><a href="#commons-dbutilsAPI介绍：" class="headerlink" title="commons-dbutilsAPI介绍："></a>commons-dbutilsAPI介绍：</h4><ul>
<li>org.apache.commons.dbutils.QueryRunner</li>
<li>org.apache.commons.dbutils.ResultSetHandler<h4 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h4></li>
<li>org.apache.commons.dbutils.DbUtils</li>
</ul>
<h3 id="二、QueryRunner类使用讲解"><a href="#二、QueryRunner类使用讲解" class="headerlink" title="二、QueryRunner类使用讲解"></a>二、QueryRunner类使用讲解</h3><p>该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。<br>QueryRunner类提供了两个构造方法：</p>
<ul>
<li>默认的构造方法</li>
<li>需要一个 javax.sql.DataSource 来作参数的构造方法。</li>
</ul>
<h4 id="2-1、QueryRunner类的主要方法"><a href="#2-1、QueryRunner类的主要方法" class="headerlink" title="2.1、QueryRunner类的主要方法"></a>2.1、QueryRunner类的主要方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Object query(Connection conn, String sql, Object[] params, ResultSetHandler rsh) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。</span><br><span class="line">public Object query(String sql, Object[] params, ResultSetHandler rsh) throws SQLException:　几乎与第一种方法一样；唯一的不同在于它不将数据库连接提供给方法，并且它是从提供给构造方法的数据源(DataSource) 或使用的setDataSource 方法中重新获得 Connection。</span><br><span class="line">　public Object query(Connection conn, String sql, ResultSetHandler rsh) throws SQLException : 执行一个不需要置换参数的查询操作。</span><br><span class="line">　　public int update(Connection conn, String sql, Object[] params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。</span><br><span class="line">　　public int update(Connection conn, String sql) throws SQLException：用来执行一个不需要置换参数的更新操作。</span><br></pre></td></tr></table></figure>
<h4 id="2-2、使用QueryRunner类实现CRUD"><a href="#2-2、使用QueryRunner类实现CRUD" class="headerlink" title="2.2、使用QueryRunner类实现CRUD"></a>2.2、使用QueryRunner类实现CRUD</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">package DaoImpl;</span><br><span class="line"></span><br><span class="line">import Dao.AdminDao;</span><br><span class="line">import model.Admin;</span><br><span class="line">import org.apache.commons.dbutils.QueryRunner;</span><br><span class="line">import org.apache.commons.dbutils.ResultSetHandler;</span><br><span class="line">import org.apache.commons.dbutils.handlers.BeanHandler;</span><br><span class="line">import util.DBHelper;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">public class AdminDaoImpl implements AdminDao &#123;</span><br><span class="line">    private Connection connection;</span><br><span class="line">    private QueryRunner queryRunner;</span><br><span class="line">    private PreparedStatement preparedStatement;</span><br><span class="line"></span><br><span class="line">    public AdminDaoImpl() &#123;</span><br><span class="line">        queryRunner = new QueryRunner();</span><br><span class="line">        connection = DBHelper.getConnection();</span><br><span class="line">        if (connection != null) &#123;</span><br><span class="line">            System.out.println(&quot;链接成功&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Admin findByUserName(String username) &#123;</span><br><span class="line">        String sql = &quot;select * from admin where username = ?&quot;;</span><br><span class="line">        ResultSetHandler&lt;Admin&gt; rsHandle = new BeanHandler&lt;Admin&gt;(Admin.class);</span><br><span class="line">        Admin admin = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            admin = queryRunner.query(connection, sql, rsHandle, username);</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return admin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean addAdmin(Admin admin) &#123;</span><br><span class="line">        Connection conn = null;</span><br><span class="line">        PreparedStatement stmt = null;</span><br><span class="line">        if (admin != null) &#123;</span><br><span class="line">            String sql = &quot;insert into admin(username,password)&quot; + &quot;values(?,?)&quot;;</span><br><span class="line">            try &#123;</span><br><span class="line">                conn = DBHelper.getConnection();</span><br><span class="line">                stmt = conn.prepareStatement(sql);</span><br><span class="line">                stmt.execute(&quot;set Names utf8&quot;);</span><br><span class="line">                stmt.setString(1, admin.getUsername());</span><br><span class="line">                stmt.setString(2, admin.getPassword());</span><br><span class="line">                stmt.executeUpdate();</span><br><span class="line">                return true;</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean modifyAdmin(Admin admin) &#123;</span><br><span class="line">        String sql = &quot;update admin set username=?,password=? where Id =?&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">            preparedStatement.setString(1, admin.getUsername());</span><br><span class="line">            preparedStatement.setString(2, admin.getPassword());</span><br><span class="line">            preparedStatement.setString(3, admin.getId());</span><br><span class="line">            preparedStatement.executeUpdate();</span><br><span class="line">            return true;</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、ResultSetHandler接口使用讲解"><a href="#三、ResultSetHandler接口使用讲解" class="headerlink" title="三、ResultSetHandler接口使用讲解"></a>三、ResultSetHandler接口使用讲解</h3><p>　该接口用于处理java.sql.ResultSet，将数据按要求转换为另一种形式。<br>　　ResultSetHandler接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)</p>
<h4 id="3-1、ResultSetHandler接口的实现类"><a href="#3-1、ResultSetHandler接口的实现类" class="headerlink" title="3.1、ResultSetHandler接口的实现类"></a>3.1、ResultSetHandler接口的实现类</h4><ul>
<li>ArrayHandler：把结果集中的第一行数据转成对象数组。</li>
<li>ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。</li>
<li>BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。</li>
<li>BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。</li>
<li>ColumnListHandler：将结果集中某一列的数据存放到List中。</li>
<li>KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。</li>
<li>MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</li>
<li>MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">package javatest;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.dbutils.QueryRunner;</span><br><span class="line">import org.apache.commons.dbutils.handlers.*;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import util.DBHelper;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class ResultSetHandlerTest &#123;</span><br><span class="line">    QueryRunner queryRunner = null;</span><br><span class="line">    Connection connection = DBHelper.getConnection();</span><br><span class="line"></span><br><span class="line">    public ResultSetHandlerTest() &#123;</span><br><span class="line">        queryRunner = new QueryRunner();</span><br><span class="line">        connection = DBHelper.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 把结果集中的某一行数据转成对象数组。</span><br><span class="line">     *</span><br><span class="line">     * @throws SQLException</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testArrayHandler() throws SQLException &#123;</span><br><span class="line">        String sql = &quot;select * from admin where Id=3&quot;;</span><br><span class="line">        Object result[] = (Object[]) queryRunner.query(connection, sql, new ArrayHandler());</span><br><span class="line">        System.out.println(Arrays.asList(result));  //list  toString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 把结果集中的每一行数据都转成一个数组，再存放到List中。</span><br><span class="line">     *</span><br><span class="line">     * @throws SQLException</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testArrayListHandler() throws SQLException &#123;</span><br><span class="line"></span><br><span class="line">        QueryRunner queryRunner = new QueryRunner();</span><br><span class="line">        String sql = &quot;select * from admin&quot;;</span><br><span class="line">        List&lt;Object[]&gt; list = (List) queryRunner.query(connection, sql, new ArrayListHandler());</span><br><span class="line">        for (Object[] o : list) &#123;</span><br><span class="line">            System.out.println(Arrays.asList(o));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将结果集中某一列的数据存放到List中。</span><br><span class="line">     * 获取固定列的所有数据</span><br><span class="line">     *</span><br><span class="line">     * @throws SQLException</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testColumnListHandler() throws SQLException &#123;</span><br><span class="line">        QueryRunner queryRunner = new QueryRunner();</span><br><span class="line">        String sql = &quot;select * from admin&quot;;</span><br><span class="line">        List list = (List) queryRunner.query(connection, sql, new ColumnListHandler(&quot;username&quot;));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。</span><br><span class="line">     *</span><br><span class="line">     * @throws SQLException</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testKeyedHandler() throws SQLException &#123;</span><br><span class="line">        QueryRunner queryRunner = new QueryRunner();</span><br><span class="line">        String sql = &quot;select * from admin&quot;;</span><br><span class="line">        Map&lt;Integer, Map&gt; map = (Map) queryRunner.query(connection, sql, new KeyedHandler(&quot;Id&quot;));</span><br><span class="line">        System.out.println(map.entrySet());</span><br><span class="line">        /*</span><br><span class="line">        [1=&#123;Id=1, username=1, password=1&#125;, 2=&#123;Id=2, username=秦, password=123&#125;, 3=&#123;Id=3, username=秦光旭, password=1234567&#125;, 4=&#123;Id=4, username=秦光旭, password=123456&#125;]</span><br><span class="line">         */</span><br><span class="line">        System.out.println(map.get(1));</span><br><span class="line">        //&#123;Id=1, username=1, password=1&#125;</span><br><span class="line">        for (Map.Entry&lt;Integer, Map&gt; me : map.entrySet()) &#123;</span><br><span class="line">            int id = me.getKey();</span><br><span class="line">            Map&lt;String, Object&gt; innermap = me.getValue();</span><br><span class="line">            for (Map.Entry&lt;String, Object&gt; innerme : innermap.entrySet()) &#123;</span><br><span class="line">                String columnName = innerme.getKey();</span><br><span class="line">                Object value = innerme.getValue();</span><br><span class="line">                System.out.println(columnName + &quot;=&quot; + value);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;----------------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        /*</span><br><span class="line">Id=1</span><br><span class="line">username=1</span><br><span class="line">password=1</span><br><span class="line">----------------</span><br><span class="line">Id=2</span><br><span class="line">username=秦</span><br><span class="line">password=123</span><br><span class="line">----------------</span><br><span class="line">Id=3</span><br><span class="line">username=秦光旭</span><br><span class="line">password=1234567</span><br><span class="line">----------------</span><br><span class="line">Id=4</span><br><span class="line">username=秦光旭</span><br><span class="line">password=123456</span><br><span class="line">----------------</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</span><br><span class="line">     *</span><br><span class="line">     * @throws SQLException</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testMapHandler() throws SQLException &#123;</span><br><span class="line">        QueryRunner queryRunner = new QueryRunner();</span><br><span class="line">        String sql = &quot;select * from admin&quot;;</span><br><span class="line">        Map&lt;String, Object&gt; map = queryRunner.query(connection, sql, new MapHandler());</span><br><span class="line">        for (Map.Entry&lt;String,Object&gt; me : map.entrySet())&#123;</span><br><span class="line">            System.out.println(me.getKey() + &quot;=&quot; +me.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将结果集中的每一行数据都封装到一个Map里，然后再存放到List</span><br><span class="line">     * @throws SQLException</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testMapListHandler() throws SQLException&#123;</span><br><span class="line">        QueryRunner queryRunner = new QueryRunner();</span><br><span class="line">        String  sql = &quot;select * from admin&quot;;</span><br><span class="line">        List&lt;Map&gt; list = (List) queryRunner.query(connection,sql,new MapListHandler());</span><br><span class="line">        for (Map&lt;String,Object&gt; map:list) &#123;</span><br><span class="line">            for (Map.Entry&lt;String,Object&gt; me:map.entrySet()) &#123;</span><br><span class="line">                System.out.println(me.getKey()+&quot;=&quot;+me.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @throws SQLException</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testScalarHandler() throws SQLException&#123;</span><br><span class="line">        QueryRunner queryRunner = new QueryRunner();</span><br><span class="line">        String sql = &quot;select count(*) from admin&quot;;</span><br><span class="line">        long count = queryRunner.query(connection,sql,new ScalarHandler&lt;&gt;(1));</span><br><span class="line">       int count1 = Integer.parseInt(String.valueOf(count));</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        System.out.println(count1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、DbUtils类使用讲解"><a href="#四、DbUtils类使用讲解" class="headerlink" title="四、DbUtils类使用讲解"></a>四、DbUtils类使用讲解</h3><h4 id="DbUtils-：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下："><a href="#DbUtils-：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：" class="headerlink" title="DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下："></a>DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：</h4><ul>
<li>public static void close(…) throws java.sql.SQLException：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。</li>
<li>public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。</li>
<li>public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 </li>
<li>public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/20/Spring Boot 常用注解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qgx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qin12的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/Spring Boot 常用注解/" itemprop="url">
                  Spring Boot(二)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-20 12:10:37" itemprop="dateCreated datePublished" datetime="2018-07-20T12:10:37+08:00">2018-07-20</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Spring-Boot-常用注解"><a href="#Spring-Boot-常用注解" class="headerlink" title="Spring Boot 常用注解"></a>Spring Boot 常用注解</h3><h4 id="RestController和-RequestMapping"><a href="#RestController和-RequestMapping" class="headerlink" title="@RestController和@RequestMapping"></a>@RestController和@RequestMapping</h4><p>@RestController被称为一个构造型（stereotype）注解。它为阅读代码的开发人员提供建议。对于Spring，该类扮演了一个特殊角色。它继承自@Controller注解。4.0之前的版本，spring MVC的组件都使用@Controller来标识当前类是一个控制器servlet。</p>
<p>使用这个特性，我们可以开发REST服务的时候不需要使用@Controller而专门的@RestController。</p>
<p>实例：在本实例中，Example的类是一个web @Controller，所以当处理进来的web请求时，Spring会询问它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.boot.*;</span><br><span class="line">import org.springframework.boot.autoconfigure.*;</span><br><span class="line">import org.springframework.stereotype.*;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line">@RestController</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">public class Example &#123;    </span><br><span class="line">    @RequestMapping(&quot;/&quot;)    </span><br><span class="line">    String home() &#123;        </span><br><span class="line">        return &quot;Hello World!&quot;;</span><br><span class="line">    &#125;    </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        SpringApplication.run(Example.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>@RequestMapping：</strong>注解提供路由信息。它告诉Spring任何来自”/“路径的HTTP请求都应该被映射到home方法。</p>
<p><strong>@RestController</strong>注解告诉Spring以字符串的形式渲染结果，并直接返回给调用者。该注解有六个属性： </p>
<p><strong>params：</strong>指定request中必须包含某些参数值是，才让该方法处理。</p>
<p><strong>headers：</strong>指定request中必须包含某些指定的header值，才能让该方法处理请求。</p>
<p><strong>value：</strong>指定请求的实际地址，指定的地址可以是URI Template 模式。</p>
<p><strong>method：</strong>指定请求的method类型， GET、POST、PUT、DELETE等。</p>
<p><strong>consumes：</strong>指定处理请求的提交内容类型（Content-Type），如application/json,text/html。</p>
<p><strong>produces：</strong>指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回。<br>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(“/test”) </span><br><span class="line">@ResponseBody </span><br><span class="line">public String test()&#123; </span><br><span class="line">    return ”ok”; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong>@RestController和@RequestMapping注解是Spring MVC注解（它们不是Spring Boot的特定部分）</p>
<p><strong>@EnableAutoConfiguration</strong><br>第二个类级别的注解是@EnableAutoConfiguration。这个注解告诉Spring Boot根据添加的jar依赖猜测你想如何配置Spring。由于spring-boot-starter-web添加了Tomcat和Spring MVC，所以auto-configuration将假定正在开发一个web应用并相应地对Spring进行设置。</p>
<p><strong>Starter POMs</strong>和<strong>Auto-Configuration</strong>设计auto-configuration的目的是更好的使用”Starter POMs”，但这两个概念没有直接的联系。可以自由地挑选starter POMs以外的jar依赖，并且Spring Boot将仍旧尽最大努力去自动配置你的应用。</p>
<p>你可以通过将@EnableAutoConfiguration或@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。</p>
<p>注意：只需要添加一个@EnableAutoConfiguration注解。建议将它添加到主@Configuration类上，如果发现应用不想要的特定自动配置类，可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.boot.autoconfigure.*;  </span><br><span class="line">import org.springframework.boot.autoconfigure.jdbc.*;  </span><br><span class="line">import org.springframework.context.annotation.*;  </span><br><span class="line">@Configuration  </span><br><span class="line">@EnableAutoConfiguration(exclude=&#123;DataSourceAutoConfiguration.class&#125;)  </span><br><span class="line">public class MyConfiguration &#123;  </span><br><span class="line">    // ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>@Configuration<br>Spring Boot提倡基于Java的配置。尽管可以使用一个XML源来调用SpringApplication.run()，但官方建议使用@Configuration类作为主要源。一般定义main方法的类也是主要@Configuration的一个很好候选。</p>
<p>不需要将所有的@Configuration放进一个单独的类。@Import注解可以用来导入其他配置类。另外也可以使用@ComponentScan注解自动收集所有的Spring组件，包括@Configuration类。</p>
<p>如果需要使用基于XML的配置，官方建议仍旧从一个@Configuration类开始。可以使用附加的@ImportResource注解加载XML配置文件。</p>
<p>@Configuration注解该类，等价与XML中配置beans；用@Bean标注方法等价于XML中配置bean。<br>@ComponentScan(basePackages = “com.yoodb.blog”,includeFilters = <a href="mailto:{@ComponentScan.Filter" target="_blank" rel="noopener">{@ComponentScan.Filter</a>(Aspect.class)})</p>
<p>@ComponentScan：表示将该类自动发现扫描组件。如果扫描到有@Component、<br>@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。</p>
<p>使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。如果没有配置，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。</p>
<p>@SpringBootApplication<br>很多Spring Boot开发者总是使用@Configuration，@EnableAutoConfiguration和@ComponentScan注解他们的main类。由于这些注解被如此频繁地一块使用（特别是你遵循以上最佳实践时），Spring Boot提供一个方便的@SpringBootApplication选择。</p>
<p>该@SpringBootApplication注解等价于以默认属性使用@Configuration，@EnableAutoConfiguration和@ComponentScan。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.boot.SpringApplication;  </span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;  </span><br><span class="line">@SpringBootApplication </span><br><span class="line">// 等同于@Configuration @EnableAutoConfiguration @ComponentScan  </span><br><span class="line"></span><br><span class="line">public class Application &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        SpringApplication.run(Application.class, args);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Spring Boot将尝试校验外部的配置，默认使用JSR-303（如果在classpath路径中）。可以轻松的为@ConfigurationProperties类添加JSR-303 javax.validation约束注解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component  </span><br><span class="line">@ConfigurationProperties(prefix=&quot;connection&quot;)  </span><br><span class="line">public class ConnectionSettings &#123;  </span><br><span class="line">    @NotNull  </span><br><span class="line">    private InetAddress remoteAddress;  </span><br><span class="line">        // ... getters and setters  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>@Profiles</strong><br>Spring Profiles提供了一种隔离应用程序配置的方式，并让这些配置只能在特定的环境下生效。任何@Component或@Configuration都能被@Profile标记，从而限制加载它的时机。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration  </span><br><span class="line">@Profile(&quot;production&quot;)  </span><br><span class="line">public class ProductionConfiguration &#123;  </span><br><span class="line">    // ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>全局异常处理<br><strong>@ControllerAdvice：</strong>包含@Component。可以被扫描到。统一处理异常。<br><strong>@ExceptionHandler（Exception.class）：</strong>用在方法上面表示遇到这个异常就执行以下方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 全局异常处理 </span><br><span class="line"> */  @ControllerAdvice  public class GlobalDefaultExceptionHandler &#123;  </span><br><span class="line">    public static final String DEFAULT_ERROR_VIEW = &quot;error&quot;;  </span><br><span class="line">    @ExceptionHandler(&#123;TypeMismatchException.class,NumberFormatException.class&#125;)  </span><br><span class="line">    public ModelAndView formatErrorHandler(HttpServletRequest req, Exception e) throws Exception &#123;  </span><br><span class="line">        ModelAndView mav = new ModelAndView();  </span><br><span class="line">        mav.addObject(&quot;error&quot;,&quot;参数类型错误&quot;);  </span><br><span class="line">        mav.addObject(&quot;exception&quot;, e);  </span><br><span class="line">        mav.addObject(&quot;url&quot;, RequestUtils.getCompleteRequestUrl(req));  </span><br><span class="line">        mav.addObject(&quot;timestamp&quot;, new Date());  </span><br><span class="line">        mav.setViewName(DEFAULT_ERROR_VIEW);  </span><br><span class="line">        return mav;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">通过@value注解来读取application.properties里面的配置，使用实例参考：</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//************** application.properties *************//</span><br><span class="line"></span><br><span class="line">qq_api_key=********1***********</span><br><span class="line">qq_api_secrt=******2***********</span><br><span class="line"></span><br><span class="line">/************* Java **************/</span><br><span class="line">@Value(&quot;$&#123;qq_api_key&#125;&quot;)  </span><br><span class="line">private String API_KEY;  </span><br><span class="line">@Value(&quot;$&#123;qq_api_secrt&#125;&quot;)  </span><br><span class="line">private String API_SECRET;</span><br></pre></td></tr></table></figure>
<p>注意：使用@Value注解的时其使用的类如果被其他类作为对象引用，必须要使用注入的方式而不能new，一般常用的配置在application.properties文件。</p>
<p>其他注解<br><strong>@ResponseBody：</strong>表示该方法的返回结果直接写入HTTP response body中一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@Responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。如异步获取json数据，加上@Responsebody后，会直接返回json数据。</p>
<p><strong>@Component：</strong>泛指组件，当组件不好归类时，可以使用这个注解进行标注。一般公共的方法会用上这个注解。</p>
<p><strong>@RequestParam：</strong>用在方法的参数前面，实例：<br>@RequestParam String a =request.getParameter(“a”);</p>
<p><strong>@PathVariable:</strong>路径变量注解，其参数与大括号里的名字一样要保持一致，实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestMapping(&quot;yoodb/detail/&#123;id&#125;&quot;)  </span><br><span class="line">public String getByMacAddress(@PathVariable String id)&#123;  </span><br><span class="line">//do something;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>@Inject：</strong>等价于默认的@Autowired，只是没有required属性。</p>
<p><strong>@Bean:</strong>相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。</p>
<p><strong>@AutoWired：</strong>自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。</p>
<p><strong>@Qualifier：</strong>当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Autowired </span><br><span class="line">@Qualifier(value = &quot;demoInfoService&quot;) </span><br><span class="line">private DemoInfoService demoInfoService;</span><br><span class="line">@Resource(name=&quot;name&quot;,type=&quot;type&quot;)：没有括号内内容的话，默认byName。与@Autowired类似。</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/20/组合模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qgx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qin12的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/组合模式/" itemprop="url">
                  组合模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-20 12:10:37" itemprop="dateCreated datePublished" datetime="2018-07-20T12:10:37+08:00">2018-07-20</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/设计模式/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式的设计动机：组合模式定义了如何将容器对象和叶子对象进行递归组合，使得客户在使用的过程中无须进行区分，可以对他们进行一致的处理。</p>
<h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>  组合模式组合多个对象形成树形结构以表示“整体-部分”的结构层次。</p>
<pre><code>组合模式对单个对象(叶子对象)和组合对象(组合对象)具有一致性，它将对象组织到树结构中，可以用来描述整体与部分的关系。同时它也模糊了简单元素(叶子对象)和复杂元素(容器对象)的概念，使得客户能够像处理简单元素一样来处理复杂元素，从而使客户程序能够与复杂元素的内部结构解耦。
</code></pre><h4 id="结构："><a href="#结构：" class="headerlink" title="结构："></a>结构：</h4><p>  组合模式主要包含如下几个角色：</p>
<pre><code>  1.Component ：组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component子部件。 
2.Leaf：叶子对象。叶子结点没有子结点。 
3.Composite：容器对象，定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关操作，如增加(add)和删除(remove)等。
</code></pre><p>  从模式结构中我们看出了叶子节点和容器对象都实现Component接口，这也是能够将叶子对象和容器对象一致对待的关键所在。</p>
<h4 id="模式实现："><a href="#模式实现：" class="headerlink" title="模式实现："></a>模式实现：</h4><p> 在文件系统中，可能存在很多种格式的文件，如果图片，文本文件、视频文件等等，这些不同的格式文件的浏览方式都不同，同时对文件夹的浏览就是对文件夹中文件的浏览，但是对于客户而言都是浏览文件，两者之间不存在什么差别，现在只用组合模式来模拟浏览文件</p>
<h5 id="首先是文件类：File-java"><a href="#首先是文件类：File-java" class="headerlink" title="首先是文件类：File.java"></a>首先是文件类：File.java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public abstract class File &#123;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    public File(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="然后是文件夹类：Folder-java，该类包含对文件的增加、删除和浏览三个方法"><a href="#然后是文件夹类：Folder-java，该类包含对文件的增加、删除和浏览三个方法" class="headerlink" title="然后是文件夹类：Folder.java，该类包含对文件的增加、删除和浏览三个方法"></a>然后是文件夹类：Folder.java，该类包含对文件的增加、删除和浏览三个方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class Folder extends File&#123;</span><br><span class="line">    private List&lt;File&gt; files;</span><br><span class="line">    </span><br><span class="line">    public Folder(String name)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">        files = new ArrayList&lt;File&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 浏览文件夹中的文件</span><br><span class="line">     */</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        for(File file : files)&#123;</span><br><span class="line">            file.display();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * @desc 向文件夹中添加文件</span><br><span class="line">     * @param file</span><br><span class="line">     * @return void</span><br><span class="line">     */</span><br><span class="line">    public void add(File file)&#123;</span><br><span class="line">        files.add(file);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * @desc 从文件夹中删除文件</span><br><span class="line">     * @param file</span><br><span class="line">     * @return void</span><br><span class="line">     */</span><br><span class="line">    public void remove(File file)&#123;</span><br><span class="line">        files.remove(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="然后是三个文件类：TextFile-java、ImageFile-java、VideoFile-java"><a href="#然后是三个文件类：TextFile-java、ImageFile-java、VideoFile-java" class="headerlink" title="然后是三个文件类：TextFile.java、ImageFile.java、VideoFile.java"></a>然后是三个文件类：TextFile.java、ImageFile.java、VideoFile.java</h5><h5 id="TextFile-java"><a href="#TextFile-java" class="headerlink" title="TextFile.java"></a>TextFile.java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class TextFile extends File&#123;</span><br><span class="line"></span><br><span class="line">    public TextFile(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;这是文本文件，文件名：&quot; + super.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ImageFile-java"><a href="#ImageFile-java" class="headerlink" title="ImageFile.java"></a>ImageFile.java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ImagerFile extends File&#123;</span><br><span class="line"></span><br><span class="line">    public ImagerFile(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;这是图像文件，文件名：&quot; + super.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="VideoFile-java"><a href="#VideoFile-java" class="headerlink" title="VideoFile.java"></a>VideoFile.java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class VideoFile extends File&#123;</span><br><span class="line"></span><br><span class="line">    public VideoFile(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;这是影像文件，文件名：&quot; + super.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最后是客户端"><a href="#最后是客户端" class="headerlink" title="最后是客户端"></a>最后是客户端</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 我们先建立一个这样的文件系统</span><br><span class="line">         *                  总文件</span><br><span class="line">         *                  </span><br><span class="line">         *   a.txt    b.jpg                   c文件夹              </span><br><span class="line">         *                      c_1.text  c_1.rmvb    c_1.jpg   </span><br><span class="line">         *                                                       </span><br><span class="line">         */ </span><br><span class="line">        //总文件夹</span><br><span class="line">        Folder zwjj = new Folder(&quot;总文件夹&quot;);</span><br><span class="line">        //向总文件夹中放入三个文件：1.txt、2.jpg、1文件夹</span><br><span class="line">        TextFile aText= new TextFile(&quot;a.txt&quot;);</span><br><span class="line">        ImagerFile bImager = new ImagerFile(&quot;b.jpg&quot;);</span><br><span class="line">        Folder cFolder = new Folder(&quot;C文件夹&quot;);</span><br><span class="line">        </span><br><span class="line">        zwjj.add(aText);</span><br><span class="line">        zwjj.add(bImager);</span><br><span class="line">        zwjj.add(cFolder);</span><br><span class="line">        </span><br><span class="line">        //向C文件夹中添加文件：c_1.txt、c_1.rmvb、c_1.jpg </span><br><span class="line">        TextFile cText = new TextFile(&quot;c_1.txt&quot;);</span><br><span class="line">        ImagerFile cImage = new ImagerFile(&quot;c_1.jpg&quot;);</span><br><span class="line">        VideoFile cVideo = new VideoFile(&quot;c_1.rmvb&quot;);</span><br><span class="line">        </span><br><span class="line">        cFolder.add(cText);</span><br><span class="line">        cFolder.add(cImage);</span><br><span class="line">        cFolder.add(cVideo);</span><br><span class="line">        </span><br><span class="line">        //遍历C文件夹</span><br><span class="line">        cFolder.display();</span><br><span class="line">        //将c_1.txt删除</span><br><span class="line">        cFolder.remove(cText);</span><br><span class="line">        System.out.println(&quot;-----------------------&quot;);</span><br><span class="line">        cFolder.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>1、可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，使得增加新构件也更容易。</li>
<li>2、客户端调用简单，客户端可以一致的使用组合结构或其中单个对象。</li>
<li>3、定义了包含叶子对象和容器对象的类层次结构，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，可以形成复杂的树形结构。</li>
<li>4、更容易在组合体内加入对象构件，客户端不必因为加入了新的对象构件而更改原有代码。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><pre><code>1，你想表示对象的部分-整体层次结构
2，你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。
</code></pre><h4 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h4><pre><code>1、 组合模式用于将多个对象组合成树形结构以表示“整体-部分”的结构层次。组合模式对单个对象（叶子对象）和组合对象（容器对象）的使用具有一致性。

2、 组合对象的关键在于它定义了一个抽象构建类，它既可表示叶子对象，也可表示容器对象，客户仅仅需要针对这个抽象构建进行编程，无须知道他是叶子对象还是容器对象，都是一致对待。

3、 组合模式虽然能够非常好地处理层次结构，也使得客户端程序变得简单，但是它也使得设计变得更加抽象，而且也很难对容器中的构件类型进行限制，这会导致在增加新的构件时会产生一些问题。
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/20/集合框架二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qgx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qin12的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/集合框架二/" itemprop="url">
                  java 基础知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-20 12:10:37" itemprop="dateCreated datePublished" datetime="2018-07-20T12:10:37+08:00">2018-07-20</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="集合框架二"><a href="#集合框架二" class="headerlink" title="集合框架二"></a>集合框架二</h3><h4 id="7、集合类各容器方法："><a href="#7、集合类各容器方法：" class="headerlink" title="7、集合类各容器方法："></a>7、集合类各容器方法：</h4><p>接口Collection方法摘要(没有构造方法)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a)添加：</span><br><span class="line">i.  boolean add(E e)</span><br><span class="line"></span><br><span class="line">j.  boolean addAll(Collection c)</span><br><span class="line">b)删除：</span><br><span class="line">i.  void clear():清空容器</span><br><span class="line">j.  boolean remove(Objec object):</span><br><span class="line">k.  boolean removeAll(Collection c):</span><br><span class="line">c)判断：</span><br><span class="line">i.  boolean contains(Object object):判断是否包含此元素</span><br><span class="line">j.  boolean containsAll(Collection c):判断是否包含一堆元素</span><br><span class="line">k.  boolean equals(Object object):比较此collection与指定对象是否相等</span><br><span class="line">m.  boolean isEmpty():判断是否集合为空</span><br><span class="line">d)获取：</span><br><span class="line">h.  Iterator iterator():取出</span><br><span class="line">i.  int hashCode():返回此collection的哈希值</span><br><span class="line">j.  int size():返回此collection中元素的个数</span><br><span class="line">k.  boolean retainAll(Collection c):取交集</span><br><span class="line">m.  Object toArray():返回此collection中所有元素的数组</span><br><span class="line">n.  T[] toArray(T[] a):返回包含此collection中所有元素的数值。</span><br></pre></td></tr></table></figure></p>
<h4 id="List集合子类及其方法"><a href="#List集合子类及其方法" class="headerlink" title="List集合子类及其方法"></a>List集合子类及其方法</h4><ul>
<li>(1)List接口是Collection接口的一个子接口。</li>
<li>(2)List接口中的元素有如下特点(对角标的操作都是特有方法，因为有序)：<br>A:元素有序(存储顺序和取出顺序一致)<br>B:元素可以重复</li>
<li>(3)List接口中的特有方法<br>A:add(int index,Object obj):在指定位置加入元素<br>B:remove(int index):移除指定位置的元素<br>C:set(int index,Object obj):修改指定位置的元素<br>D:get(int index):获取指定位置的元素<br>E:indexOf(Object obj):获取指定元素的位置<br>F:subList(int start,int end):从一个大的List中截取一个小的List<br>G:listIterator():返回一个List接口特有的迭代器</li>
</ul>
<h4 id="1-、ArrayList："><a href="#1-、ArrayList：" class="headerlink" title="(1)、ArrayList："></a>(1)、ArrayList：</h4><p>构造方法摘要：(少用，不是重点)<br>ArrayList()：构造一个初始容量为 10 的空列表。<br>ArrayList(Collection&lt;? extends E&gt; c)： 构造一个包含指定 collection 的元素的列表，</p>
<p>ArrayList(int initialCapacity)： 构造一个具有指定初始容量的空列表。<br>    方法摘要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">添加：</span><br><span class="line">boolean add(E e)： 将指定的元素添加到此列表的尾部。</span><br><span class="line">void add(int index, E element)： 将指定的元素插入此列表中的指定位置。</span><br><span class="line">boolean addAll(Collection&lt;? extends E&gt; c):按照指定 collection 的迭代器所返回的元素顺序，</span><br><span class="line">将该 collection 中的所有元素添加到此列表的尾部 </span><br><span class="line">boolean addAll(int index, Collection&lt;? extends E&gt; c)： 从指定的位置开始，将指定 collection</span><br><span class="line">      中的所有元素插入到此列表中。 </span><br><span class="line">删除：</span><br><span class="line">void clear(): 移除此列表中的所有元素。</span><br><span class="line"> remove(int index): 移除此列表中指定位置上的元素。 </span><br><span class="line">boolean remove(Object o): 移除此列表中首次出现的指定元素（如果存在）。</span><br><span class="line">protected  void removeRange(int fromIndex, int toIndex): </span><br><span class="line">移除列表中索引在 fromIndex（包括）和 toIndex（不包括）之间的所有元素。</span><br><span class="line">boolean removeAll(Collection&lt;?&gt; c): 从列表中移除指定 collection 中包含的其所有元素 </span><br><span class="line">|获取：</span><br><span class="line"> get(int index): 返回此列表中指定位置上的元素。</span><br><span class="line">int indexOf(Object o): 返回此列表中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1。</span><br><span class="line">int lastIndexOf(Object o) 返回此列表中最后一次出现的指定元素的索引，或如果此列表不包含索引，则返回 -1。   </span><br><span class="line">public List&lt;E&gt; subList(int fromIndex,int toIndex): 返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的部分视图。</span><br><span class="line">Iterator&lt;E&gt; iterator(): 返回按适当顺序在列表的元素上进行迭代的迭代器。</span><br><span class="line">ListIterator&lt;E&gt; listIterator(int index):返回列表中元素的列表迭代器(按适当顺序),从列表的指定位置开始。</span><br><span class="line">修改：(特有方法！！)</span><br><span class="line"> set(int index, E element): 用指定的元素替代此列表中指定位置上的元素。</span><br></pre></td></tr></table></figure></p>
<h4 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="(2)LinkedList:"></a>(2)LinkedList:</h4><p>构造方法摘要：<br>LinkedList(): 构造一个空列表。<br>LinkedList(Collection&lt;? extends E&gt; c): 构造一个包含指定 collection 中的元素的列表，<br>      这些元素按其 collection 的迭代器返回的顺序排列。<br>方法摘要:(特有的)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">添加</span><br><span class="line">void addFirst(E e): 将指定元素插入此列表的开头。 </span><br><span class="line">void addLast(E e): 将指定元素添加到此列表的结尾。 </span><br><span class="line">获取元素，但不删除元素</span><br><span class="line"> get(int index): 返回此列表中指定位置处的元素。           </span><br><span class="line"> getFirst(): 返回此列表的第一个元素。          </span><br><span class="line"> getLast(): 返回此列表的最后一个元素。</span><br><span class="line">获取元素且删除元素</span><br><span class="line"> remove()： 获取并移除此列表的头（第一个元素）。          </span><br><span class="line"> remove(int index)： 移除此列表中指定位置处的元素。         </span><br><span class="line">boolean remove(Object o)： 从此列表中移除首次出现的指定元素（如果存在）。         </span><br><span class="line"> removeFirst()： 移除并返回此列表的第一个元素。 </span><br><span class="line"> removeLast(): 移除并返回此列表的最后一个元素。</span><br><span class="line">修改</span><br><span class="line"> set(int index, E element) 将此列表中指定位置的元素替换为指定的元素。 </span><br><span class="line">#### (3)Vector</span><br><span class="line">构造方法摘要：</span><br><span class="line">Vector(): 构造一个空向量，使其内部数据数组的大小为 10，其标准容量增量为零。          </span><br><span class="line">Vector(Collection&lt;? extends E&gt; c):  构造一个包含指定 collection 中的元素的向量，</span><br><span class="line">   这些元素按其 collection 的迭代器返回元素的顺序排列。</span><br></pre></td></tr></table></figure></p>
<p>方法摘要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">添加：</span><br><span class="line">boolean add(E e): 将指定元素添加到此向量的末尾。</span><br><span class="line">void add(int index, E element): 在此向量的指定位置插入指定的元素。         </span><br><span class="line">boolean addAll(Collection&lt;? extends E&gt; c):</span><br><span class="line">将指定 Collection 中的所有元素添加到此向量的末尾， </span><br><span class="line">按照指定 collection 的迭代器所返回的顺序添加这些元素。 </span><br><span class="line">boolean addAll(int index, Collection&lt;? extends E&gt; c): 在指定位置将指定 Collection 中的所有元素插入到此向量中。</span><br><span class="line">获取:</span><br><span class="line">Enumeration&lt;E&gt; elements(): 返回此向量的组件的枚举。</span><br><span class="line">  Vector特有的取出方式:</span><br><span class="line">  枚举和迭代器很像，其实枚举和迭代器是一样的，只是因为枚举的名称和方法的名称</span><br><span class="line">  名字都过长，所以枚举被迭代器取代了。</span><br><span class="line">枚举Enumeration的方法摘要：</span><br><span class="line">boolean hasMoreElements(): 测试此枚举是否包含更多的元素。 </span><br><span class="line"> nextElement(): 如果此枚举对象至少还有一个可提供的元素，</span><br><span class="line"> 则返回此枚举的下一个元素。</span><br></pre></td></tr></table></figure></p>
<h4 id="Set集合子类及其方法"><a href="#Set集合子类及其方法" class="headerlink" title="Set集合子类及其方法"></a>Set集合子类及其方法</h4><p>(1)HashSet:它不保证set的迭代顺序;特别是它不保证该顺序恒久不变.此类允许使用null元素。<br>构造方法：<br>HashSet() 构造一个新的空 set，其底层 HashMap 实例的默认初始容量是 16，加载因子是 0.75。<br>HashSet(Collection&lt;? extends E&gt; c) 构造一个包含指定 collection 中的元素的新 set。<br>方法摘要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">boolean add(E e) 如果此 set 中尚未包含指定元素，则添加指定元素。   </span><br><span class="line">void clear() 从此 set 中移除所有元素。</span><br><span class="line"> </span><br><span class="line">Object clone() 返回此 HashSet 实例的浅表副本：并没有复制这些元素本身。  </span><br><span class="line">boolean contains(Object o) 如果此 set 包含指定元素，则返回 true。  </span><br><span class="line">boolean isEmpty() 如果此 set 不包含任何元素，则返回 true。 </span><br><span class="line"> </span><br><span class="line">Iterator&lt;E&gt; iterator() 返回对此 set 中元素进行迭代的迭代器。  </span><br><span class="line">boolean remove(Object o) 如果指定元素存在于此 set 中，则将其移除。</span><br><span class="line">  </span><br><span class="line">int size() 返回此 set 中的元素的数量（set 的容量）。  </span><br><span class="line">(2)TreeSet:使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的 Comparator 进行排序.</span><br><span class="line">构造方法：</span><br><span class="line">TreeSet() 构造一个新的空 set，该set根据其元素的自然顺序进行排序。          </span><br><span class="line">TreeSet(Collection&lt;? extends E&gt; c) </span><br><span class="line">构造一个包含指定 collection 元素的新 TreeSet，它按照其元素的自然顺序进行排序。 </span><br><span class="line">TreeSet(Comparator&lt;? super E&gt; comparator)  构造一个新的空 TreeSet，它根据指定比较器进行排序。</span><br></pre></td></tr></table></figure></p>
<p>方法摘要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">添加：</span><br><span class="line">boolean add(E e)  将指定的元素添加到此 set（如果该元素尚未存在于 set 中）。</span><br><span class="line">boolean addAll(Collection&lt;? extends E&gt; c) 将指定 collection 中的所有元素添加到此 set 中。</span><br><span class="line">删除：</span><br><span class="line"> void clear() 移除此 set 中的所有元素。 </span><br><span class="line"> boolean remove(Object o)  将指定的元素从 set 中移除（如果该元素存在于此 set 中）。 </span><br><span class="line">  pollFirst() 获取并移除第一个（最低）元素；如果此 set 为空，则返回 null。 </span><br><span class="line">  pollLast() 获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。 </span><br><span class="line">获取：</span><br><span class="line"> Iterator&lt;E&gt; iterator()  返回在此 set 中的元素上按升序进行迭代的迭代器。</span><br><span class="line"> first() 返回此 set 中当前第一个（最低）元素。</span><br><span class="line">  last() 返回此 set 中当前最后一个（最高）元素。</span><br><span class="line"> int size()  返回 set 中的元素数（set 的容量）。</span><br><span class="line">判断：</span><br><span class="line">boolean isEmpty()  如果此 set 不包含任何元素，则返回 true。 </span><br><span class="line">boolean contains(Object o) 如果此 set 包含指定的元素，则返回 true。 </span><br><span class="line">Map:将键映射到值的对象。Map集合没有迭代器！Map集合特点：该集合存储键值对。而且键是唯一的。</span><br><span class="line">方法摘要：</span><br></pre></td></tr></table></figure></p>
<p>   添加：<br>     V put(K key, V value) 将指定的值与此映射中的指定键关联（可选操作）。<br>     void putAll(Map&lt;? extends K,? extends V&gt; m) 从指定映射中将所有映射关系复制到此映射中<br>   删除：<br>              void clear()  从此映射中移除所有映射关系（可选操作）。<br>     V remove(Object key) 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。<br>   判断<br>     boolean containsKey(Object key) 如果此映射包含指定键的映射关系，则返回 true。<br>              boolean containsValue(Object value) 如果此映射将一个或多个键映射到指定值，则返回 true。<br>              boolean isEmpty() 如果此映射未包含键-值映射关系，则返回 true。<br>           获取<br>     int size() 返回此映射中的键-值映射关系数。<br>              Collection<v> values()  返回此映射中包含的值的 Collection 视图。<br><code>`</code></v></p>
<h5 id="重点：Map集合没有迭代器，以下是Map的两种取出方式："><a href="#重点：Map集合没有迭代器，以下是Map的两种取出方式：" class="headerlink" title="重点：Map集合没有迭代器，以下是Map的两种取出方式："></a>重点：Map集合没有迭代器，以下是Map的两种取出方式：</h5><ul>
<li>第一种：Set<k> keySet()<br>返回此映射中包含的键的Set视图，将Map集合中所有的键存入Set集合，然后再通过Set集合的<br>迭代器取出所有的键，再根据get方法获取每个键的值；</k></li>
<li>第二种：Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()<br>返回此映射中包含的映射关系的Set视图，将Map集合中的映射关系存入到Set集合中，<br>这个映射关系的数据类型是Map.entry,再通过Map.Entry类的方法再要取出关系里面的键和值<br>Map.Entry的方法摘要：<br>boolean equals(Object o)  比较指定对象与此项的相等性。</li>
</ul>
<p>K getKey()  返回与此项对应的键。</p>
<p>V getValue() 返回与此项对应的值。</p>
<p>int hashCode() 返回此映射项的哈希码值。<br>V setValue(V value) 用指定的值替换与此项对应的值(特有！！！)。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/20/单片机/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qgx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qin12的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/单片机/" itemprop="url">
                  单片机
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-20 12:10:37" itemprop="dateCreated datePublished" datetime="2018-07-20T12:10:37+08:00">2018-07-20</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/杂七杂八/" itemprop="url" rel="index"><span itemprop="name">杂七杂八</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="单片机"><a href="#单片机" class="headerlink" title="单片机"></a>单片机</h3><h5 id="4、89C51共有哪些中断源？对其中端请求如何进行控制？"><a href="#4、89C51共有哪些中断源？对其中端请求如何进行控制？" class="headerlink" title="4、89C51共有哪些中断源？对其中端请求如何进行控制？"></a>4、89C51共有哪些中断源？对其中端请求如何进行控制？</h5><p>答：（1）89C51有如下中断源<br>①:外部中断0请求，低电平有效<br>②:外部中断1请求，低电平有效<br>③T0：定时器、计数器0溢出中断请求<br>④T1：定时器、计数器1溢出中断请求<br>⑤TX/RX：串行接口中断请求<br>（2）通过对特殊功能寄存器TCON、SCON、IE、IP的各位进行置位或复位等操作，可实现各种中断控制功能</p>
<h5 id="5、什么是中断优先级？中断优先处理的原则是什么？"><a href="#5、什么是中断优先级？中断优先处理的原则是什么？" class="headerlink" title="5、什么是中断优先级？中断优先处理的原则是什么？"></a>5、什么是中断优先级？中断优先处理的原则是什么？</h5><p>答：中断优先级是CPU相应中断的先后顺序。原则：<br>（1）  先响应优先级高的中断请求，再响应优先级低的<br>（2）  如果一个中断请求已经被响应，同级的其它中断请求将被禁止<br>（3）  如果同级的多个请求同时出现，则CPU通过内部硬件查询电路，按查询顺序确定应该响应哪个中断请求<br>查询顺序：外部中断0→定时器0中断→外部中断1→定时器1中断→串行接口中断</p>
<h5 id="11、当正在执行某一个中断源的中断服务程序时，如果有新的中断请求出现，试问在什么情况下可响应新的中断请求？在什么情况下不能响应新的中断请求？"><a href="#11、当正在执行某一个中断源的中断服务程序时，如果有新的中断请求出现，试问在什么情况下可响应新的中断请求？在什么情况下不能响应新的中断请求？" class="headerlink" title="11、当正在执行某一个中断源的中断服务程序时，如果有新的中断请求出现，试问在什么情况下可响应新的中断请求？在什么情况下不能响应新的中断请求？"></a>11、当正在执行某一个中断源的中断服务程序时，如果有新的中断请求出现，试问在什么情况下可响应新的中断请求？在什么情况下不能响应新的中断请求？</h5><p>答：（1）符合以下6个条件可响应新的中断请求：<br>a)       有中断源发出中断请求<br>b)       中断允许位EA=1，即CPU开中断<br>c)       申请中断的中断源的中断允许位为1，即中断没有被屏蔽<br>d)       无同级或更高级中断正在被服务<br>e)       当前的指令周期已结束<br>f)        若现行指令为RETI或访问IE或IP指令时，该指令以及紧接着的另一条指令已被执行完</p>
<h5 id="14、89C51各中断源的中断标志是如何产生的？又是如何清0的？CPU响应中断时，中断入口地址各是多少？"><a href="#14、89C51各中断源的中断标志是如何产生的？又是如何清0的？CPU响应中断时，中断入口地址各是多少？" class="headerlink" title="14、89C51各中断源的中断标志是如何产生的？又是如何清0的？CPU响应中断时，中断入口地址各是多少？"></a>14、89C51各中断源的中断标志是如何产生的？又是如何清0的？CPU响应中断时，中断入口地址各是多少？</h5><p>答：各中断标志的产生和清“0”如下：<br>（1）  外部中断类<br>外部中断是由外部原因引起的，可以通过两个固定引脚，即外部中断0和外部中断1输入信号。<br>外部中断0请求信号，由P3.2脚输入。通过IT0来决定中断请求信号是低电平有效还是下跳变有效。一旦输入信号有效，则向CPU申请中断，并且使IE0=1。硬件复位。<br>外部中断1请求信号，功能与用法类似外部中断0<br>（2）  定时中断类<br>定时中断是为满足定时或计数溢出处理需要而设置的。当定时器/计数器中的计数结构发生计数溢出的，即表明定时时间到或计数值已满，这时就以计数溢出信号作为中断请求，去置位一个溢出标志位。这种中断请求是在单片机芯片内部发生的，无需在芯片上设置引入端，但在计数方式时，中断源可以由外部引入。<br>TF0：定时器T0溢出中断请求。当定时器T0产生溢出时，定时器T0请求标志TF0=1，请求中断处理。使用中断时由硬件复位，在查询方式下可由软件复位。<br>TF1：定时器T1溢出中断请求。功能与用法类似定时器T0<br>（3）  串行口中断类<br>串行口中断是为串行数据的传送需要而设置的。串行中断请求也是在单片机芯片内部发生的，但当串行口作为接收端时，必须有一完整的串行帧数据从RI端引入芯片，才可能引发中断。<br>RI或TI：串行口中断请求。当接收或发送一串帧数据时，使内部串行口中断请求标志RI或TI=1，并请求中断。响应后必须软件复位。<br> CPU响应中断时，中断入口地址如下：<br> 中断源       入口地址<br>外部中断0    0003H<br>定时器T0中断000BH<br>外部中断1    0013H<br>定时器T1中断001BH<br>串行口中断    0023H</p>
<p>答案：<br>        1）首先判断有无键按下：  (3分)<br>        将列线全部置0，读行线状态，若P1.0~P1.3全为1，则表明无键按下，若出现低电平即0，则有键按下，记录下行号 i ;<br>        2) 其次，如有键按下，判断具体键号  (7分)<br>        方法如下：逐列为低，其它为高，再读行线状态，如出现哪一行为低，记录此时的列号j ， 则证明第i行第j列的按键被按下，至此完成键盘的行列式扫描。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/20/JAVA线程池原理详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qgx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qin12的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/JAVA线程池原理详解/" itemprop="url">
                  JAVA线程池原理详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-20 12:10:37" itemprop="dateCreated datePublished" datetime="2018-07-20T12:10:37+08:00">2018-07-20</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/javaEE/" itemprop="url" rel="index"><span itemprop="name">javaEE</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="JAVA线程池原理详解"><a href="#JAVA线程池原理详解" class="headerlink" title="JAVA线程池原理详解"></a>JAVA线程池原理详解</h3><h4 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、线程是稀缺资源，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以重复使用。</span><br><span class="line">2、可以根据系统的承受能力，调整线程池中工作线程的数量，防止因为消耗过多内存导致服务器崩溃。</span><br></pre></td></tr></table></figure>
<h4 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(</span><br><span class="line">   int corePoolSize,</span><br><span class="line">   int maximumPoolSize,</span><br><span class="line">   long keepAliveTime,</span><br><span class="line">   TimeUnit unit,</span><br><span class="line">   BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">   RejectedExecutionHandler handler)</span><br><span class="line">corePoolSize：线程池核心线程数量</span><br><span class="line">maximumPoolSize:线程池最大线程数量</span><br><span class="line">keepAliverTime：当活跃线程数大于核心线程数时，空闲的多余线程最大存活时间</span><br><span class="line">unit：存活时间的单位</span><br><span class="line">workQueue：存放任务的队列</span><br><span class="line">handler：超出线程范围和队列容量的任务的处理程序</span><br></pre></td></tr></table></figure>
<h4 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h4><p>提交一个任务到线程池中，线程池的处理流程如下：</p>
<ul>
<li>1、判断线程池里的核心线程是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。</li>
<li>2、线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li>
<li>3、判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</li>
</ul>
<p><img src="/img/xiancheng.png" alt=""></p>
<h4 id="线程池的源码解读"><a href="#线程池的源码解读" class="headerlink" title="线程池的源码解读"></a>线程池的源码解读</h4><h5 id="1、ThreadPoolExecutor的execute-方法"><a href="#1、ThreadPoolExecutor的execute-方法" class="headerlink" title="1、ThreadPoolExecutor的execute()方法"></a>1、ThreadPoolExecutor的execute()方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command == null)</span><br><span class="line">       throw new NullPointerException();</span><br><span class="line">　　　//如果线程数大于等于基本线程数或者线程创建失败，将任务加入队列</span><br><span class="line">    if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;</span><br><span class="line">　　　　//线程池处于运行状态并且加入队列成功</span><br><span class="line">       if (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">          if (runState != RUNNING || poolSize == 0)</span><br><span class="line">             ensureQueuedTaskHandled(command);</span><br><span class="line">          &#125;</span><br><span class="line">　　　　　　//线程池不处于运行状态或者加入队列失败，则创建线程（创建的是非核心线程）</span><br><span class="line">       else if (!addIfUnderMaximumPoolSize(command))</span><br><span class="line">　　　　　　  //创建线程失败，则采取阻塞处理的方式</span><br><span class="line">         reject(command); // is shutdown or saturated</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h5 id="2、创建线程的方法：addIfUnderCorePoolSize-command"><a href="#2、创建线程的方法：addIfUnderCorePoolSize-command" class="headerlink" title="2、创建线程的方法：addIfUnderCorePoolSize(command)"></a>2、创建线程的方法：addIfUnderCorePoolSize(command)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private boolean addIfUnderCorePoolSize(Runnable firstTask) &#123;</span><br><span class="line">    Thread t = null;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (poolSize &lt; corePoolSize &amp;&amp; runState == RUNNING)</span><br><span class="line">           t = addThread(firstTask);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    if (t == null)</span><br><span class="line">       return false;</span><br><span class="line">    t.start();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们重点来看第7行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private Thread addThread(Runnable firstTask) &#123;</span><br><span class="line">     Worker w = new Worker(firstTask);</span><br><span class="line">     Thread t = threadFactory.newThread(w);</span><br><span class="line">     if (t != null) &#123;</span><br><span class="line">        w.thread = t;</span><br><span class="line">        workers.add(w);</span><br><span class="line">        int nt = ++poolSize;</span><br><span class="line">        if (nt &gt; largestPoolSize)</span><br><span class="line">           largestPoolSize = nt;</span><br><span class="line">      &#125;</span><br><span class="line">     return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里将线程封装成工作线程worker，并放入工作线程组里，worker类的方法run方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">       Runnable task = firstTask;</span><br><span class="line">       firstTask = null;</span><br><span class="line">       while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">           runTask(task);</span><br><span class="line">            task = null;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">        workerDone(this);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>worker在执行完任务后，还会通过getTask方法循环获取工作队里里的任务来执行。<br>我们通过一个程序来观察线程池的工作原理：<br>1、创建一个线程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadPoolTest implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">   @Override</span><br><span class="line">   public void run()</span><br><span class="line">   &#123;</span><br><span class="line">       try</span><br><span class="line">       &#123;</span><br><span class="line">           Thread.sleep(300);</span><br><span class="line">       &#125;</span><br><span class="line">       catch (InterruptedException e)</span><br><span class="line">       &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、线程池循环运行16个线程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">   &#123;</span><br><span class="line">       LinkedBlockingQueue&lt;Runnable&gt; queue =</span><br><span class="line">           new LinkedBlockingQueue&lt;Runnable&gt;(5);</span><br><span class="line">       ThreadPoolExecutor threadPool = new ThreadPoolExecutor(5, 10, 60, TimeUnit.SECONDS, queue);</span><br><span class="line">       for (int i = 0; i &lt; 16 ; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           threadPool.execute(</span><br><span class="line">               new Thread(new ThreadPoolTest(), &quot;Thread&quot;.concat(i + &quot;&quot;)));</span><br><span class="line">           System.out.println(&quot;线程池中活跃的线程数： &quot; + threadPool.getPoolSize());</span><br><span class="line">           if (queue.size() &gt; 0)</span><br><span class="line">           &#123;</span><br><span class="line">               System.out.println(&quot;----------------队列中阻塞的线程数&quot; + queue.size());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       threadPool.shutdown();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">线程池中活跃的线程数： 1</span><br><span class="line">线程池中活跃的线程数： 2</span><br><span class="line">线程池中活跃的线程数： 3</span><br><span class="line">线程池中活跃的线程数： 4</span><br><span class="line">线程池中活跃的线程数： 5</span><br><span class="line">线程池中活跃的线程数： 5</span><br><span class="line">----------------队列中阻塞的线程数1</span><br><span class="line">线程池中活跃的线程数： 5</span><br><span class="line">----------------队列中阻塞的线程数2</span><br><span class="line">线程池中活跃的线程数： 5</span><br><span class="line">----------------队列中阻塞的线程数3</span><br><span class="line">线程池中活跃的线程数： 5</span><br><span class="line">----------------队列中阻塞的线程数4</span><br><span class="line">线程池中活跃的线程数： 5</span><br><span class="line">----------------队列中阻塞的线程数5</span><br><span class="line">线程池中活跃的线程数： 6</span><br><span class="line">----------------队列中阻塞的线程数5</span><br><span class="line">线程池中活跃的线程数： 7</span><br><span class="line">----------------队列中阻塞的线程数5</span><br><span class="line">线程池中活跃的线程数： 8</span><br><span class="line">----------------队列中阻塞的线程数5</span><br><span class="line">线程池中活跃的线程数： 9</span><br><span class="line">----------------队列中阻塞的线程数5</span><br><span class="line">线程池中活跃的线程数： 10</span><br><span class="line">----------------队列中阻塞的线程数5</span><br><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task Thread[Thread15,5,main] rejected from java.util.concurrent.ThreadPoolExecutor@232204a1[Running, pool size = 10, active threads = 10, queued tasks = 5, completed tasks = 0]</span><br><span class="line">   at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047)</span><br><span class="line">   at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823)</span><br><span class="line">   at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369)</span><br><span class="line">   at test.ThreadTest.main(ThreadTest.java:17)</span><br></pre></td></tr></table></figure></p>
<p>从结果可以观察出：<br>创建的线程池具体配置为：核心线程数量为5个；全部线程数量为10个；工作队列的长度为5。<br>我们通过queue.size()的方法来获取工作队列中的任务数。<br>运行原理：<br>        刚开始都是在创建新的线程，达到核心线程数量5个后，新的任务进来后不再创建新的线程，而是将任务加入工作队列，任务队列到达上线5个后，新的任务又会创建新的普通线程，直到达到线程池最大的线程数量10个，后面的任务则根据配置的饱和策略来处理。我们这里没有具体配置，使用的是默认的配置AbortPolicy:直接抛出异常。<br>        当然，为了达到我需要的效果，上述线程处理的任务都是利用休眠导致线程没有释放！！</p>
<p>RejectedExecutionHandler：饱和策略<br>当队列和线程池都满了，说明线程池处于饱和状态，那么必须对新提交的任务采用一种特殊的策略来进行处理。这个策略默认配置是AbortPolicy，表示无法处理新的任务而抛出异常。JAVA提供了4中策略：</p>
<ul>
<li>AbortPolicy：直接抛出异常</li>
<li>CallerRunsPolicy：只用调用所在的线程运行任务</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>
<li>DiscardPolicy：不处理，丢弃掉。</li>
</ul>
<p>我们现在用第四种策略来处理上面的程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">   &#123;</span><br><span class="line">       LinkedBlockingQueue&lt;Runnable&gt; queue =</span><br><span class="line">           new LinkedBlockingQueue&lt;Runnable&gt;(3);</span><br><span class="line">       RejectedExecutionHandler handler = new ThreadPoolExecutor.DiscardPolicy();</span><br><span class="line"></span><br><span class="line">       ThreadPoolExecutor threadPool = new ThreadPoolExecutor(2, 5, 60, TimeUnit.SECONDS, queue,handler);</span><br><span class="line">       for (int i = 0; i &lt; 9 ; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           threadPool.execute(</span><br><span class="line">               new Thread(new ThreadPoolTest(), &quot;Thread&quot;.concat(i + &quot;&quot;)));</span><br><span class="line">           System.out.println(&quot;线程池中活跃的线程数： &quot; + threadPool.getPoolSize());</span><br><span class="line">           if (queue.size() &gt; 0)</span><br><span class="line">           &#123;</span><br><span class="line">               System.out.println(&quot;----------------队列中阻塞的线程数&quot; + queue.size());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       threadPool.shutdown();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">执行结果</span><br><span class="line">线程池中活跃的线程数： 1</span><br><span class="line">线程池中活跃的线程数： 2</span><br><span class="line">线程池中活跃的线程数： 2</span><br><span class="line">----------------队列中阻塞的线程数1</span><br><span class="line">线程池中活跃的线程数： 2</span><br><span class="line">----------------队列中阻塞的线程数2</span><br><span class="line">线程池中活跃的线程数： 2</span><br><span class="line">----------------队列中阻塞的线程数3</span><br><span class="line">线程池中活跃的线程数： 3</span><br><span class="line">----------------队列中阻塞的线程数3</span><br><span class="line">线程池中活跃的线程数： 4</span><br><span class="line">----------------队列中阻塞的线程数3</span><br><span class="line">线程池中活跃的线程数： 5</span><br><span class="line">----------------队列中阻塞的线程数3</span><br><span class="line">线程池中活跃的线程数： 5</span><br><span class="line">----------------队列中阻塞的线程数3</span><br></pre></td></tr></table></figure></p>
<p>这里采用了丢弃策略后，就没有再抛出异常，而是直接丢弃。在某些重要的场景下，可以采用记录日志或者存储到数据库中，而不应该直接丢弃。<br>设置策略有两种方式：</p>
<ul>
<li><p>第一种：<br>RejectedExecutionHandler handler = new ThreadPoolExecutor.DiscardPolicy();<br>ThreadPoolExecutor threadPool = new ThreadPoolExecutor(2, 5, 60, TimeUnit.SECONDS, queue,handler);</p>
</li>
<li><p>第二种：<br>ThreadPoolExecutor threadPool = new ThreadPoolExecutor(2, 5, 60, TimeUnit.SECONDS, queue);<br>threadPool.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/20/我的第一个原型设计——模仿知乎的注册界面/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qgx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qin12的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/我的第一个原型设计——模仿知乎的注册界面/" itemprop="url">
                  我的第一个原型设计——模仿知乎的注册界面
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-20 12:10:37" itemprop="dateCreated datePublished" datetime="2018-07-20T12:10:37+08:00">2018-07-20</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="我的第一个原型设计——模仿知乎的注册界面"><a href="#我的第一个原型设计——模仿知乎的注册界面" class="headerlink" title="我的第一个原型设计——模仿知乎的注册界面"></a>我的第一个原型设计——模仿知乎的注册界面</h3><h4 id="一-模仿什么？"><a href="#一-模仿什么？" class="headerlink" title="一.模仿什么？"></a>一.模仿什么？</h4><p>模仿一个网站，从两个方面来看。首先是用元件所呈现的这个界面最直观的部分，然后就是交互部分。</p>
<h5 id="1-元件布局"><a href="#1-元件布局" class="headerlink" title="1.元件布局"></a>1.元件布局</h5><p>首先我们来看一下知乎注册界面：</p>
<p><img src="/img/zhihu.png" alt=""><br>从这个布局，我们很容易分析出来它的各个元件，如下：</p>
<p><img src="/img/zhihu2.png" alt=""></p>
<h5 id="2-交互效果"><a href="#2-交互效果" class="headerlink" title="2.交互效果"></a>2.交互效果</h5><p>从上往下看</p>
<ul>
<li><p>（1）logo和标语，没有什么交互效果，只需要填充相应的数据就可以了。</p>
</li>
<li><p>（2）注册矩形框，和下面的条条一样是蓝色的。</p>
</li>
<li><p>（3）登录矩形框 </p>
</li>
</ul>
<ul>
<li>鼠标悬浮的时候，颜色会变浅 </li>
<li>点击登陆后，登录的字体的颜色会变蓝色 </li>
<li>注册的字体颜色会变成灰色 </li>
<li>下面的蓝色小条条会移动到登录矩形框的下面 </li>
<li>界面也会变成登陆的时的界面。</li>
</ul>
<ul>
<li><p>（4）输入，包括姓名、手机号和密码<br>对于页面载入时，鼠标的光标的焦点在姓名输入框；<br>如果三个文本框都没有输入文字，点击注册按钮，这时在姓名文本框后面就会出现一个提示“姓名不能为空”，并且这个文字会抖动一下。<br>同样姓名填了，手机号没有填，右侧就会提醒手机号不能为空，文字也会抖几下，密码同上。<br>当出现提示文字的时候，如果把鼠标的焦点移到该输入文本框时候，提示文字就会从右侧逐渐消退。</p>
</li>
<li><p>（5）提示中的知乎协议和下载知乎APP,点击就会进入另外的界面。</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/20/Servlet 简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qgx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qin12的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/Servlet 简介/" itemprop="url">
                  javaweb (一)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-20 12:10:37" itemprop="dateCreated datePublished" datetime="2018-07-20T12:10:37+08:00">2018-07-20</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/javaEE/" itemprop="url" rel="index"><span itemprop="name">javaEE</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Servlet-简介"><a href="#Servlet-简介" class="headerlink" title="Servlet 简介"></a>Servlet 简介</h3><ul>
<li>Servlet是sun公司提供的一门用于开发动态web资源的技术。</li>
<li>Sun公司在其API中提供了一个servlet接口，用户若想用发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤：<ul>
<li>1、编写一个Java类，实现servlet接口。</li>
<li>2、把开发好的Java类部署到web服务器中。</li>
</ul>
</li>
</ul>
<p>按照一种约定俗成的称呼习惯，通常我们也把实现了servlet接口的java程序，称之为Servlet。</p>
<h3 id="Servlet-的运行过程"><a href="#Servlet-的运行过程" class="headerlink" title="Servlet 的运行过程"></a>Servlet 的运行过程</h3><p>Servlet 程序是由WEB服务器收到客户端的Servlet访问请求后</p>
<ul>
<li><ol>
<li>web服务器首先检查是否已经装载并创建了该Servlet的实例对象，如果是，则执行第4步，否则，执行第2步。</li>
</ol>
</li>
<li>2.装载并创建该Servlet 的一个实例对象</li>
<li>3.调用Servlet实例对象的init()方法。</li>
<li>4.创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。</li>
<li>web应用程序被停止或重新启动之前，Servlet 引擎将卸载Servlet，并在卸载之前调用Servlet的destory()方法。<br><img src="/img/servlet1.png" alt=""><br><img src="/img/servlet2.png" alt=""><br><img src="/img/servlet3.png" alt=""><br><img src="/img/servlet4.png" alt=""><br><img src="/img/servlet5.png" alt=""><br><img src="/img/servlet6.png" alt=""><br><img src="/img/servlet7.png" alt=""><br><img src="/img/servlet8.png" alt=""><h3 id="在IDEA中开发Servlet"><a href="#在IDEA中开发Servlet" class="headerlink" title="在IDEA中开发Servlet"></a>在IDEA中开发Servlet</h3>在IDEA中新建一个Web project工程。<br><img src="/img/创建webproject.png" alt=""></li>
<li>Servlet接口SUN公司定义了两个默认实现类，分别为：GenericServlet、HttpServlet。</li>
<li>HttpServlet指能够处理HTTP请求的servlet，它在原有Servlet接口上添加了一些与HTTP协议处理方法，它比Servlet接口的功能更为强大。因此开发人员在编写Servlet时，通常应继承这个类，而避免直接去实现Servlet接口。HttpServlet在实现Servlet接口时，覆写了service方法，该方法体内的代码会自动判断用户的请求方式，如为GET请求，则调用HttpServlet的doGet方法，如为Post请求，则调用doPost方法。因此，开发人员在编写Servlet时，通常只需要覆写doGet或doPost方法，而不要去覆写service方法。<br>ServletDemo1<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line">@WebServlet(name = &quot;ServletDemo1&quot;)</span><br><span class="line">public class ServletDemo1 extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">       doGet(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">                response.setContentType(&quot;text/html&quot;);</span><br><span class="line">                 PrintWriter out = response.getWriter();</span><br><span class="line">                 out.println(&quot;&lt;!DOCTYPE HTML PUBLIC \&quot;-//W3C//DTD HTML 4.01 Transitional//EN\&quot;&gt;&quot;);</span><br><span class="line">                 out.println(&quot;&lt;HTML&gt;&quot;);</span><br><span class="line">                 out.println(&quot;  &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;/TITLE&gt;&lt;/HEAD&gt;&quot;);</span><br><span class="line">                 out.println(&quot;  &lt;BODY&gt;&quot;);</span><br><span class="line">                 out.print(&quot;    This is &quot;);</span><br><span class="line">                 out.print(this.getClass());</span><br><span class="line">                 out.println(&quot;, using the GET method&quot;);</span><br><span class="line">                out.println(&quot;  &lt;/BODY&gt;&quot;);</span><br><span class="line">                 out.println(&quot;&lt;/HTML&gt;&quot;);</span><br><span class="line">                out.flush();</span><br><span class="line">                out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>配置web.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span><br><span class="line">         version=&quot;4.0&quot;&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;ServletDemo1&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/s&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后我们就可以通过浏览器访问ServletDemo1这个Servlet，如下图所示：<br><img src="/img/结果.png" alt=""></p>
<h3 id="Servlet开发注意细节"><a href="#Servlet开发注意细节" class="headerlink" title="Servlet开发注意细节"></a>Servlet开发注意细节</h3><h4 id="Servlet-访问URL映射配置"><a href="#Servlet-访问URL映射配置" class="headerlink" title="Servlet 访问URL映射配置"></a>Servlet 访问URL映射配置</h4><p>由于客户端是通过URL地址访问web服务器中的资源，所以Servlet程序若想被外界访问，必须把servlet程序映射到一个URL地址上，这个工作在web.xml文件中使用<servlet>元素和<servlet-mapping>元素完成。<br>　　<servlet>元素用于注册Servlet，它包含有两个主要的子元素：<servlet-name>和<servlet-class>，分别用于设置Servlet的注册名称和Servlet的完整类名。<br>一个<servlet-mapping>元素用于映射一个已注册的Servlet的一个对外访问路径，它包含有两个子元素：<servlet-name>和<url-pattern>，分别用于指定Servlet的注册名称和Servlet的对外访问路径。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> &lt;servlet&gt;</span><br><span class="line">  &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt;</span><br><span class="line"> &lt;servlet-class&gt;ServletDemo1&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt;</span><br><span class="line">       &lt;url-pattern&gt;/s&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></url-pattern></servlet-name></servlet-mapping></servlet-class></servlet-name></servlet></servlet-mapping></servlet></p>
<p>同一个Servlet可以被映射到多个URL上，即多个<servlet-mapping>元素的<servlet-name>子元素的设置值可以是同一个Servlet的注册名。 例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">  &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt;</span><br><span class="line"> &lt;servlet-class&gt;ServletDemo1&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt;</span><br><span class="line">       &lt;url-pattern&gt;/s&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line"> &lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt;</span><br><span class="line">       &lt;url-pattern&gt;/s1&lt;/url-pattern&gt;</span><br><span class="line">  &lt;/servlet-mapping&gt;</span><br><span class="line">  </span><br><span class="line">   &lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt;</span><br><span class="line">   &lt;url-pattern&gt;/s.htm&lt;/url-pattern&gt;</span><br><span class="line">   &lt;/servlet-mapping&gt;</span><br><span class="line">   </span><br><span class="line">  &lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt;</span><br><span class="line">       &lt;url-pattern&gt;/s.jsp&lt;/url-pattern&gt;</span><br><span class="line"> &lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></servlet-name></servlet-mapping></p>
<p>通过上面的配置，当我们想访问名称是ServletDemo1的Servlet，可以使用如下的几个地址去访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/s</span><br><span class="line">http://localhost:8080/s1</span><br><span class="line">http://localhost:8080/s.jsp</span><br><span class="line">http://localhost:8080/s.htm</span><br></pre></td></tr></table></figure></p>
<p>ServletDemo1被映射到了多个URL上。</p>
<h4 id="Servlet访问URL使用-通配符映射"><a href="#Servlet访问URL使用-通配符映射" class="headerlink" title="Servlet访问URL使用*通配符映射　　"></a>Servlet访问URL使用*通配符映射　　</h4><p>在Servlet映射到的URL中也可以使用*通配符，但是只能有两种固定的格式：一种格式是”*.扩展名”，另一种格式是以正斜杠（/）开头并以”/*”结尾。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">     &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt;</span><br><span class="line">     &lt;servlet-class&gt;ServletDemo1&lt;/servlet-class&gt;</span><br><span class="line">   &lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">     &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">     &lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></p>
<p><em>可以匹配任意的字符，所以此时可以用任意的URL去访问ServletDemo1这个Servlet，如下图所示：<br><img src="/img/结果2.png" alt=""><br>对于如下的一些映射关系：<br>　　Servlet1 映射到 /abc/</em><br>　　Servlet2 映射到 /<em><br>　　Servlet3 映射到 /abc<br>　　Servlet4 映射到 </em>.do<br>问题：<br>　　当请求URL为“/abc/a.html”，“/abc/<em>”和“/</em>”都匹配，哪个servlet响应<br>    　　Servlet引擎将调用Servlet1。<br>　　当请求URL为“/abc”时，“/abc/<em>”和“/abc”都匹配，哪个servlet响应<br>    　　Servlet引擎将调用Servlet3。<br>　　当请求URL为“/abc/a.do”时，“/abc/</em>”和“<em>.do”都匹配，哪个servlet响应<br>    　　Servlet引擎将调用Servlet1。<br>　　当请求URL为“/a.do”时，“/</em>”和“<em>.do”都匹配，哪个servlet响应<br>    　　Servlet引擎将调用Servlet2。<br>　　当请求URL为“/xxx/yyy/a.do”时，“/</em>”和“*.do”都匹配，哪个servlet响应<br>    　　Servlet引擎将调用Servlet2。<br>　　匹配的原则就是”谁长得更像就找谁”</p>
<h4 id="Servlet-与普通java类的区别"><a href="#Servlet-与普通java类的区别" class="headerlink" title="Servlet 与普通java类的区别"></a>Servlet 与普通java类的区别</h4><ul>
<li>Servlet是一个供其他Java程序（Servlet引擎）调用的Java类，它不能独立运行，它的运行完全由Servlet引擎来控制和调度。</li>
<li>针对客户端的多次Servlet请求，通常情况下，服务器只会创建一个Servlet实例对象，也就是说Servlet实例对象一旦创建，它就会驻留在内存中，为后续的其它请求服务，直至web容器退出，servlet实例对象才会销毁。</li>
<li>在Servlet的整个生命周期内，Servlet的init方法只被调用一次。而对一个Servlet的每次访问请求都导致Servlet引擎调用一次servlet的service方法。对于每次访问请求，Servlet引擎都会创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象，然后将这两个对象作为参数传递给它调用的Servlet的service()方法，service方法再根据请求方式分别调用doXXX方法。</li>
<li>如果在<servlet>元素中配置了一个<load-on-startup>元素，那么WEB应用程序在启动时，就会装载并创建Servlet的实例对象、以及调用Servlet实例对象的init()方法。</load-on-startup></servlet></li>
<li>举例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;invoker&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;</span><br><span class="line">        org.apache.catalina.servlets.InvokerServlet</span><br><span class="line">    &lt;/servlet-class&gt;</span><br><span class="line">    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>　　用途：为web应用写一个InitServlet，这个servlet配置为启动时装载，为整个web应用创建必要的数据库表和数据。</p>
<h4 id="缺省Servlet"><a href="#缺省Servlet" class="headerlink" title="缺省Servlet"></a>缺省Servlet</h4><ul>
<li>如果某个Servlet的映射路径仅仅为一个正斜杠（/），那么这个Servlet就成为当前Web应用程序的缺省Servlet。 </li>
<li>凡是在web.xml文件中找不到匹配的<servlet-mapping>元素的URL，它们的访问请求都将交给缺省Servlet处理，也就是说，缺省Servlet用于处理所有其他Servlet都不处理的访问请求。 例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">      &lt;servlet-name&gt;ServletDemo2&lt;/servlet-name&gt;</span><br><span class="line">      &lt;servlet-class&gt;ServletDemo2&lt;/servlet-class&gt;</span><br><span class="line">      &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    </span><br><span class="line">   &lt;!-- 将ServletDemo2配置成缺省Servlet --&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">      &lt;servlet-name&gt;ServletDemo2&lt;/servlet-name&gt;</span><br><span class="line">     &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">   &lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
</servlet-mapping></li>
</ul>
<p>当访问不存在的Servlet时，就使用配置的默认Servlet进行处理，如下图所示：<br><img src="/img/结果3.png" alt=""></p>
<p>　在&lt;tomcat的安装目录&gt;\conf\web.xml文件中，注册了一个名称为org.apache.catalina.servlets.DefaultServlet的Servlet，并将这个Servlet设置为了缺省Servlet。</p>
<p>当访问Tomcat服务器中的某个静态HTML文件和图片时，实际上是在访问这个缺省Servlet。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/20/详细讲解Android Studio中使用Git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qgx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qin12的学习博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/详细讲解Android Studio中使用Git/" itemprop="url">
                  初识GitLab
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-20 12:10:37" itemprop="dateCreated datePublished" datetime="2018-07-20T12:10:37+08:00">2018-07-20</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="详细讲解Android-Studio中使用Git"><a href="#详细讲解Android-Studio中使用Git" class="headerlink" title="详细讲解Android Studio中使用Git"></a>详细讲解Android Studio中使用Git</h3><p>作者博客链接：<br><a href="https://www.jianshu.com/p/059ed1e01229" target="_blank" rel="noopener">https://www.jianshu.com/p/059ed1e01229</a></p>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>以前项目版本管理工具一直用的都是SVN，现在换成Git，并且项目托管平台使用的是GitLab。虽然经常用GitHub，但是却很少使用到分支，因为都是自己在写，也不用开发版与发布版、打Tag那些，所以这篇文章主要讲下GitLab与Git的使用。</p>
<p>这篇文章还是会按我以前的写作风格，写的通俗易懂，并且全程自己操作一遍，目的是为了初学者也能看懂。</p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><strong>Git：</strong>Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。简单说，它就是一个管理项目版本的工具。</p>
<p><strong>GitLab：</strong>GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务。简单说，GitLab的性质是和GitHub一样的，都是用来存储项目的仓库。</p>
<h4 id="准备-Git"><a href="#准备-Git" class="headerlink" title="准备 Git"></a>准备 Git</h4><p><strong>3.1 安装Git</strong></p>
<p>下载地址：<br><a href="http://git-scm.com/download/" target="_blank" rel="noopener">http://git-scm.com/download/</a></p>
<p>安装步骤：双击安装，按默认选项一路下去即可。<br>安装完成后，在开始菜单里找到“Git”–&gt;“Git Bash”，出现如下图，就说明Git安装成功！<br><img src="/img/gitlab1.png" alt=""></p>
<p><strong>3.2 配置信息</strong></p>
<p>在上图命令行中输入你的用户名与邮箱<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure></p>
<p>命令中的 –global 参数表示你这台机器上所有的Git仓库都会使用这个配置。</p>
<p><strong>3.3 Android Studio中配置Git</strong></p>
<p>在Android Studio中点击Settings–&gt;Version Control –&gt; Git，然后在Path To Git executable上输入你刚刚安装Git的位置，最后点击Test按钮出现Git executed successfully说明配置成功，如下图：<br><img src="/img/gitlab2.png" alt=""></p>
<h4 id="GitLab-使用"><a href="#GitLab-使用" class="headerlink" title="GitLab 使用"></a>GitLab 使用</h4><p><strong>4.1 注册账号</strong></p>
<p>这里说下注册账号的时候需要注意的事项。<br>如果注册账号的时候提示如下错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">there was an error with the reCAPTCHA,please solve the reCAPTCHA again</span><br></pre></td></tr></table></figure></p>
<p>那是因为注册时需要验证码验证，就是reCAPTCHA，是一个图形验证码。但是这个验证码需要FQ才能看得到，否则你一直都注册不了。如图：<br><img src="/img/gitlab3.png" alt=""><br><strong>4.2 GitLab账户配置SSH Keys</strong></p>
<p><strong>4.2.1 首先需要检查你电脑是否已经有 SSH Keys</strong></p>
<p>在Git Bash 客户端，输入如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh</span><br><span class="line">$ ls</span><br></pre></td></tr></table></figure></p>
<p>如下说明已经存在，存在就可以忽略步骤4.2.2，直接进入步骤4.2.3</p>
<p><img src="/img/gitlab4.png" alt=""></p>
<p><strong>4.2.2 创建一个 SSH Keys</strong></p>
<p>在Git Bash 客户端，输入如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;your_email&quot;</span><br></pre></td></tr></table></figure></p>
<p>然后根据提示进行相应操作，如下图所示：</p>
<p>第一个Enter表示Keys存储的位置，默认按回车键即可。第二个和第三个Enter表示Push文件的时候要输入的密码，不需要密码就默认按回车键即可，然后出现如图底部信息就说明创建成功了！</p>
<p><img src="/img/gitlab5.png" alt=""><br><strong>4.2.3 GitLab配置SSH Keys</strong></p>
<p>进入上图所示存储 id_rsa.pub 的文件夹拷贝该文件中的内容，然后登录你的GitLab账号，点击网页右上角的头像–&gt;Settings，点击左边菜单栏的 SSH Keys 进入页面添加 SSH key。如下操作：<br><img src="/img/gitlab6.png" alt=""><br><img src="/img/gitlab7.png" alt=""></p>
<p><strong>4.3 创建项目</strong></p>
<p>在GitLab网站点击导航条上的 “+” 即可进入创建项目的页面，然后根据提示填写相应信息，如下图：<br><img src="/img/gitlab8.png" alt=""><br><img src="/img/gitlab9.png" alt=""></p>
<p>Project path：项目路径<br>Project name：项目名称<br>Project description (optional)：项目描述（可选项）<br>Visibility Level：可见登记，Private表示私有的，只有你自己或者组内的成员能访问，Internal表示所有登录的用户，Public表示公开的，所有人都可以访问。</p>
<p>创建完成后是这样的：<br><img src="/img/gitlab10.png" alt=""></p>
<h4 id="Android-Studio中使用Git"><a href="#Android-Studio中使用Git" class="headerlink" title="Android Studio中使用Git"></a>Android Studio中使用Git</h4><p><strong>5.1 将项目上传到GitLab</strong></p>
<p>本地已创建好的项目为WildmaGit</p>
<p><strong>5.1.1 配置忽略文件</strong></p>
<p>Android Studio创建项目后会自动生成.gitignore文件，这个文件可以用来忽略那些不用加入到仓库的文件。项目根目录下与module目录下都会生成该文件，如下：<br><img src="/img/gitlab11.png" alt=""><br>一般情况下我们只需要将项目根目录下的/.idea/workspace.xml与/.idea/libraries改成.idea即可，其他没有特殊要求就用默认的。如下：</p>
<p>修改前：<br><img src="/img/gitlab12.png" alt=""><br>修改后：<br><img src="/img/gitlab13.png" alt=""><br><strong>5.1.2 初始化本地Git仓库</strong></p>
<p>点击Android Studio顶部菜单栏上的VCS–&gt;Import into Version Control–&gt;Create Git Repository，如图：<br><img src="/img/gitlab14.png" alt=""><br>然后选择需要初始化的项目根目录，如图：<br><img src="/img/gitlab15.png" alt=""><br>初始化之后发现文件名由原来的白色变成了红色，这表示文件已经被git跟踪了，但是并没有添加到仓库中。如图：<br><img src="/img/gitlab16.png" alt=""><br><strong>5.1.3 将本地Git仓库已与远程仓库进行关联</strong></p>
<p>打开项目文件夹，在该文件夹中打开Git Bash。输入如下命令后就代表本地Git仓库已与远程仓库进行关联了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitlab.com:wildma/WildmaGit.git</span><br></pre></td></tr></table></figure></p>
<p>具体步骤见下图：<br><img src="/img/gitlab17.png" alt=""><br><img src="/img/gitlab18.png" alt=""><br>其中 <a href="mailto:git@gitlab.com" target="_blank" rel="noopener">git@gitlab.com</a>:wildma/WildmaGit.git 为我们项目的远程地址，可以到我们前面创建项目中复制，如下：<br><img src="/img/gitlab19.png" alt=""></p>
<p><strong>5.1.4 添加文件</strong></p>
<p>选中项目的根目录，点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Add…，如下图：<br><img src="/img/gitlab20.png" alt=""><br>添加文件后发现文件名由原来的红色变成了绿色，说明已经将文件添加进仓库了。如下图：<br><img src="/img/gitlab21.png" alt=""><br><strong>5.1.5 提交文件</strong></p>
<p>每次提交前需要先更新项目，原因是如果是多人合作的项目，需要先将远程仓库中他人提交的最新代码更新到本地仓库。如图：<br><img src="/img/gitlab22.png" alt=""><br>然后选中Merge，点击OK，如果本地代码与远程代码有冲突就会弹出冲突提示，根据需求Merge即可，如图：<br><img src="/img/gitlab23.png" alt=""></p>
<p>Update后就可以提交文件了，选中项目的根目录，点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Commit Directory…，如图：<br><img src="/img/gitlab24.png" alt=""></p>
<p>然后会弹出如下提交框，这里可以选择你要提交的文件和填写提交信息，如图：<br><img src="/img/gitlab25.png" alt=""><br>提交文件后发现文件名由原来的绿色又变成了最开始的白色，说明已经将文件提交上仓库了。如图：<br><img src="/img/gitlab26.png" alt=""></p>
<p><strong>5.1.6 将提交的文件推送到远程仓库</strong></p>
<p>选中项目的根目录，点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Push…，如下图：<br><img src="/img/gitlab27.png" alt=""><br>然后会弹出如下推送框<br><img src="/img/gitlab28.png" alt=""><br>点击Push后，就可以在GitLab上看到刚刚推送的内容了。如下图：<br><img src="/img/gitlab29.png" alt=""></p>
<p><strong>5.2 从GitLab上clone项目</strong></p>
<p>首先到GitLab上复制项目的地址，如图：<br><img src="/img/gitlab30.png" alt=""><br>然后点击Android Studio顶部菜单栏上的VCS–&gt;Checkout from Version Control–&gt;Git ，如图：<br><img src="/img/gitlab31.png" alt=""><br>最后填写相应的信息即可，如下图：</p>
<p>Git Repository URL：填写刚刚复制的项目地址<br>Parent Directory：项目路径<br>Directory Name：项目文件夹名称<br><img src="/img/gitlab32.png" alt=""><br>点击clone后，项目就clone下来了！<br><strong>5.3 分支管理</strong></p>
<p><strong>5.3.1 分支策略</strong></p>
<p>在实际开发中，我们会用到很多分支。这里说下各分支的作用。</p>
<p>master分支：最稳定的分支，保存需要发布的版本，不在该分支上做任何开发。<br>dev分支：开发分支，保存最新的代码，平时开发就在该分支上。当某个版本开发完成后就合并到master分支，然后在master分支进行版本发布。<br>bug分支：用来修复bug的分支，一般是线上版出现bug的时候，从master分支创建一个新的bug分支进行bug修复，修复完成合并到master分支和dev分支（保证master分支与dev分支同步），然后删除该bug分支。</p>
<p>实际开发中我主要用到这三个分支，当然每个人都不同，有些人还会细分到功能分支，预发分支。其中master分支与dev分支都需要推送到远程，为了其他成员能共同开发，bug分支则放在本地即可，你自己修复完bug删掉即可。</p>
<p><strong>5.3.2 分支操作</strong></p>
<p><strong>1. 创建分支</strong></p>
<p>点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Branches…，如图：<br><img src="/img/gitlab33.png" alt=""><br>然后选择New Branch，输入分支的名字，例如“dev”，如图：<br><img src="/img/gitlab34.png" alt=""><br><img src="/img/gitlab35.png" alt=""><br>点击OK，分支dev就创建成功了，并且默认切换到该分支。重复上面的步骤可以看到当前分支显示的是dev，如图：<br><img src="/img/gitlab36.png" alt=""></p>
<p><strong>2. 推送分支到远程</strong></p>
<p>这时候我们在dev分支上修改内容，然后按照前面说的提交文件（步骤5.1.5），将提交的文件推送到远程仓库（步骤5.1.6）即可。如图：<br><img src="/img/gitlab37.png" alt=""><br><img src="/img/gitlab38.png" alt=""><br>点击push，然后就可以到Gitlab上看到我们刚刚推送的dev分支了，如图：<br><img src="/img/gitlab39.png" alt=""><br><strong>3. 切换分支</strong></p>
<p>dev分支上版本V1.0开发完了，需要将代码合并到master上进行发布。因为当前在dev分支，所以需要先切换到master分支，点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Branches…，打开Git Branches窗口，然后选择本地分支栏下的master-&gt;origin/master，然后点击Checkout。如图：<br><img src="/img/gitlab40.png" alt=""><br><strong>4. 合并分支</strong></p>
<p>第三步已经将分支切换到master了，现在进行分支合并。点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Branches…，打开Git Branches窗口，然后选择远程分支栏下的origin/dev，然后点击Merge。如图：<br><img src="/img/gitlab41.png" alt=""><br>这个时候到GitLab上却发现master分支上并没有合并到dev分支修改的内容，那是因为刚刚只是将远程dev分支的内容合并到本地master分支，本地master分支还没有push到远程，push一下就可以啦~ 如图：<br><img src="/img/gitlab42.png" alt=""><br>这个时候发现GitLab上master分支与dev分支是保持一致的了。然后将最新的master分支打包发布即可！</p>
<p><strong>5. 删除分支</strong></p>
<p><strong>删除本地分支：</strong></p>
<p>点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Branches…，打开Git Branches窗口，选中本地dev分支，选择Delete即可。如图：<br><img src="/img/gitlab43.png" alt=""><br><strong>删除远程分支：</strong></p>
<p>点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Branches…，打开Git Branches窗口，选中远程dev分支，选择Delete即可。如图：<br><img src="/img/gitlab44.png" alt=""><br><strong>5.4 标签(Tag)管理</strong></p>
<p>标签一般是用于标记某个发布的版本， 例如你发布了版本v1.0，这个时候会打一个v1.0的Tag，主要是方便以后查看和管理某个版本的代码。</p>
<p><strong>1. 创建标签</strong></p>
<p>点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Tag…，如图：<br><img src="/img/gitlab45.png" alt=""><br>然后填写Tag名称与Tag信息，点击Create Tag即可创建本地标签。其中Commit可填写以前某次提交记录的id，表示在该次提交上打Tag。如果不填表示Tag打在最新提交的commit上。如图：<br><img src="/img/gitlab46.png" alt=""><br><strong>2. 推送标签到远程</strong></p>
<p>点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Push…，如图：<br><img src="/img/gitlab47.png" alt=""><br>然后弹出Push框，选中Push Tags，点击Push即可推送到远程。如图：<br><img src="/img/gitlab48.png" alt=""><br>最后到GitLab就可以看到刚刚创建的Tag了，如图：<br><img src="/img/gitlab49.png" alt=""><br><strong>3. checkout某个标签的代码</strong></p>
<p>点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Branches…，如图：<br><img src="/img/gitlab50.png" alt=""><br>然后选择Checkout Tag or Revision…，最后在弹出的Checkout框中填入Tag的名称即可。如图：<br><img src="/img/gitlab51.png" alt=""><br><img src="/img/gitlab52.png" alt=""></p>
<p><strong>4. 删除标签</strong></p>
<p>在Android Studio中没找到删除Tag的操作，所以这里用Git命令。（有发现的小伙伴可以告诉我）</p>
<p><strong>查看本地标签：</strong><br>git tag</p>
<p><strong>删除本地标签：</strong><br>git tag -d tagName</p>
<p><strong>删除远程标签：</strong><br>git push origin :refs/tags/tagName</p>
<p>以上命令需要在Android Studio自带的命令行中输入，如图：<br><img src="/img/gitlab53.png" alt=""><br>希望这种图文结合的方式大家都能看懂吧！写的不好的地方请多交流~</p>
<p>项目地址：<br><a href="https://gitlab.com/wildma/WildmaGit" target="_blank" rel="noopener">https://gitlab.com/wildma/WildmaGit</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="Qgx" />
            
              <p class="site-author-name" itemprop="name">Qgx</p>
              <p class="site-description motion-element" itemprop="description">漫漫长路，伴你同行</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">79</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">53</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/qin12" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:1520290900@qq.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=1520290900&website=www.oicqzone.com" target="_blank" title="QQ"><i class="fa fa-fw fa-QQ"></i>QQ</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Qgx</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Mist</a> v6.2.0</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.2.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.2.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.2.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
