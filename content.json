{"meta":{"title":"qin12的学习博客","subtitle":"只为成功找方法，不为失败找借口！","description":"漫漫长路，伴你同行","author":"Qgx","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-07-20T09:06:05.000Z","updated":"2018-07-20T09:06:05.452Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-05-11T07:08:58.000Z","updated":"2018-07-20T04:10:37.829Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"music","date":"2018-05-11T00:49:44.000Z","updated":"2018-07-20T04:10:37.829Z","comments":true,"path":"music/index.html","permalink":"http://yoursite.com/music/index.html","excerpt":"","text":""},{"title":"photo","date":"2018-05-11T00:49:59.000Z","updated":"2018-07-20T04:10:37.829Z","comments":true,"path":"photo/index.html","permalink":"http://yoursite.com/photo/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-11T07:08:32.000Z","updated":"2018-07-20T04:10:37.829Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring核心机制：依赖注入/控制反转","slug":"Spring核心机制：依赖注入_控制反转","date":"2018-07-26T14:57:28.018Z","updated":"2018-07-26T14:57:28.018Z","comments":true,"path":"2018/07/26/Spring核心机制：依赖注入_控制反转/","link":"","permalink":"http://yoursite.com/2018/07/26/Spring核心机制：依赖注入_控制反转/","excerpt":"","text":"Spring核心机制：依赖注入/控制反转初涉依赖注入 对于spring而言，将自己置身于spring的立场上去看，当调用方需要某一个类的时候我就为你提供这个类的实例，就是说spring负责将被依赖的这个对象赋值给调用方，那么就相当于我为调用方注入了这样的一个实例。从这方面来看是依赖注入。 浅谈控制反转（Inversion of Control，IOC） 我们首先先来了解一下控制二字，也就是在控制“正”转的情况下，在任何一个有请求作用的系统当中，至少需要有两个类互相配合工作，在一个入口类下使用new关键字创建另一个类的对象实例，这就好比在面向对象编程的思想下，“我“充当一个入口类，在这个入口类中，我每次吃饭的时候都要买一双一次性筷子（每一次使用都要new一次），在这样的关系下，是”我“（即调用者）每次都要”主动“去买一次性筷子（另一个类），我对筷子说你老老实实的过来我的手上，是我控制了筷子，那好，在这种控制正转的关系下，放在现实生活当中，肯定是不现实的，而且人是懒惰的，他总会去创造出更加方便自己生活的想法，更确切的做法是，买一双普通的筷子（非一次性），把他放在一个容器当中（在Spring中叫做IOC容器），你需要使用的时候就对容器说：IOC我想要用筷子（向容器发出请求），接着筷子就会”注入“到的手上，而在这个过程当中，你不再是控制方，反而演变成一名请求者（虽然本身还是调用者），依赖于容器给予你资源，控制权坐落到了容器身上，于是这就是人们俗称的控制反转。 依赖注入两种方式1.设值注入设值注入:通过set的方式注入值.Ioc容器通过成员变量的setter方法来注入被依赖的对象，这种注入方式简单，直观，因而在spring中大量的使用。下面我们采用实际的例子来体会一下：假设这样的一个场景，我想打印消息，这样一件事情首先定义一个MessageService的接口。123456789package com.qgx.spring;public interface MessageService &#123; /** * 消息打印 */ public void printMessage();&#125; 然后实现这个接口，并实现这个方法。12345678package com.qgx.spring;public class MessagePrinter implements MessageService &#123; @Override public void printMessage() &#123; System.out.println(&quot;输出消息&quot;); &#125;&#125; 定义一个person的接口123456789package com.qgx.spring;public interface Person &#123; /** * 人发送消息 */ public void sendMessage();&#125; 我来实现人这个接口12345678910111213141516171819package com.qgx.spring;public class Qin12 implements Person &#123; private MessageService service; public MessageService getService() &#123; return service; &#125; public void setService(MessageService service) &#123; this.service = service; &#125; @Override public void sendMessage() &#123; service.printMessage(); &#125;&#125; Spring的配置文件：123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;bean id=&quot;messageService&quot; class=&quot;com.qgx.spring.MessagePrinter&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;qin12&quot; class=&quot;com.qgx.spring.Qin12&quot;&gt; &lt;property name=&quot;service&quot; ref=&quot;messageService&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt; 测试类如下:123456789101112package com.qgx.spring;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); Person person = context.getBean(&quot;qin12&quot;,Person.class); person.sendMessage(); &#125;&#125; 2.构造注入 通过构造函数的方式注入。spring以反射的方式执行带指定参数的构造器，当执行带参数的构造器时就可以通过构造器的参数赋值给成员变量，完成构造注入。那么现在需求变了，我需要改一些东西，下面可以注意下我主要改动了哪里：在Qin12这个类中添加有参数和无参数的构造函数：1234567891011121314151617181920212223242526package com.qgx.spring;public class Qin12 implements Person &#123; private MessageService service; public Qin12(MessageService service) &#123; this.service = service; &#125; public Qin12() &#123; &#125; public MessageService getService() &#123; return service; &#125; public void setService(MessageService service) &#123; this.service = service; &#125; @Override public void sendMessage() &#123; service.printMessage(); &#125;&#125; 在Spring配置文件中，稍微改动，即将原来的设值注入换为构造注入即可。1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;bean id=&quot;messageService&quot; class=&quot;com.qgx.spring.MessagePrinter&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;qin12&quot; class=&quot;com.qgx.spring.Qin12&quot;&gt; &lt;!--&lt;property name=&quot;service&quot; ref=&quot;messageService&quot;&gt;&lt;/property&gt;--&gt; &lt;!-- 构造注入 --&gt; &lt;constructor-arg ref=&quot;messageService&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;/beans&gt; 设值注入和构造注入的对比这两种方式，效果是一样的，注入的时机不同，设值注入是先调用无参的构造函数，创建出实例后然后调用set方法注入属性值。而构造输入是通过在调用构造函数初始化实例的同时完成了注入。 设值注入的优点 通过set的方式设定依赖关系显得更加直观，自然，和javabean写法类似。 复杂的依赖关系，采用构造注入会造成构造器过于臃肿，spring 实例化的时候同时实例化其依赖的全部实例，导致性能下降，set方式可以避免这些问题。 在成员变量可选的情况下，构造注入不够灵活。 构造注入的优点 某些特定的情况下，构造注入比设值注入好一些。 构造注入可以在构造器中决定依赖关系的注入顺序，优先依赖的优先注入，构造注入可以清楚的分清注入的顺序。 组件的调用者无需知道组件内部的依赖关系，符合高内聚原则。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"依赖注入/控制反转","slug":"依赖注入-控制反转","permalink":"http://yoursite.com/tags/依赖注入-控制反转/"}]},{"title":"Sping 简介","slug":"Sping 简介","date":"2018-07-26T14:48:32.054Z","updated":"2018-07-26T14:48:32.054Z","comments":true,"path":"2018/07/26/Sping 简介/","link":"","permalink":"http://yoursite.com/2018/07/26/Sping 简介/","excerpt":"","text":"Sping 简介1、什么是Spring框架？Spring是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架，从控制反转和面向切面这两个方面去了解，容器是用来盛放物品的装备，而Spring就是实现这一功能的。在开发过程当中把所需要的对象配置到Spring框架当中去，由它进行控制，由此就出现了控制反转和面向切面。控制反转就是把一个对象的生成权交给第三方，也就是Spring去完成，那么这就是定向反转。一般在应用程序当中，需要生产的对象的这一权力来转让给Spring，在应用的过程当中，到Spring里面去查找，由Spring来进行控制对象的生产。在这样的生产中，有这样一个好处，就是说什么时候生产这样的对象，或者说这个对象怎么去维护，这就是Spring去管理，而不是要我们程序当中过多的考虑这个问题，这样就减少了程序的吻合度。除此之外，Spring要使用一个轻量级控制反转这个对象必须要有一个类存在，在这个过程中就叫依赖注入，我们把所需要的对象注册到Spring容器当中去，让Spring能够找到它，然后去生产它，这种方式就叫做依赖注入。面向切面的编程，大家在开发的过程中会遇到一些这样的操作，比如要进行增删改的操作，要验证你的身份，要验证你的权限，而这些方法基本上是一样的。一般的方法抽取出来配置到Spring当中去，让它以切面的这种方式去执行，这样的方式就是面向切面的程序设计。 2、为什么要使用Spring？Spring主要两个有功能为我们的业务对象管理提供了非常便捷的方法： DI（Dependency Injection，依赖注入）(IoC) AOP（Aspect Oriented Programming，面向切面编程） Java Bean规范 必须是个公有(public)类 有无参构造函数 用公共方法暴露内部成员属性(getter,setter) 实现这样规范的类，被称为Java Bean。即是一种可重用的组件。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring简介","slug":"Spring简介","permalink":"http://yoursite.com/tags/Spring简介/"}]},{"title":"linux下搭建hexo个人博客","slug":"Linux 搭建hexo个人博客","date":"2018-07-20T10:01:16.700Z","updated":"2018-07-20T10:01:16.700Z","comments":true,"path":"2018/07/20/Linux 搭建hexo个人博客/","link":"","permalink":"http://yoursite.com/2018/07/20/Linux 搭建hexo个人博客/","excerpt":"","text":"Linux 搭建hexo个人博客安装需要的软件git1sudo apt-get install git node.js1sudo apt-get install nodejs npm1sudo apt-get install npm 检查是否安装成功1node -v 1npm -v hexo1sudo npm install -g hexo-cli 将node,npm命令设置全局命令： 将hexo-cli/bin/文件夹下的hexo命令设置为全局：123sudo ln -s /usr/bin/nodesudo ln -s /usr/bin/npmhexo /usr/local/bin/hexo 创建hexo文件夹123456sudo mkdir hexocd hexosudo mkdir hexocd hexohexo initsudo npm install 开启服务1sudo hexo server -p 5000","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux;hexo","slug":"linux-hexo","permalink":"http://yoursite.com/tags/linux-hexo/"}]},{"title":"我的第一个Android设计第三天","slug":"Fragment  的嵌套使用","date":"2018-07-20T09:41:52.732Z","updated":"2018-07-20T09:41:52.732Z","comments":true,"path":"2018/07/20/Fragment  的嵌套使用/","link":"","permalink":"http://yoursite.com/2018/07/20/Fragment  的嵌套使用/","excerpt":"","text":"Fragment 的嵌套使用Fragment管理类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.example.qgx.androidkeshe.Fragement;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentTransaction;import java.util.List;/** * * Created by qgx on 2018/6/22. */public class FragmentManagerHelper &#123; private FragmentManager mFragmentManager; private int mContainerViewId; /** * * @param mFragmentManager 管理类 * @param mContainerViewId 容器布局的id */ public FragmentManagerHelper(FragmentManager mFragmentManager, int mContainerViewId) &#123; this.mFragmentManager = mFragmentManager; this.mContainerViewId = mContainerViewId; &#125; /** * 添加fragment * @param fragment */ public void add(Fragment fragment)&#123; FragmentTransaction fragmentTransaction = mFragmentManager.beginTransaction(); fragmentTransaction.add(mContainerViewId,fragment); fragmentTransaction.commit(); &#125; /** * 切换显示fragment * @param fragment */ public void switchFragmnet(Fragment fragment) &#123; FragmentTransaction fragmentTransaction = mFragmentManager.beginTransaction(); List&lt;Fragment&gt; childFragments = mFragmentManager.getFragments(); for (Fragment childFragment : childFragments) &#123; fragmentTransaction.hide(childFragment); &#125; if (!childFragments.contains(fragment)) &#123; fragmentTransaction.add(mContainerViewId, fragment); &#125; else &#123; fragmentTransaction.show(fragment); &#125; fragmentTransaction.commit(); &#125; &#125; 是重写Fragment的setUserVisibleHint（）方法，实现Fragment内部的懒加载机制。懒加载FragmentlazyLoadFragment.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.example.qgx.androidkeshe.Fragement;import android.os.Bundle;import android.support.annotation.Nullable;import android.support.v4.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;/** * Created by qgx on 2018/6/22. */public abstract class LazyLoadFragment extends Fragment &#123; /** * 视图是否已经初初始化 */ protected boolean isInit = false; protected boolean isLoad = false; protected final String TAG = &quot;LazyLoadFragment&quot;; private View view; /** * 设置Fragment要显示的布局 * * @return 布局的layoutId */ protected abstract int setContentView(); public abstract void initView(); public abstract void setListener(); public abstract void initData(); /** * 获取设置的布局 * * @return */ protected View getContentView() &#123; return view; &#125; /** * 找出对应的控件 * * @param id * @param &lt;T&gt; * @return */ protected &lt;T extends View&gt; T findViewById(int id) &#123; return (T) getContentView().findViewById(id); &#125; /** * 当视图初始化并且对用户可见的时候去真正的加载数据 */ protected abstract void lazyLoad(); /** * 当视图已经对用户不可见并且加载过数据，如果需要在切换到其他页面时停止加载数据，可以调用此方法 */ protected void stopLoad() &#123; &#125; /** * 视图销毁的时候讲Fragment是否初始化的状态变为false */ @Override public void onDestroyView() &#123; super.onDestroyView(); isInit = false; isLoad = false; &#125; /** * 是否可以加载数据 * 可以加载数据的条件： * 1.视图已经初始化 * 2.视图对用户可见 */ private void isCanLoadData() &#123; if (!isInit) &#123; return; &#125; if (getUserVisibleHint()) &#123; lazyLoad(); isLoad = true; &#125; else &#123; if (isLoad) &#123; stopLoad(); &#125; &#125; &#125; /** * 视图是否已经对用户可见，系统的方法 */ @Override public void setUserVisibleHint(boolean isVisibleToUser) &#123; super.setUserVisibleHint(isVisibleToUser); isCanLoadData(); &#125; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; view = inflater.inflate(setContentView(), container, false); initView(); initData(); setListener(); isInit = true; /**初始化的时候去加载数据**/ isCanLoadData(); return view; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android 课设","slug":"Android-课设","permalink":"http://yoursite.com/tags/Android-课设/"}]},{"title":"推荐一些有意思的东西","slug":"3dTagCloudAndroid","date":"2018-07-20T04:10:37.825Z","updated":"2018-07-20T04:10:37.825Z","comments":true,"path":"2018/07/20/3dTagCloudAndroid/","link":"","permalink":"http://yoursite.com/2018/07/20/3dTagCloudAndroid/","excerpt":"","text":"3dTagCloudAndroid介绍：TagCloudView是一个完全基于Android ViewGroup编写的控件，支持将一组View展示为一个3D球形集合，并支持全方向滚动。 运行效果： 使用说明：Android Studio / IDEA 在build.gradle中添加1compile &apos;com.moxun:tagcloudlib:1.0.3&apos; 在布局文件中引入1&lt;com.moxun.tagcloudlib.view.TagCloudView/&gt; 设置Adapter 继承TagsAdapter，实现以下方法 public int getCount();返回Tag数量public View getView(Context context, int position, ViewGroup parent);返回每个Tag实例public Object getItem(int position);返回Tag数据public int getPopularity(int position);针对每个Tag返回一个权重值，该值与ThemeColor和Tag初始大小有关public void onThemeColorChanged(View view,int themeColor);Tag主题色发生变化时会回调该方法 定制属性 属性 xml 代码 值类型 自动滚动 app:autoScrollMode setAutoScrollMode(int mode) [disable,uniform,decelerate] 半径百分比 app:radiusPercent setRadiusPercent(float percent) float [0,1] 滚动速度 app:scrollSpeed setScrollSpeed(float scrollSpeed) float [0,+] 起始颜色 app:lightColor setLightColor(int color) int 终止颜色 app:darkColor setDarkColor(int color) int 轻松调试数据库日常开发中一个非常痛苦的事情，就是在需要操作数据库的项目中，需要不断的调试数据库，很多时候我们选择是导出数据库，然后使用Sqlite 可视化软件打开打开。 高端一点的使用sqlite3，然后通过命令行操作。 当然了还有个比较强大好用的工具是：facebook 的stetho。 不过我今天推荐的是另一个项目： https://github.com/amitshekhariitbhu/Android-Debug-Database 怎么用呢？ 在我们的项目对应的module 中添加一行：123dependencies &#123;debugImplementation &apos;com.amitshekhar.android:debug-db:1.0.4&apos;&#125; 然后直接运行包含数据库的项目，在手机安装成功后，在浏览器访问： 你手机的 IP：8080 你就可以看到如下界面：在这里，你可以执行sql 语句，查看任何表数据，甚至可以新增、修改、删除数据。所有的操作都是直接反馈到数据库的。 此外还支持 SharedPref的直接查看与修改~ 是不是非常简单！ 项目支持更换端口，从多年的编程经验来看，建议设置一个别的端口号，一开始默认8080端口我就遇到了问题。12345buildTypes &#123;debug &#123;resValue(&quot;string&quot;, &quot;PORT_NUMBER&quot;, &quot;9999&quot;)&#125;&#125; 注意，手机需要和 PC 在同一个网段；usb 连接也可以，自行参考 readme即可。","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"http://yoursite.com/categories/杂七杂八/"}],"tags":[{"name":"有意思","slug":"有意思","permalink":"http://yoursite.com/tags/有意思/"}]},{"title":"springboot","slug":"Tomcat 部署项目的三种方法","date":"2018-07-20T04:10:37.825Z","updated":"2018-07-20T04:10:37.825Z","comments":true,"path":"2018/07/20/Tomcat 部署项目的三种方法/","link":"","permalink":"http://yoursite.com/2018/07/20/Tomcat 部署项目的三种方法/","excerpt":"","text":"Tomcat 部署项目的三种方法作者：YSOcean链接：cnblogs.com/ysocean/p/6893446.html 1、下载 Tomcat 服务器官网下载地址：http://tomcat.apache.org/ 2、启动并部署 Tomcat 服务器①、解压 tomcat 安装包到一个非中文目录下②、配置环境变量。JAVA_HOME(指向 JDK 安装的根目录)③、双击 apache-tomcat-6.0.16\\bin 目录下的 startup.bat，启动服务器(如果一闪而过，那就是没有配置 JAVA_HOME 的环境变量)④、在浏览器中输入 http://localhost:8080 注意：Tomcat 启动不了的时候注意配置 JAVA_HOME:C:\\Program Files\\Java\\jdk1.6.0_43这是安装 JDK的根目录 3、Tomcat 的目录结构 4、部署项目的第一种方法（项目直接放入 webapps 目录中）1、将编写并编译好的web项目(注意要是编译好的，如果是 eclipse，可以将项目打成 war 包放入)，放入到 webapps 中2、启动tomcat服务器（双击 apache-tomcat-6.0.16\\bin 目录下的 startup.bat，启动服务器）3、在浏览器输入：http://localhost:8080/项目名/访问的文件名 5、部署项目的第二种方法（修改 conf/server.xml 文件 ）①、打开tomcat下conf/server.xml，在 标签之间输入项目配置信息1&lt;Context path=&quot;/WebProject&quot; docBase=&quot;D:/WebProject&quot; reloadable=&quot;true&quot; /&gt; path: 浏览器访问时的路径名docBase: web项目的WebRoot所在的路径，注意是WebRoot的路径，不是项目的路径。其实也就是编译后的项目reloadble: 设定项目有改动时，tomcat是否重新加载该项目②、双击 startup.bat，启动 tomcat 服务器，然后在浏览器输入访问的项目名称路径、注意：如果你配置的 path=”/xx”,那么访问的时候就是这样： 6、部署项目的第三种方法（apache-tomcat-7.0.52\\conf\\Catalina\\localhost ）①、进入到 apache-tomcat-7.0.52\\conf\\Catalina\\localhost 目录，新建一个 项目名.xml 文件②、在 那个新建的 xml 文件中，增加下面配置语句（和上面的是一样的,但是不需要 path 配置，加上也没什么用）1&lt;Context docBase=&quot;D:/WebProject&quot; reloadable=&quot;true&quot; /&gt; ③、在浏览器输入路径：localhost:8080/xml文件名/访问的文件名总结：①、第一种方法比较普通，但是我们需要将编译好的项目重新 copy 到 webapps 目录下，多出了两步操作。 ②、第二种方法直接在 server.xml 文件中配置，但是从 tomcat5.0版本开始后，server.xml 文件作为 tomcat 启动的主要配置文件，一旦 tomcat 启动后，便不会再读取这个文件，因此无法再 tomcat 服务启动后发布 web 项目。 ③、第三种方法是最好的，每个项目分开配置，tomcat 将以\\conf\\Catalina\\localhost 目录下的 xml 文件的文件名作为 web 应用的上下文路径，而不再理会 中配置的 path 路径，因此在配置的时候，可以不写 path。 通常我们使用第三种方法.","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://yoursite.com/categories/javaEE/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"}]},{"title":"多线程编程","slug":"Android 多线程编程","date":"2018-07-20T04:10:37.825Z","updated":"2018-07-20T04:10:37.821Z","comments":true,"path":"2018/07/20/Android 多线程编程/","link":"","permalink":"http://yoursite.com/2018/07/20/Android 多线程编程/","excerpt":"","text":"Android 多线程编程一、线程的基本用法方法一、新建一个类继承自 Thread，然后重写父类的 run() 方法。123456class MyThread extends Thread &#123; @Override public void run() &#123; // 处理具体的逻辑 &#125;&#125; 启动：1new MyThread().start(); 方法二、使用继承的方式耦合性有点高，更多的时候会选择使用实现 Runnable 接口的方式来定义一个线程。123456class MyThread implements Runnable &#123; @Override public void run() &#123; // 处理具体的逻辑 &#125;&#125; 启动：12MyThread myThread = new MyThread();new Thread(myThread).start(); 方法三、或使用匿名类的方式，这种写法更为常见。123456new Thread(new Runnable() &#123; @Override public void run() &#123; // 处理具体的逻辑 &#125;&#125;).start(); 二、异步消息处理机制Android 的 UI 是线程不安全的。如果想要更新应用程序里的 UI 元素，则必须在主线程中进行，否则就会出现异常。可以使用 异步消息处理机制。123456789101112131415161718192021222324252627282930313233343536public class MainActivity extends Activity implements OnClickListener &#123; public static final int UPDATE_TEXT = 1; private TextView text; private Button changeText; private Handler handler = new Handler() &#123; public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case UPDATE_TEXT: // 在这里可以进行UI操作 text.setText(&quot;Nice to meet you&quot;); break; default: break; &#125; &#125; &#125;;...... @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.change_text: new Thread(new Runnable() &#123; @Override public void run() &#123; Message message = new Message(); message.what = UPDATE_TEXT; handler.sendMessage(message); // 将Message对象发送出去 &#125; &#125;).start(); break; default: break; &#125; &#125;&#125; 1. MessageMessage 是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间交换数据。上一小节中我们使用到了 Message 的 what 字段，除此之外还可以使用 arg1 和 arg2 字段来携带一些整型数据，使用 obj 字段携带一个 Object 对象。 2. HandlerHandler 顾名思义也就是处理者的意思，它主要是用于发送和处理消息的。发送消息一般是使用 Handler 的 sendMessage() 方法，而发出的消息经过一系列地辗转处理后，最终会传递到 Handler 的 handleMessage() 方法中。 3. MessageQueueMessageQueue 是消息队列的意思，它主要用于存放所有通过 Handler 发送的消息。这部分消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个 MessageQueue 对象。 4. LooperLooper 是每个线程中的 MessageQueue 的管家，调用 Looper 的 loop() 方法后，就会进入到一个无限循环当中，然后每当发现 MessageQueue 中存在一条消息，就会将它取出，并传递到 Handler 的 handleMessage() 方法中。每个线程中也只会有一个 Looper 对象。 三、使用 AsyncTask不过为了更加方便我们在子线程中对 UI 进行操作，Android 还提供了另外一些好用的工具，AsyncTask 就是其中之一。借助 AsyncTask，即使你对异步消息处理机制完全不了解，也可以十分简单地从子线程切换到主线程。当然，AsyncTask 背后的实现原理也是基于异步消息处理机制的，只是 Android 帮我们做了很好的封装而已。由于AsyncTask 是一个抽象类，所以如果我们想使用它，就必须要创建一个子类去继承它。在继承时我们可以为 AsyncTask 类指定三个泛型参数，这三个参数的用途如下：Params在执行 AsyncTask 时需要传入的参数，可用于在后台任务中使用。Progress后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。Result当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。因此，一个最简单的自定义 AsyncTask 就可以写成如下方式：123class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123;......&#125; 经常需要去重写的方法有以下四个： onPreExecute()这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等。 doInBackground(Params…)这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成就可以通过 return 语句来将任务的执行结果返回，如果 AsyncTask 的第三个泛型参数指定的是 Void，就可以不返回任务执行结果。注意，在这个方法中是不可以进行 UI 操作的，如果需要更新 UI 元素，比如说反馈当前任务的执行进度，可以调用 publishProgress(Progress…) 方法来完成。 #####onProgressUpdate(Progress…)当在后台任务中调用了 publishProgress(Progress…)方法后，这个方法就会很快被调用，方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对 UI 进行操作，利用参数中的数值就可以对界面元素进行相应地更新。 onPostExecute(Result)当后台任务执行完毕并通过 return 语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些 UI 操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等。因此，一个比较完整的自定义 AsyncTask 就可以写成如下方式：123456789101112131415161718192021222324252627282930313233343536373839class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123; @Override protected void onPreExecute() &#123; progressDialog.show(); // 显示进度对话框 &#125; @Override protected Boolean doInBackground(Void... params) &#123; try &#123; while (true) &#123; int downloadPercent = doDownload(); // 这是一个虚构的方法 publishProgress(downloadPercent); if (downloadPercent &gt;= 100) &#123; break; &#125; &#125; &#125; catch (Exception e) &#123; return false; &#125; return true; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; // 在这里更新下载进度 progressDialog.setMessage(&quot;Downloaded &quot; + values[0] + &quot;%&quot;); &#125; @Override protected void onPostExecute(Boolean result) &#123; progressDialog.dismiss(); // 关闭进度对话框 // 在这里提示下载结果 if (result) &#123; Toast.makeText(context, &quot;Download succeeded&quot;, Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(context, &quot; Download failed&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 启动：1new DownloadTask().execute(); 在这个 DownloadTask 中，我们在 doInBackground() 方法里去执行具体的下载任务。这个方法里的代码都是在子线程中运行的，因而不会影响到主线程的运行。注意这里虚构了一个 doDownload() 方法，这个方法用于计算当前的下载进度并返回，我们假设这个方法已经存在了。在得到了当前的下载进度后， 下面就该考虑如何把它显示到界面上了， 由于 doInBackground() 方法是在子线程中运行的，在这里肯定不能进行 UI 操作，所以我们可以调用 publishProgress() 方法并将当前的下载进度传进来，这样 onProgressUpdate() 方法就会很快被调用，在这里就可以进行UI 操作了。当下载完成后，doInBackground() 方法会返回一个布尔型变量，这样 onPostExecute() 方法就会很快被调用，这个方法也是在主线程中运行的。然后在这里我们会根据下载的结果来弹出相应的 Toast 提示，从而完成整个 DownloadTask 任务。简单来说，使用 AsyncTask 的诀窍就是，在 doInBackground() 方法中去执行具体的耗时任务，在 onProgressUpdate() 方法中进行 UI 操作，在 onPostExecute() 方法中执行一些任务的收尾工作。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android 多线程编程","slug":"Android-多线程编程","permalink":"http://yoursite.com/tags/Android-多线程编程/"}]},{"title":"Spring Boot(五)","slug":"Spring Boot构建RESTful API与单元测试","date":"2018-07-20T04:10:37.825Z","updated":"2018-07-20T04:10:37.825Z","comments":true,"path":"2018/07/20/Spring Boot构建RESTful API与单元测试/","link":"","permalink":"http://yoursite.com/2018/07/20/Spring Boot构建RESTful API与单元测试/","excerpt":"","text":"Spring Boot构建RESTful API与单元测试 @Controller：修饰class，用来创建处理http请求的对象 @RestController：Spring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@ResponseBody，默认返回json格式。 @RequestMapping：配置url映射下面我们尝试使用Spring MVC来实现一组对User对象操作的RESTful API，配合注释详细说明在Spring MVC中如何映射HTTP请求、如何传参、如何编写单元测试。 RESTful API具体设计如下：User实体定义：123456789public class User &#123; private Long id; private String name; private Integer age; // 省略setter和getter &#125; 实现对User对象的操作接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@RestController @RequestMapping(value=&quot;/users&quot;) // 通过这里配置使下面的映射都在/users下 public class UserController &#123; // 创建线程安全的Map static Map&lt;Long, User&gt; users = Collections.synchronizedMap(new HashMap&lt;Long, User&gt;()); @RequestMapping(value=&quot;/&quot;, method=RequestMethod.GET) public List&lt;User&gt; getUserList() &#123; // 处理&quot;/users/&quot;的GET请求，用来获取用户列表 // 还可以通过@RequestParam从页面中传递参数来进行查询条件或者翻页信息的传递 List&lt;User&gt; r = new ArrayList&lt;User&gt;(users.values()); return r; &#125; @RequestMapping(value=&quot;/&quot;, method=RequestMethod.POST) public String postUser(@ModelAttribute User user) &#123; // 处理&quot;/users/&quot;的POST请求，用来创建User // 除了@ModelAttribute绑定参数之外，还可以通过@RequestParam从页面中传递参数 users.put(user.getId(), user); return &quot;success&quot;; &#125; @RequestMapping(value=&quot;/&#123;id&#125;&quot;, method=RequestMethod.GET) public User getUser(@PathVariable Long id) &#123; // 处理&quot;/users/&#123;id&#125;&quot;的GET请求，用来获取url中id值的User信息 // url中的id可通过@PathVariable绑定到函数的参数中 return users.get(id); &#125; @RequestMapping(value=&quot;/&#123;id&#125;&quot;, method=RequestMethod.PUT) public String putUser(@PathVariable Long id, @ModelAttribute User user) &#123; // 处理&quot;/users/&#123;id&#125;&quot;的PUT请求，用来更新User信息 User u = users.get(id); u.setName(user.getName()); u.setAge(user.getAge()); users.put(id, u); return &quot;success&quot;; &#125; @RequestMapping(value=&quot;/&#123;id&#125;&quot;, method=RequestMethod.DELETE) public String deleteUser(@PathVariable Long id) &#123; // 处理&quot;/users/&#123;id&#125;&quot;的DELETE请求，用来删除User users.remove(id); return &quot;success&quot;; &#125; &#125; 下面针对该Controller编写测试用例验证正确性，具体如下。当然也可以通过浏览器插件等进行请求提交验证。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@RunWith(SpringJUnit4ClassRunner.class) @SpringApplicationConfiguration(classes = MockServletContext.class) @WebAppConfiguration public class ApplicationTests &#123; private MockMvc mvc; @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.standaloneSetup(new UserController()).build(); &#125; @Test public void testUserController() throws Exception &#123; // 测试UserController RequestBuilder request = null; // 1、get查一下user列表，应该为空 request = get(&quot;/users/&quot;); mvc.perform(request) .andExpect(status().isOk()) .andExpect(content().string(equalTo(&quot;[]&quot;))); // 2、post提交一个user request = post(&quot;/users/&quot;) .param(&quot;id&quot;, &quot;1&quot;) .param(&quot;name&quot;, &quot;测试大师&quot;) .param(&quot;age&quot;, &quot;20&quot;); mvc.perform(request) .andExpect(content().string(equalTo(&quot;success&quot;))); // 3、get获取user列表，应该有刚才插入的数据 request = get(&quot;/users/&quot;); mvc.perform(request) .andExpect(status().isOk()) .andExpect(content().string(equalTo(&quot;[&#123;\\&quot;id\\&quot;:1,\\&quot;name\\&quot;:\\&quot;测试大师\\&quot;,\\&quot;age\\&quot;:20&#125;]&quot;))); // 4、put修改id为1的user request = put(&quot;/users/1&quot;) .param(&quot;name&quot;, &quot;测试终极大师&quot;) .param(&quot;age&quot;, &quot;30&quot;); mvc.perform(request) .andExpect(content().string(equalTo(&quot;success&quot;))); // 5、get一个id为1的user request = get(&quot;/users/1&quot;); mvc.perform(request) .andExpect(content().string(equalTo(&quot;&#123;\\&quot;id\\&quot;:1,\\&quot;name\\&quot;:\\&quot;测试终极大师\\&quot;,\\&quot;age\\&quot;:30&#125;&quot;))); // 6、del删除id为1的user request = delete(&quot;/users/1&quot;); mvc.perform(request) .andExpect(content().string(equalTo(&quot;success&quot;))); // 7、get查一下user列表，应该为空 request = get(&quot;/users/&quot;); mvc.perform(request) .andExpect(status().isOk()) .andExpect(content().string(equalTo(&quot;[]&quot;))); &#125; &#125; 至此，我们通过引入web模块（没有做其他的任何配置），就可以轻松利用Spring MVC的功能，以非常简洁的代码完成了对User对象的RESTful API的创建以及单元测试的编写。其中同时介绍了Spring MVC中最为常用的几个核心注解：@Controller,@RestController,RequestMapping以及一些参数绑定的注解：@PathVariable,@ModelAttribute,@RequestParam等。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"Spring Boot构建RESTful API与单元测试","slug":"Spring-Boot构建RESTful-API与单元测试","permalink":"http://yoursite.com/tags/Spring-Boot构建RESTful-API与单元测试/"}]},{"title":"重识OkHttp","slug":"OkHttp：从深入了解到源码分析","date":"2018-07-20T04:10:37.825Z","updated":"2018-07-20T04:10:37.825Z","comments":true,"path":"2018/07/20/OkHttp：从深入了解到源码分析/","link":"","permalink":"http://yoursite.com/2018/07/20/OkHttp：从深入了解到源码分析/","excerpt":"","text":"OkHttp：从深入了解到源码分析作者博客：http://www.jianshu.com/u/16925b46816d 前言本文的分析基于OkHttp3.4，不展示完整的代码示例，具体可以看这个官方例子或者项目中的例子。https://github.com/square/okhttp/wiki/RecipesOkHttp作为square公司出品的一个网络请求框架，应该算是目前Android端最火爆的网络框架了。我公司目前的项目中采用的都是Rxjava结合Retrofit进行网络请求的处理，对于底层真正实现网络请求的OkHttp关注的不是很多。最近探究了一下OkHttp的源码，对OkHttp的使用有了一些新的认识，在此做一下总结。 ###目录 使用篇 OkHttp的优点 网络处理3要素1 请求Request - 1、表单FormBody - 2、分块MultipartBody - 3、客户端OkHttpClient 2、同步请求和异步请求3、其他 配置响应缓存 取消请求 Response读取响应结果4、总结分析篇 客户端完整的请求 探究源码 Call的实现类RealCall RealCall的enqueue( Callback callBack) Dispatcher的enqueue getResponseWithInterceptorChain() 同步请求 总结 使用篇1.OkHttp的优点OkHttp作为当前Android端最火热的网络请求框架，必然有很多的优点。 支持HTTP / 2协议，允许连接到同一个主机地址的所有请求共享Socket。这必然会提高请求效率。在HTTP / 2协议不可用的情况下，通过连接池减少请求的延迟。GZip透明压缩减少传输的数据包大小。响应缓存，避免同一个重复的网络请求。 2.网络处理3要素对于客户端来讲，我们关注的就是把正确的请求发送到服务端并拿到结果来进行处理。在OkHttp中，我认为可以分为3个部分： 请求类封装客户端发送的请求，包括请求的url，请求方法（主要是GET和POST方法），请求头标题以及请求体requestBody; 响应类封装了服务器响应的数据，包括代码，消息，主体，头等。OkHttpClient负责发送请求请求并通过同步或者异步的方式返回服务器的响应响应，就好比是一个浏览器。 OkHttp中通过建造者模式来构建OkHttpClient，请求和响应对于客户端来讲，我们不需要过多关注响应是如何构建的，因为这个是OkHttp对响应结果进行了封装处理。我们只关注请求请求和客户端OkHttpClient如何构建即可。 2.1请求Request请求采用建模者模式来配置url，请求方法method，header，tag和cacheControl。 设置url。可以是String类型，URL类型和HttpUrl类型。最终都是用到HttpUrl类型。设置方法，包含get，post方法等。默认的是get方法.post方法要传RequestBody，类似的还有delete，put，patch。设置头，方法有addHeader（String name，String value），removeHeader（String name），header（String name，String value），headers（Headers headers）.headers（Headers headers）调用之后其它的头都会被移除，只添加这一个标题。而头（String name，String value）方法调用之后，其它与这个名称同名的标题都会被移除，只保留这一个标题。设置标签，设置标签可以用来取消这一请求。如果未指定标签或者标签为null，那么这个请求本身就会当做是一个标签用来被取消请求。设置cacheControl，这个是设置到请求头中。用来替换其它名称是“Cache-Control”的头。如果cacheControl是空的话就会移除请求头中名是“Cache-Control”的头。 OkHttp采用POST方法向服务器发送一个请求体，在OkHttp中这个请求体是RequestBody。这个请求体可以是： 字符串类型流流类型文件类型表单形式的键值类型类似Html文件上传表单的复杂请求体类型（多块请求） RequestBody有几个静态方法用于创建不同类型的请求体：最终都是相当于重写了RequestBody的两个抽象方法来写入流，如果传递流类型的参数，只要重写这两个抽象方法即可。例如，我们提交一个String：提交File：提交流：对于提交表单和分块请求，OkHttp提供了两个RequestBody的子类，FormBody和MultipartBody 2.1.1 表单FormBodyFormBody也是采用建造者模式， 这个很简单，添加key-value形式的键值对即可。添加键值对有两个方法：例如： 2.1.2 分块MultipartBodyMultipartBody也是采用建造者模式，MultipartBody.Builder可以构建兼容Html文件上传表单的复杂请求体。每一部分的多块请求体都是它自身的请求体，并且可以定义它自己的请求头。如果存在的话，这些请求头用来描述这部分的请求体。例如Content-Disposition、Content-Length 和 Content-Type如果可用就会被自动添加到头。 MIME类型有：有几个主要的方法：例如提交一个图片文件： 2.2 客户端OkHttpClientOkHttpClient采用建造者模式，通过Builder可以配置连接超时时间、读写时间，是否缓存、是否重连，还可以设置各种拦截器interceptor等。建议在一个App中，OkHttpClient保持一个实例。一个OkHttpClient支持一定数量的并发，请求同一个主机最大并发是5，所有的并发最大是64。这个与OkHttp中的调度器Dispatcher有关，可以设置并发数。本文不对Dispatcher进行讨论。一个例子：OkHttpClient支持单独配置，例如原来设置不同的请求时间，可以通过OkHttpClient的newBuilder()方法来重新构造一个OkHttpClient。例如： 3.同步请求和异步请求上面已经讲了如何创建Request和OkHttpClient，剩下的就是发送请求并得到服务器的响应了。OkHttp发送请求可分为同步和异步。OkHttpClient首先通过Request构建一个Call，通过这个Call去执行同步或者异步请求。同步方式，调用Call的execute()方法，返回Response，会阻塞当前线程：异步方式，调用Call的enqueue(CallBack callBack)方法，会在另一个线程中返回结果。 4.其他4.1 配置响应缓存为了缓存响应，需要一个可读写并且设置大小Size的缓存目录。缓存目录需要私有，其它不信任的应用不能访问这个文件。如果同时有多个缓存访问同一个缓存目录会报错。所以最好只在App中初始化一次OkHttpClient，给这个实例配置缓存，在整个App生命周期内都用这一个缓存。否则几个缓存会相互影响，导致缓存出错，引起程序崩溃。响应缓存采用Http头来配置，你可以添加这样的请求头Cache-Control: max-stale=3600。 max-age指的是客户端可以接收生存期不大于指定时间（以秒为单位）的响应。为了防止响应使用缓存，可以用CacheControl.FORCE_NETWORK。为了防止使用网络，采用 CacheControl.FORCE_CACHE。 注意:如果使用FORCE_CACHE禁止使用网络，而响应又没有缓存存在，OkHttp会报504 Unsatisfiable Request 响应错误。 4.2 取消请求调用Call.cancel()方法可以立即取消一个网络请求。如果当前线程正在写request或者读response会报IO异常。如果不再需要网络请求，采用这种方法是比较方便的。例如在App中返回了上一页。无论是同步还是异步的请求都可以被取消。 4.3 Response读取响应结果可以通过Response的code来判断请求是否成功，如果服务器返回的有数据，可以通过Response的body得到一个ResponseBody读取。如果采用ResponseBody的string()方法会一次性把数据读取到内存中，如果数据超过1MB可能会报内存溢出，所以对于超过1MB的数据，建议采用流的方式去读取，如ResponseBody的byteStream()方法。 需要说明的是： 如果ResponseBody的内容不读取的话，不会触发IO流的读取操作内容读取之后，这个body需要关闭。 5 总结OkHttp中的很多类都用到了建造者模式，可以根据需要灵活配置。采用建造者模式的有：12345OkHttpClient.BuilderRequest.BuilderFormBody.BuilderMultipartBody.BuilderResponse.Builder 如果单独使用OkHttp进行网络请求，通常需要开发者自己再封装一下，如果不想重复造轮子，Github上面的有一些优秀开源库可以拿来使用（本文只列出star较多的几个）：123hongyangAndroid/okhttputils（曾经在项目中用过）jeasonlzy/okhttp-OkGoyanzhenjie/NoHttp 分析篇1.客户端完整的请求OkHttp发送一个请求需要4步：12341 构建OkHttpClient2 构建Request3 创建一个Call4 执行Call的同步或者异步方法，处理响应。 我们只以一个简单的异步get请求来举例：Request和OkHttpClient都是我们自己创建的，不再讨论了。就从这个Call来展开讨论。 2.探究源码2.1 Call的实现类RealCallCall是一个准备执行的请求，它是一个接口。含有一个内部接口Factory 用于生成Call。OkHttpClient实现了Call.Factory接口，所以有一个newCall方法，这个方法中干了这么个事：可以看到，返回了一个RealCall，这个RealCall是OkHttp中Call的唯一实现类。说明我们执行请求，是通过RealCall发出的。在RealCall的构造方法中，我们还创建了一个拦截器RetryAndFollowUpInterceptor，通过名字我们可以猜测一下这个拦截器的作用是重试和跟进，这个负责是否断线重连和重定向，可以看到这个拦截器跟OkHttpClient有关联，我们可以在配置OkHttpClient的时候配置断线重连等，默认的都是true。 在OkHttp中以Real为前缀的类，都是真正干活的类 2.2 RealCall的enqueue( Callback callBack)方法OkHttpClient的newCall方法只是创建了一个RealCall，RealCall的enqueue方法传递了一个CallBack用于处理回调，那我们看看这个方法都干了些什么:从上面可以看出，同一个Call只能执行一次，否则会报错。client.dispatcher()返回的是与OkHttpClient绑定的一个Dispatcher。这个Dispatcher用来管理请求的调度。在使用篇我们简单的也提到过这个类。这个类主要是用来管理异步请求的调度，同步请求中虽然也参与了，但只是简单的统计正在执行的Call并在Call执行完毕之后做相应的处理。 AsyncCall是RealCall的内部类，继承了NamedRunnable，实际上也是一个Runnable实现类。这个AsyncCall 包装了Callback。它的run()方法中最终会调用它自己的execute()方法。后面我们会讲到AsyncCall的execute()方法。RealCall的enqueue( Callback callBack)实际上最后调用了Dispatcher的enqueue(AsyncCall call)方法。 2.3 Dispatcher的enqueue方法Dispatcher的enqueue方法是这样的：这个方法中首先会判断当前正在执行的Call的数量以及访问同一个主机地址的Call的数量是否在限定范围内。Dispatcher默认的Call的并发数是64，同一个主机地址的并发数是5。这个并发数可以更改。如果满足条件，就向代表当前正在执行的Call的集合中添加该Call，并且去执行它。否则就会向等待的集合中添加该Call，等待被执行。 executorService()返回的是ExecutorService对象，调用ExecutorService的execute(call)方法实际上最后调用的就是AsyncCall 的execute()方法。在这个execute()方法中，能获得返回Response，之后做回调处理，Dispatcher也会对Call进行管理。核心的方法是getResponseWithInterceptorChain()。 #####2.4 核心方法getResponseWithInterceptorChain()在这个getResponseWithInterceptorChain()方法中，有大量的Interceptors，有开发者自己定义的Interceptor也有OkHttp自己的Interceptor。这些Interceptor都存入到了ArrayList集合，我们在这里就可以大胆猜测一下这个Interceptor应该是顺序执行的。最后创建了一个RealInterceptorChain，通过调用它的proceed(request)方法开始处理原始的request，然后我们就拿到了我们想要的Response。 RealInterceptorChain是Interceptor.Chain的实现类，看这个Real前缀就知道它干的绝对是重要的事。它是一个具体的拦截器链，我们存放在List interceptors集合中的拦截器之间的传递都要靠它。 它的proceed(request)最终会调用到四个参数的重载方法：上述代码部分就是这个方法的核心，能够把Request依次传递给下一个Interceptor去处理。拦截器Interceptor的设计真是很赞，每一个Interceptor在发送Request的时候只处理自己那一部分Request，然后通过RealInterceptorChain的带动传递给下一个Interceptor进行处理，最后一个Interceptor发送完请求得到服务器的响应Response，经过自己的处理之后返回给它之前的那个Interceptor进行处理，依次进行，最后一个处理完毕的Response返回给开发者用户。形象一点，Interceptor就像是生产线上的工人，Request是物料，Response是产品，RealInterceptorChain是一节一节的传送带。每个工人同时负责处理自己那一部分的Request和Response，由传送带进行传递，各司其职，最后完成一件对用户来讲完美的产品。我第一次看OkHttp3.4源码的的时候真是一脸懵逼继而叹为观止。后来看了其它文章，才知道原来这个设计模式叫作责任链模式。在Android源码设计模式解析与实战这本书中介绍了Android的事件分发处理采用的也是责任链模式。 具体到每个拦截器都是怎么处理Request和Response的，最好自己去看一下，我们就不展开讨论了。 3.同步请求看了异步请求的调用，同步请求的分析就比较简单最终调用的是getResponseWithInterceptorChain()这个核心方法。4.总结 本文对OkHttp一个完整的请求过程做了简单的说明，限于篇幅有些地方讲的不是很详细，有兴趣的读者可以自己去探索一下这个流程，尤其是在拦截器那一部分，掌握好了之后对我们平时灵活运用OkHttp会有很大帮助，如配置我们自定义的缓存拦截器，或者在拦截器中监听下载进度，网上也有很多文章可供参考。 参考:OkHttp官方Wiki文档从OKHttp框架看代码设计拆轮子系列：拆 OkHttp","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"OkHttp","slug":"OkHttp","permalink":"http://yoursite.com/tags/OkHttp/"}]},{"title":"Spring Boot(四)","slug":"Spring Boot 连接MySql数据库","date":"2018-07-20T04:10:37.825Z","updated":"2018-07-20T04:10:37.825Z","comments":true,"path":"2018/07/20/Spring Boot 连接MySql数据库/","link":"","permalink":"http://yoursite.com/2018/07/20/Spring Boot 连接MySql数据库/","excerpt":"","text":"Spring Boot 连接MySql数据库Spring Boot可以大大简化持久化任务，几乎不需要写SQL语句，在之前章节“Spring Boot 构建框架”中我们新建了一个Spring Boot应用程序，本章在原有的工程中与数据库建立连接。 Spring Boot有两种方法与数据库建立连接，一种是使用JdbcTemplate，另一种集成Mybatis，下面分别为大家介绍一下如何集成和使用这两种方式。 1. 使用JdbcTemplate12345678&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 在resource文件夹下添加application.properties配置文件并输入数据库参数，内容如下：1234567891011spring.datasource.url=jdbc:mysql://127.0.0.1:3306/testspring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.max-idle=10spring.datasource.max-wait=1000spring.datasource.min-idle=5spring.datasource.initial-size=5server.port=8012server.session.timeout=10server.tomcat.uri-encoding=UTF-8 新建Controller类测试数据库连接，实例如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Map.Entry;import java.util.Set;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(&quot;/mydb&quot;)public class DBController &#123; @Autowired private JdbcTemplate jdbcTemplate; @RequestMapping(&quot;/getUsers&quot;) public List&lt;Map&lt;String, Object&gt;&gt; getDbType()&#123; String sql = &quot;select * from appuser&quot;; List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(sql); for (Map&lt;String, Object&gt; map : list) &#123; Set&lt;Entry&lt;String, Object&gt;&gt; entries = map.entrySet( ); if(entries != null) &#123; Iterator&lt;Entry&lt;String, Object&gt;&gt; iterator = entries.iterator( ); while(iterator.hasNext( )) &#123; Entry&lt;String, Object&gt; entry =(Entry&lt;String, Object&gt;) iterator.next( ); Object key = entry.getKey( ); Object value = entry.getValue(); System.out.println(key+&quot;:&quot;+value); &#125; &#125; &#125; return list; &#125; @RequestMapping(&quot;/user/&#123;id&#125;&quot;) public Map&lt;String,Object&gt; getUser(@PathVariable String id)&#123; Map&lt;String,Object&gt; map = null; List&lt;Map&lt;String, Object&gt;&gt; list = getDbType(); for (Map&lt;String, Object&gt; dbmap : list) &#123; Set&lt;String&gt; set = dbmap.keySet(); for (String key : set) &#123; if(key.equals(&quot;id&quot;))&#123; if(dbmap.get(key).equals(id))&#123; map = dbmap; &#125; &#125; &#125; &#125; if(map==null) map = list.get(0); return map; &#125; &#125; 运行App输入地址输出数据库数据。 2. 集成Mybatis 添加mybatis依赖，在pom.xml文件中增加如下：12345&lt;dependency&gt;&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;&lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt; 在resource文件夹下添加application.properties配置文件并输入数据库参数，如下：1234567891011spring.datasource.url=jdbc:mysql://127.0.0.1:3306/testspring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.max-idle=10spring.datasource.max-wait=1000spring.datasource.min-idle=5spring.datasource.initial-size=5server.port=8012server.session.timeout=10server.tomcat.uri-encoding=UTF-8 依次添加mapper的接口类和xml文件，类分别如下： AppMessageMapper.java12345678910111213import java.util.List;import com.example.demo.bean.AppMessage;public interface AppMessageMapper &#123; int deleteByPrimaryKey(String id); int insert(AppMessage record); int insertSelective(AppMessage record); AppMessage selectByPrimaryKey(String id); int updateByPrimaryKeySelective(AppMessage record); int updateByPrimaryKey(AppMessage record); List&lt;AppMessage&gt; selectAll(); List&lt;AppMessage&gt; getMessById(String id);&#125; AppMessageMapper.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.example.demo.mapper.AppMessageMapper&quot; &gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.example.demo.bean.AppMessage&quot; &gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;message&quot; property=&quot;message&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;senddate&quot; property=&quot;senddate&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt; &lt;/resultMap&gt; &lt;sql id=&quot;Base_Column_List&quot; &gt; id, message, senddate &lt;/sql&gt; &lt;select id=&quot;selectByPrimaryKey&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.lang.String&quot; &gt; select &lt;include refid=&quot;Base_Column_List&quot; /&gt; from appuser_message where id = #&#123;id,jdbcType=VARCHAR&#125; &lt;/select&gt; &lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;java.lang.String&quot; &gt; delete from appuser_message where id = #&#123;id,jdbcType=VARCHAR&#125; &lt;/delete&gt; &lt;insert id=&quot;insert&quot; parameterType=&quot;com.example.demo.bean.AppMessage&quot; &gt; insert into appuser_message (id, message, senddate ) values (#&#123;id,jdbcType=VARCHAR&#125;, #&#123;message,jdbcType=VARCHAR&#125;, #&#123;senddate,jdbcType=TIMESTAMP&#125; ) &lt;/insert&gt; &lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.example.demo.bean.AppMessage&quot; &gt; insert into appuser_message &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot; &gt; &lt;if test=&quot;id != null&quot; &gt; id, &lt;/if&gt; &lt;if test=&quot;message != null&quot; &gt; message, &lt;/if&gt; &lt;if test=&quot;senddate != null&quot; &gt; senddate, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot; &gt; &lt;if test=&quot;id != null&quot; &gt; #&#123;id,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=&quot;message != null&quot; &gt; #&#123;message,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=&quot;senddate != null&quot; &gt; #&#123;senddate,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id=&quot;updateByPrimaryKeySelective&quot; parameterType=&quot;com.example.demo.bean.AppMessage&quot; &gt; update appuser_message &lt;set &gt; &lt;if test=&quot;message != null&quot; &gt; message = #&#123;message,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=&quot;senddate != null&quot; &gt; senddate = #&#123;senddate,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;/set&gt; where id = #&#123;id,jdbcType=VARCHAR&#125; &lt;/update&gt; &lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;com.example.demo.bean.AppMessage&quot; &gt; update appuser_message set message = #&#123;message,jdbcType=VARCHAR&#125;, senddate = #&#123;senddate,jdbcType=TIMESTAMP&#125; where id = #&#123;id,jdbcType=VARCHAR&#125; &lt;/update&gt; &lt;select id=&quot;selectAll&quot; resultMap=&quot;BaseResultMap&quot;&gt; select id, message, senddate from appuser_message order by senddate asc &lt;/select&gt; &lt;select id=&quot;getMessById&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.lang.String&quot;&gt; select id, message, senddate from appuser_message where id = #&#123;id,jdbcType=VARCHAR&#125; order by senddate asc &lt;/select&gt; &lt;/mapper&gt; AppMessage.java123456789101112131415161718192021222324import java.util.Date;public class AppMessage &#123; private String id; private String message; private Date senddate; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id == null ? null : id.trim(); &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message == null ? null : message.trim(); &#125; public Date getSenddate() &#123; return senddate; &#125; public void setSenddate(Date senddate) &#123; this.senddate = senddate; &#125;&#125; AppMessageService.java 12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.example.demo.bean.AppMessage;import com.example.demo.mapper.AppMessageMapper;@Servicepublic class AppMessageService &#123; @Autowired private AppMessageMapper mapper; public List&lt;AppMessage&gt; getMessage()&#123; List&lt;AppMessage&gt; list = new ArrayList&lt;AppMessage&gt;(); list.add(mapper.selectByPrimaryKey(&quot;xtt&quot;)); //list = mapper.selectAll(); return list; &#125; public List&lt;AppMessage&gt; getAllMessage()&#123; List&lt;AppMessage&gt; list = new ArrayList&lt;AppMessage&gt;(); list = mapper.selectAll(); return list; &#125; public int addMessage(AppMessage appMessage) &#123; return mapper.insert(appMessage); &#125; public List&lt;AppMessage&gt; getMessageById(String id) &#123; return mapper.getMessById(id); &#125; public int delMessage(String id) &#123; return mapper.deleteByPrimaryKey(id); &#125;&#125; APPMessageController.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import com.example.demo.bean.AppMessage;import com.example.demo.service.AppMessageService;@RestController@RequestMapping(&quot;/appmessage&quot;)public class APPMessageController &#123; @Autowired private AppMessageService service; @RequestMapping(&quot;/getThree&quot;) public List&lt;AppMessage&gt; getThreeForMessage()&#123; List&lt;AppMessage&gt; list = service.getMessage(); return list; &#125; @RequestMapping(&quot;/getAll&quot;) public List&lt;AppMessage&gt; getAllMessage()&#123; List&lt;AppMessage&gt; list = service.getAllMessage(); int num = list.size(); if(null!=list &amp;&amp; num&gt;3)&#123; for (int i = 0; i &lt; num-3; i++) &#123; list.remove(0); &#125; &#125; return list; &#125; @RequestMapping(&quot;/getByID&quot;) public List&lt;AppMessage&gt; getMessageById(@RequestParam(&quot;id&quot;) String id)&#123; List&lt;AppMessage&gt; list = service.getMessageById(id); int num = list.size(); if(null!=list &amp;&amp; num&gt;5)&#123; for (int i = 0; i &lt; num-5; i++) &#123; list.remove(0); &#125; &#125; return list; &#125; @RequestMapping(value = &quot;/add&quot;,method = RequestMethod.POST) // 或者采用@PostMapping(&quot;/add&quot;)方法，更加节省代码的编写量 public int addMessage(@RequestBody AppMessage appMessage)&#123; return service.addMessage(appMessage); &#125; @RequestMapping(value=&quot;/delMessageById&quot;,method=RequestMethod.POST) // 或者采用@PostMapping(&quot;/delMessageById&quot;)方法，更加节省代码的编写量 public int delMessageById(@RequestParam(&quot;id&quot;) String id)&#123; return service.delMessage(id); &#125;&#125; 问题描述SpringBoot扫描包提示找不到mapper的问题，异常信息：Consider defining a bean of type in your configuration 分析原因Spring Boot项目的Bean装配默认规则是根据Application类所在的包位置从上往下扫描，“Application类”是指Spring Boot项目入口类。如果Application类所在的包为：com.yoodb.blog，则只会扫描com.yoodb.blog包及其所有子包，如果service或dao所在包不在com.yoodb.blog及其子包下，则不会被扫描。 解决方法方式一：使用注解@ComponentScan(value=”com.yoodb.blog”)，其中，com.yoodb.blog为包路径。方式二：将启动类Application放在上一级包中，注意的是Application启动类必须要保证在包的根目录下。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"Spring Boot 连接MySql数据库","slug":"Spring-Boot-连接MySql数据库","permalink":"http://yoursite.com/tags/Spring-Boot-连接MySql数据库/"}]},{"title":"Git","slug":"Git 指令","date":"2018-07-20T04:10:37.825Z","updated":"2018-07-20T04:10:37.825Z","comments":true,"path":"2018/07/20/Git 指令/","link":"","permalink":"http://yoursite.com/2018/07/20/Git 指令/","excerpt":"","text":"Git 指令git init1在本地新建一个repo,进入一个项目目录,执行git init,会初始化一个repo,并在当前文件夹下创建一个.git文件夹. git clone123获取一个url对应的远程Git repo, 创建一个local copy.一般的格式是git clone [url].clone下来的repo会以url最后一个斜线后面的名称命名,创建一个文件夹,如果想要指定特定的名称,可以git clone [url] newname指定. git status12查询repo的状态.git status -s: -s表示short, -s的输出标记会有两列,第一列是对staging区域而言,第二列是对working目录而言. git log123456789101112131415161718show commit history of a branch.git log --oneline --number: 每条log只显示一行,显示number条.git log --oneline --graph:可以图形化地表示出分支合并历史.git log branchname可以显示特定分支的log.git log --oneline branch1 ^branch2,可以查看在分支1,却不在分支2中的提交.^表示排除这个分支(Window下可能要给^branch2加上引号).git log --decorate会显示出tag信息.git log --author=[author name] 可以指定作者的提交历史.git log --since --before --until --after 根据提交时间筛选log.--no-merges可以将merge的commits排除在外.git log --grep 根据commit信息过滤log: git log --grep=keywords默认情况下, git log --grep --author是OR的关系,即满足一条即被返回,如果你想让它们是AND的关系,可以加上--all-match的option.git log -S: filter by introduced diff.比如: git log -SmethodName (注意S和后面的词之间没有等号分隔).git log -p: show patch introduced at each commit.每一个提交都是一个快照(snapshot),Git会把每次提交的diff计算出来,作为一个patch显示给你看.另一种方法是git show [SHA].git log --stat: show diffstat of changes introduced at each commit.同样是用来看改动的相对信息的,--stat比-p的输出更简单一些. git add123在提交之前,Git有一个暂存区(staging area),可以放入新添加的文件或者加入新的改动. commit时提交的改动是上一次加入到staging area中的改动,而不是我们disk上的改动.git add .会递归地添加当前工作目录中的所有文件. git diff123456789101112131415161718192021不加参数的git diff:show diff of unstaged changes.此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容.若要看已经暂存起来的文件和上次提交时的快照之间的差异,可以用:git diff --cached 命令.show diff of staged changes.(Git 1.6.1 及更高版本还允许使用 git diff --staged，效果是相同的).git diff HEADshow diff of all staged or unstated changes.也即比较woking directory和上次提交之间所有的改动.如果想看自从某个版本之后都改动了什么,可以用:git diff [version tag]跟log命令一样,diff也可以加上--stat参数来简化输出.git diff [branchA] [branchB]可以用来比较两个分支.它实际上会返回一个由A到B的patch,不是我们想要的结果.一般我们想要的结果是两个分支分开以后各自的改动都是什么,是由命令:git diff [branchA]…[branchB]给出的.实际上它是:git diff $(git merge-base [branchA] [branchB]) [branchB]的结果. git commit1234提交已经被add进来的改动.git commit -m “the commit message&quot;git commit -a 会先把所有已经track的文件的改动add进来,然后提交(有点像svn的一次提交,不用先暂存). 对于没有track的文件,还是需要git add一下.git commit --amend 增补提交. 会使用与当前提交节点相同的父节点进行一次新的提交,旧的提交将会被取消. git reset123456789101112131415161718undo changes and commits.这里的HEAD关键字指的是当前分支最末梢最新的一个提交.也就是版本库中该分支上的最新版本.git reset HEAD: unstage files from index and reset pointer to HEAD这个命令用来把不小心add进去的文件从staged状态取出来,可以单独针对某一个文件操作: git reset HEAD - - filename, 这个- - 也可以不加.git reset --softmove HEAD to specific commit reference, index and staging are untouched.git reset --hardunstage files AND undo any changes in the working directory since last commit.使用git reset —hard HEAD进行reset,即上次提交之后,所有staged的改动和工作目录的改动都会消失,还原到上次提交的状态.这里的HEAD可以被写成任何一次提交的SHA-1.不带soft和hard参数的git reset,实际上带的是默认参数mixed.总结:git reset --mixed id,是将git的HEAD变了(也就是提交记录变了),但文件并没有改变，(也就是working tree并没有改变). 取消了commit和add的内容.git reset --soft id. 实际上，是git reset –mixed id 后,又做了一次git add.即取消了commit的内容.git reset --hard id.是将git的HEAD变了,文件也变了.按改动范围排序如下:soft (commit) &lt; mixed (commit + add) &lt; hard (commit + add + local working) git revert123反转撤销提交.只要把出错的提交(commit)的名字(reference)作为参数传给命令就可以了.git revert HEAD: 撤销最近的一个提交.git revert会创建一个反向的新提交,可以通过参数-n来告诉Git先不要提交. git rm123git rm file: 从staging区移除文件,同时也移除出工作目录.git rm --cached: 从staging区移除文件,但留在工作目录中.git rm --cached从功能上等同于git reset HEAD,清除了缓存区,但不动工作目录树. git clean123git clean是从工作目录中移除没有track的文件.通常的参数是git clean -df:-d表示同时移除目录,-f表示force,因为在git的配置文件中, clean.requireForce=true,如果不加-f,clean将会拒绝执行. git mv1git rm - - cached orig; mv orig new; git add new git stash12345678910把当前的改动压入一个栈.git stash将会把当前目录和index中的所有改动(但不包括未track的文件)压入一个栈,然后留给你一个clean的工作状态,即处于上一次最新提交处.git stash list会显示这个栈的list.git stash apply:取出stash中的上一个项目(stash@&#123;0&#125;),并且应用于当前的工作目录.也可以指定别的项目,比如git stash apply stash@&#123;1&#125;.如果你在应用stash中项目的同时想要删除它,可以用git stash pop删除stash中的项目:git stash drop: 删除上一个,也可指定参数删除指定的一个项目.git stash clear: 删除所有项目. git branch12345678910git branch可以用来列出分支,创建分支和删除分支.git branch -v可以看见每一个分支的最后一次提交.git branch: 列出本地所有分支,当前分支会被星号标示出.git branch (branchname): 创建一个新的分支(当你用这种方式创建分支的时候,分支是基于你的上一次提交建立的). git branch -d (branchname): 删除一个分支.删除remote的分支:git push (remote-name) :(branch-name): delete a remote branch.这个是因为完整的命令形式是:git push remote-name local-branch:remote-branch而这里local-branch的部分为空,就意味着删除了remote-branch git checkout12345678git checkout（branchname）切换到一个分支.git checkout -b (branchname): 创建并切换到新的分支.这个命令是将git branch newbranch和git checkout newbranch合在一起的结果.checkout还有另一个作用:替换本地改动:git checkout --&lt;filename&gt;此命令会使用HEAD中的最新内容替换掉你的工作目录中的文件.已添加到暂存区的改动以及新文件都不会受到影响.注意:git checkout filename会删除该文件中所有没有暂存和提交的改动,这个操作是不可逆的. git merge123456把一个分支merge进当前的分支.git merge [alias]/[branch]把远程分支merge到当前分支.如果出现冲突,需要手动修改,可以用git mergetool.解决冲突的时候可以用到git diff,解决完之后用git add添加,即表示冲突已经被resolved. git tag1234567891011tag a point in history as import.会在一个提交上建立永久性的书签,通常是发布一个release版本或者ship了什么东西之后加tag.比如: git tag v1.0git tag -a v1.0, -a参数会允许你添加一些信息,即make an annotated tag.当你运行git tag -a命令的时候,Git会打开一个编辑器让你输入tag信息.我们可以利用commit SHA来给一个过去的提交打tag:git tag -a v0.9 XXXXpush的时候是不包含tag的,如果想包含,可以在push时加上--tags参数.fetch的时候,branch HEAD可以reach的tags是自动被fetch下来的, tags that aren’t reachable from branch heads will be skipped.如果想确保所有的tags都被包含进来,需要加上--tags选项. git remote123456789list, add and delete remote repository aliases.因为不需要每次都用完整的url,所以Git为每一个remote repo的url都建立一个别名,然后用git remote来管理这个list.git remote: 列出remote aliases.如果你clone一个project,Git会自动将原来的url添加进来,别名就叫做:origin.git remote -v:可以看见每一个别名对应的实际url.git remote add [alias] [url]: 添加一个新的remote repo.git remote rm [alias]: 删除一个存在的remote alias.git remote rename [old-alias] [new-alias]: 重命名.git remote set-url [alias] [url]:更新url. 可以加上—push和fetch参数,为同一个别名set不同的存取地址. git fetch123download new branches and data from a remote repository.可以git fetch [alias]取某一个远程repo,也可以git fetch --all取到全部repofetch将会取到所有你本地没有的数据,所有取下来的分支可以被叫做remote branches,它们和本地分支一样(可以看diff,log等,也可以merge到其他分支),但是Git不允许你checkout到它们. git pull1234fetch from a remote repo and try to merge into the current branch.pull == fetch + merge FETCH_HEADgit pull会首先执行git fetch,然后执行git merge,把取来的分支的head merge到当前分支.这个merge操作会产生一个新的commit. 如果使用--rebase参数,它会执行git rebase来取代原来的git merge. git rebase1234--rebase不会产生合并的提交,它会将本地的所有提交临时保存为补丁(patch),放在”.git/rebase”目录中,然后将当前分支更新到最新的分支尖端,最后把保存的补丁应用到分支上.rebase的过程中,也许会出现冲突,Git会停止rebase并让你解决冲突,在解决完冲突之后,用git add去更新这些内容,然后无需执行commit,只需要:git rebase --continue就会继续打余下的补丁.git rebase --abort将会终止rebase,当前分支将会回到rebase之前的状态. git push1234push your new branches and data to a remote repository.git push [alias] [branch]将会把当前分支merge到alias上的[branch]分支.如果分支已经存在,将会更新,如果不存在,将会添加这个分支.如果有多个人向同一个remote repo push代码, Git会首先在你试图push的分支上运行git log,检查它的历史中是否能看到server上的branch现在的tip,如果本地历史中不能看到server的tip,说明本地的代码不是最新的,Git会拒绝你的push,让你先fetch,merge,之后再push,这样就保证了所有人的改动都会被考虑进来. git reflog1234git reflog是对reflog进行管理的命令,reflog是git用来记录引用变化的一种机制,比如记录分支的变化或者是HEAD引用的变化.当git reflog不指定引用的时候,默认列出HEAD的reflog.HEAD@&#123;0&#125;代表HEAD当前的值,HEAD@&#123;3&#125;代表HEAD在3次变化之前的值.git会将变化记录到HEAD对应的reflog文件中,其路径为.git/logs/HEAD, 分支的reflog文件都放在.git/logs/refs目录下的子目录中.","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"初识RecyclerView","slug":"RecyclerView","date":"2018-07-20T04:10:37.825Z","updated":"2018-07-20T04:10:37.825Z","comments":true,"path":"2018/07/20/RecyclerView/","link":"","permalink":"http://yoursite.com/2018/07/20/RecyclerView/","excerpt":"","text":"RecyclerView基本使用1.使用前需要在在gradle中添加依赖1implementation &apos;com.android.support:recyclerview-v7:27.0.2&apos; 2.编写代码，首先我们需要在Xml中写RecyclerView的布局1234&lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recyclerView&quot; android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;/&gt; 然后在activity中获取RecyclerView，并设置LayoutManager以及adapter 12345678910//通过findViewById拿到RecyclerView实例mRecyclerView = findViewById(R.id.recyclerView);//设置RecyclerView管理器mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false));//初始化适配器mAdapter = new MyRecyclerViewAdapter(list); //设置添加或删除item时的动画，这里使用默认动画mRecyclerView.setItemAnimator(new DefaultItemAnimator());//设置适配器mRecyclerView.setAdapter(mAdapter); 下面是MyRecyclerViewAdapter的代码：1234567891011121314151617181920212223242526272829303132public class MyRecyclerViewAdapter extends RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt; &#123; private List&lt;String&gt; list; //初始化适配器 public MyAdapter(List&lt;String&gt; list) &#123; this.list = list; &#125; @Override public MyAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_base_use, parent, false); MyAdapter.ViewHolder viewHolder = new MyAdapter.ViewHolder(view); return viewHolder; &#125; @Override public void onBindViewHolder(MyAdapter.ViewHolder holder, int position) &#123; holder.mText.setText(list.get(position)); &#125; @Override public int getItemCount() &#123; return list.size(); &#125; class ViewHolder extends RecyclerView.ViewHolder &#123; TextView mText; ViewHolder(View itemView) &#123; super(itemView); mText = itemView.findViewById(R.id.item_tx); &#125; &#125;&#125; 这里item_normal的布局也非常简单1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/item_tx&quot; android:layout_width=&quot;match_content&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center&quot; android:padding=&quot;10dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:text=&quot;Item&quot;/&gt; &lt;/LinearLayout&gt; 从例子也可以看出来，RecyclerView的用法并不比ListView复杂，反而更灵活好用，它将数据、排列方式、数据的展示方式都分割开来，因此可定制型，自定义的形式也非常多，非常灵活。设置横向布局：1mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false)); 设置网格布局：1mRecyclerView.setLayoutManager(new GridLayoutManager(this, 3)); 设置瀑布流：1mRecyclerView.setLayoutManager(new StaggeredGridLayoutManager(3,StaggeredGridLayoutManager.VERTICAL)); 如果第二个参数可以设置为横向的，则效果如下： 以上可知，我们可以通过设置不同的管理器，实现不同的效果 LinearLayoutManager：以线性布局展示，可以设置横向和纵向GridLayoutManager：以网格形式展示，类似GridView效果StaggeredGridLayoutManager：以瀑布流形式的效果 RecyclerView条目之间默认没有分割线，那是否可以像ListView一样设置divider以及dividerHight搞一条分割线出来呢，答案是不可以的，google并没有提供这样的属性。但是谷歌为我们提供了可以定制的解决办法，那就是以下要说ItemDecoration 利用ItemDecoration实现条目分割线ItemDecoration是谷歌定义的可用于画分割线的类， 是抽象的，需要我们自己去实现123456789101112131415161718192021222324252627public abstract static class ItemDecoration &#123; public void onDraw(Canvas c, RecyclerView parent, State state) &#123; onDraw(c, parent); &#125; @Deprecated public void onDraw(Canvas c, RecyclerView parent) &#123; &#125; public void onDrawOver(Canvas c, RecyclerView parent, State state) &#123; onDrawOver(c, parent); &#125; @Deprecated public void onDrawOver(Canvas c, RecyclerView parent) &#123; &#125; @Deprecated public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) &#123; outRect.set(0, 0, 0, 0); &#125; public void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state) &#123; getItemOffsets(outRect, ((LayoutParams) view.getLayoutParams()).getViewLayoutPosition(), parent); &#125; &#125; 当我们通过1mRecyclerView.addItemDecoration(); onDraw: 该方法可以在RecyclerView的画布上画任何装饰，且是在 the item views 被绘制之前回调 onDrawOver: 该方法可以在RecyclerView的画布上画任何装饰，且是在 the item views 被绘制之后回调getItemOffsets : 可以在该方法中为the item views添加偏移量 下面我们可以就通过继承ItemDecoration为RecyclerView添加分割线。DividerItemDecoration的代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 public class DividerItemDecoration extends RecyclerView.ItemDecoration &#123; @OrientationType private int mOrientation = LinearLayoutManager.VERTICAL; private Drawable mDivider; private int[] attrs = new int[]&#123; android.R.attr.listDivider &#125;; public DividerItemDecoration(Context context, @OrientationType int orientation) &#123; TypedArray typedArray = context.obtainStyledAttributes(attrs); mDivider = typedArray.getDrawable(0); typedArray.recycle(); setOrientation(orientation); &#125; private void setOrientation(@OrientationType int orientation) &#123; if (orientation != LinearLayoutManager.VERTICAL &amp;&amp; orientation != LinearLayoutManager.HORIZONTAL) &#123; throw new IllegalArgumentException(&quot;传入的布局类型不合法&quot;); &#125; this.mOrientation = orientation; &#125; @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; //调用这个绘制方法，RecyclerView会回调该绘制方法，需要我们自己去绘制条目的间隔线 if (mOrientation == LinearLayoutManager.VERTICAL) &#123; //垂直 drawVertical(c, parent); &#125; else &#123; //水平 drawHorizontal(c, parent); &#125; &#125; private void drawVertical(Canvas c, RecyclerView parent) &#123; // 画水平线 int left = parent.getPaddingLeft(); int right = parent.getWidth() - parent.getPaddingRight(); int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; View child = parent.getChildAt(i); RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams(); int top = child.getBottom() + params.bottomMargin + Math.round(ViewCompat.getTranslationY(child)); int bottom = top + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; private void drawHorizontal(Canvas c, RecyclerView parent) &#123; int top = parent.getPaddingTop(); int bottom = parent.getHeight() - parent.getPaddingBottom(); int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; View child = parent.getChildAt(i); RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams(); int left = child.getRight() + params.rightMargin + Math.round(ViewCompat.getTranslationX(child)); int right = left + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; //获得条目的偏移量（所有的条目都会回调一次该方法） if (mOrientation == LinearLayoutManager.VERTICAL) &#123; //垂直 outRect.set(0, 0, 0, mDivider.getIntrinsicHeight()); &#125; else &#123; //水平 outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0); &#125; &#125; @IntDef(&#123;LinearLayoutManager.VERTICAL, LinearLayoutManager.HORIZONTAL&#125;) public @interface OrientationType &#123; &#125;&#125; 然后在activity设置水平方向:12mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false); mRecyclerView.addItemDecoration(new DividerItemDecoration(this, LinearLayoutManager.VERTICAL)); 竖直方向：12mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.HORIZONAL, false); mRecyclerView.addItemDecoration(new DividerItemDecoration(this, LinearLayoutManager.HORIZONAL)); 这里的分割线是默认的，我们可以在主题中去设置分割线的颜色12345678&lt;!-- Base application theme. --&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;item name=&quot;android:listDivider&quot;&gt;@drawable/bg_recyclerview_divider&lt;/item&gt; &lt;/style&gt; bg_recyclerview_divider.xml123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;gradient android:centerColor=&quot;#ff00ff00&quot; android:endColor=&quot;#ff0000ff&quot; android:startColor=&quot;#ffff0000&quot; android:type=&quot;linear&quot;/&gt; &lt;size android:width=&quot;10dp&quot; android:height=&quot;10dp&quot;/&gt; &lt;/shape&gt; 运行后效果如下以上的分割线只适用在LinearLayoutManager的相关布局中。对于GridLayoutManager布局是不适用的。需要我们单独写一个。以下是对于GridLayoutManager布局的分割线代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public class DividerGridViewItemDecoration extends RecyclerView.ItemDecoration &#123; private Drawable mDivider; private int[] attrs = new int[]&#123; android.R.attr.listDivider&#125;; public DividerGridViewItemDecoration(Context context) &#123; TypedArray typedArray = context.obtainStyledAttributes(attrs); mDivider = typedArray.getDrawable(0); typedArray.recycle(); &#125; @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; drawVertical(c, parent); drawHorizontal(c, parent); &#125; private void drawVertical(Canvas c, RecyclerView parent) &#123; //绘制垂直间隔线（垂直的矩形） int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; View child = parent.getChildAt(i); RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams(); int left = child.getRight() + params.rightMargin; int right = left + mDivider.getIntrinsicWidth(); int top = child.getTop() - params.topMargin; int bottom = child.getBottom() + params.bottomMargin; mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; private void drawHorizontal(Canvas c, RecyclerView parent) &#123; //绘制水平分割线 int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; View child = parent.getChildAt(i); RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams(); int left = child.getLeft() - params.leftMargin; int right = child.getRight() + params.rightMargin + mDivider.getIntrinsicWidth(); int top = child.getBottom() + params.bottomMargin; int bottom = top + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; // 四个方向的偏移值 int right = mDivider.getIntrinsicWidth(); int bottom = mDivider.getIntrinsicHeight(); RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) view.getLayoutParams(); int itemPosition = params.getViewAdapterPosition(); if (isLastColum(itemPosition, parent)) &#123; right = 0; &#125; if (isLastRow(itemPosition, parent)) &#123; bottom = 0; &#125; outRect.set(0, 0, right, bottom); &#125; /** * 是否最后一行 */ private boolean isLastRow(int itemPosition, RecyclerView parent) &#123; int spanCount = getSpanCount(parent); if (spanCount != -1) &#123; int childCount = parent.getAdapter().getItemCount(); int lastRowCount = childCount % spanCount; //最后一行的数量小于spanCount if (lastRowCount == 0 || lastRowCount &lt; spanCount) &#123; return true; &#125; &#125; return false; &#125; /** * 根据parent获取到列数 */ private int getSpanCount(RecyclerView parent) &#123; RecyclerView.LayoutManager layoutManager = parent.getLayoutManager(); if (layoutManager instanceof GridLayoutManager) &#123; GridLayoutManager lm = (GridLayoutManager) layoutManager; int spanCount = lm.getSpanCount(); return spanCount; &#125; return -1; &#125; /** * 判断是否是最后一列 */ private boolean isLastColum(int itemPosition, RecyclerView parent) &#123; int spanCount = getSpanCount(parent); if (spanCount != -1) &#123; if ((itemPosition + 1) % spanCount == 0) &#123; return true; &#125; &#125; return false; &#125;&#125; 我们在activity中使用该分割线12mRecyclerView.setLayoutManager(new GridLayoutManager(this, 3));mRecyclerView.addItemDecoration(new DividerGridViewItemDecoration(this)); 点击事件RecyclerView并没有像ListView的那样可以设置点击事件以及长按点击事件，这个需要我们可以在adapter中去设置回调的方式实现，具体代码如下：MyRecyclerViewAdapter的代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class MyRecyclerViewAdapter extends RecyclerView.Adapter&lt;MyRecyclerViewAdapter.ViewHolder&gt; &#123; private List&lt;String&gt; list; private OnItemClickListener onItemClickListener; private OnItemLongClickListener onItemLongClickListener; /** * 设置点击事件 */ public void setOnItemClickListener(OnItemClickListener onItemClickListener) &#123; this.onItemClickListener = onItemClickListener; &#125; /** * 设置长按点击事件 */ public void setOnItemLongClickListener(OnItemLongClickListener onItemLongClickListener) &#123; this.onItemLongClickListener = onItemLongClickListener; &#125; public MyRecyclerViewAdapter(List&lt;String&gt; list) &#123; this.list = list; &#125; @Override public MyRecyclerViewAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_base_use, parent, false); MyRecyclerViewAdapter.ViewHolder viewHolder = new MyRecyclerViewAdapter.ViewHolder(view); return viewHolder; &#125; @Override public void onBindViewHolder(MyRecyclerViewAdapter.ViewHolder holder, int position) &#123; holder.mText.setText(list.get(position)); int adapterPosition = holder.getAdapterPosition(); if (onItemClickListener != null) &#123; holder.itemView.setOnClickListener(new MyOnClickListener(position, list.get(adapterPosition))); &#125; if (onItemLongClickListener != null) &#123; holder.itemView.setOnLongClickListener(new MyOnLongClickListener(position, list.get(adapterPosition))); &#125; &#125; @Override public int getItemCount() &#123; return list.size(); &#125; class ViewHolder extends RecyclerView.ViewHolder &#123; TextView mText; ViewHolder(View itemView) &#123; super(itemView); mText = itemView.findViewById(R.id.item_tx); &#125; &#125; private class MyOnLongClickListener implements View.OnLongClickListener &#123; private int position; private String data; public MyOnLongClickListener(int position, String data) &#123; this.position = position; this.data = data; &#125; @Override public boolean onLongClick(View v) &#123; onItemLongClickListener.onItemLongClick(v, position, data); return true; &#125; &#125; private class MyOnClickListener implements View.OnClickListener &#123; private int position; private String data; public MyOnClickListener(int position, String data) &#123; this.position = position; this.data = data; &#125; @Override public void onClick(View v) &#123; onItemClickListener.onItemClick(v, position, data); &#125; &#125; public interface OnItemClickListener &#123; void onItemClick(View view, int position, String data); &#125; public interface OnItemLongClickListener &#123; void onItemLongClick(View view, int position, String data); &#125; &#125; activity中设置监听：123456789101112mAdapter.setOnItemClickListener(new MyRecyclerViewAdapter.OnItemClickListener() &#123;@Overridepublic void onItemClick(View view, int position, String data)&#123; Toast.makeText(MainActivity.this, &quot;您点击了： &quot; + data, Toast.LENGTH_SHORT).show(); &#125; &#125;); mAdapter.setOnItemLongClickListener(new MyRecyclerViewAdapter.OnItemLongClickListener() &#123; @Overridepublic void onItemLongClick(View view, int position, String data) &#123;Toast.makeText(MainActivity.this, &quot;您长按点击了： &quot; + data, Toast.LENGTH_SHORT).show(); &#125; &#125;);","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"初识RecyclerView","slug":"初识RecyclerView","permalink":"http://yoursite.com/tags/初识RecyclerView/"}]},{"title":"javaweb (九 )","slug":"一、HttpServletRequest介绍","date":"2018-07-20T04:10:37.821Z","updated":"2018-07-20T04:10:37.821Z","comments":true,"path":"2018/07/20/一、HttpServletRequest介绍/","link":"","permalink":"http://yoursite.com/2018/07/20/一、HttpServletRequest介绍/","excerpt":"","text":"一、HttpServletRequest介绍&amp;#8195&amp;#8195HttpServletRequest对象代表客户端的请求，当客户端通过HTTP协议访问服务器时，HTTP请求头中的所有信息都封装在这个对象中，通过这个对象提供的方法，可以获得客户端请求的所有信息。 二、Request常用方法2.1、获得客户机信息123456789 getRequestURL方法返回客户端发出请求时的完整URL。 getRequestURI方法返回请求行中的资源名部分。 getQueryString 方法返回请求行中的参数部分。 getPathInfo方法返回请求URL中的额外路径信息。额外路径信息是请求URL中的位于Servlet的路径之后和查询参数之前的内容，它以“/”开头。 getRemoteAddr方法返回发出请求的客户机的IP地址。 getRemoteHost方法返回发出请求的客户机的完整主机名。 getRemotePort方法返回客户机所使用的网络端口号。 getLocalAddr方法返回WEB服务器的IP地址。 getLocalName方法返回WEB服务器的主机名。 范例：通过request对象获取客户端请求信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package qgx.request.study;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class RequestDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取客户机信息 String requestUrl = req.getRequestURL().toString();//请求的URL地址 String requestUri = req.getRequestURI();//得到请求的资源 String queryString = req.getQueryString();//得到请求的URL地址中附带的参数 String remoteAddr = req.getRemoteAddr();//IP地址 String remoteHost = req.getRemoteHost(); int remotePort = req.getRemotePort(); String remoteUser = req.getRemoteUser(); String method = req.getMethod();//得到请求URL地址时使用的方法 String pathInfo = req.getPathInfo(); String localAddr = req.getLocalAddr();//获取WEB服务器的IP地址 String localName = req.getLocalName();//获取WEB服务器的主机名 resp.setCharacterEncoding(&quot;UTF-8&quot;);//设置将字符以&quot;UTF-8&quot;编码输出到客户端浏览器 //通过设置响应头控制浏览器以UTF-8的编码显示数据，如果不加这句话，那么浏览器显示的将是乱码 //2.显示数据 resp.setHeader(&quot;content-type&quot;, &quot;text/html;charset=UTF-8&quot;); PrintWriter out = resp.getWriter(); out.write(&quot;获取到的客户机信息如下：&quot;); out.write(&quot;&lt;hr/&gt;&quot;); out.write(&quot;请求的URL地址：&quot; + requestUrl); out.write(&quot;&lt;br/&gt;&quot;); out.write(&quot;请求的资源：&quot; + requestUri); out.write(&quot;&lt;br/&gt;&quot;); out.write(&quot;请求的URL地址中附带的参数：&quot; + queryString); out.write(&quot;&lt;br/&gt;&quot;); out.write(&quot;来访者的IP地址：&quot; + remoteAddr); out.write(&quot;&lt;br/&gt;&quot;); out.write(&quot;来访者的主机名：&quot; + remoteHost); out.write(&quot;&lt;br/&gt;&quot;); out.write(&quot;使用的端口号：&quot; + remotePort); out.write(&quot;&lt;br/&gt;&quot;); out.write(&quot;remoteUser：&quot; + remoteUser); out.write(&quot;&lt;br/&gt;&quot;); out.write(&quot;请求使用的方法：&quot; + method); out.write(&quot;&lt;br/&gt;&quot;); out.write(&quot;pathInfo：&quot; + pathInfo); out.write(&quot;&lt;br/&gt;&quot;); out.write(&quot;localAddr：&quot; + localAddr); out.write(&quot;&lt;br/&gt;&quot;); out.write(&quot;localName：&quot; + localName); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 2.2、获得客户机请求头123 getHeader(string name)方法:String getHeaders(String name)方法:Enumeration getHeaderNames()方法 范例：通过request对象获取客户端请求头信息1234567891011121314151617181920212223242526272829303132333435363738394041424344package qgx.request.study;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.Enumeration;@WebServlet(name = &quot;RequestDemo2&quot;)public class RequestDemo2 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setCharacterEncoding(&quot;UTF-8&quot;);//设置将字符以&quot;UTF-8&quot;编码输出到客户端浏览器 //通过设置响应头控制浏览器以UTF-8的编码显示数据 response.setHeader(&quot;content-type&quot;, &quot;text/html;charset=UTF-8&quot;); PrintWriter out = response.getWriter(); Enumeration&lt;String&gt; reqHeadInfos = request.getHeaderNames();//获取所有的请求头 out.write(&quot;获取到的客户端所有的请求头信息如下：&quot;); out.write(&quot;&lt;hr/&gt;&quot;); while (reqHeadInfos.hasMoreElements()) &#123; String headName = (String) reqHeadInfos.nextElement(); String headValue = request.getHeader(headName);//根据请求头的名字获取对应的请求头的值 out.write(headName + &quot;:--------:&quot; + headValue); out.write(&quot;&lt;br/&gt;&quot;); &#125; out.write(&quot;&lt;br/&gt;&quot;); out.write(&quot;获取到的客户端Accept-Encoding请求头的值：&quot;); out.write(&quot;&lt;hr/&gt;&quot;); String value = request.getHeader(&quot;Accept-Encoding&quot;);//获取Accept-Encoding请求头对应的值 out.write(value); Enumeration&lt;String&gt; e = request.getHeaders(&quot;Accept-Encoding&quot;); while (e.hasMoreElements()) &#123; String string = (String) e.nextElement(); System.out.println(string); &#125; &#125;&#125; 获得客户机请求参数(客户端提交的数据)1234getParameter(String)方法(常用)getParameterValues(String name)方法(常用)getParameterNames()方法(不常用)getParameterMap()方法(编写框架时常用) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;%-- Created by IntelliJ IDEA. User: qgx Date: 2018/5/16 Time: 22:38 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Html的From表单元素&lt;/title&gt;&lt;/head&gt;&lt;fieldset style=&quot;width:500px;&quot;&gt; &lt;legend&gt;Html的Form表单元素&lt;/legend&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/RequestDemo3&quot; method=&quot;post&quot;&gt; 编&amp;nbsp;&amp;nbsp;号(文本框)： &lt;!--输入文本框，SIZE表示显示长度，maxlength表示最多输入长度--&gt; &lt;input type=&quot;text&quot; name=&quot;userid&quot; value=&quot;NO.1&quot; size=&quot;2&quot; maxlength=&quot;2&quot;&gt; &lt;br&gt; &lt;!--输入文本框，通过value指定其显示的默认值--&gt; 用户名(文本框)：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;刘俭梅&quot;&gt;&lt;br&gt; &lt;!--密码框，其中所有输入的内容都以密文的形式显示--&gt; 密&amp;nbsp;&amp;nbsp;码(密码框)： &lt;input type=&quot;password&quot; name=&quot;userpassword&quot; value=&quot;请输入密码&quot;&gt; &lt;br&gt; &lt;!--单选按钮，通过checked指定默认选中，名称必须一样，其中value为真正需要的内容--&gt; 性&amp;nbsp;&amp;nbsp;别(单选框)： &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; &gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;checked&gt;女 &lt;br&gt; &lt;!--下拉列表框，通过&lt;option&gt;元素指定下拉的选项--&gt; 学&amp;nbsp;&amp;nbsp;校(下拉框)： &lt;select name=&quot;dept&quot;&gt; &lt;option value=&quot;衢州学院&quot;SELECTED&gt;衢州学院&lt;/option&gt; &lt;option value=&quot;中北大学&quot; &gt;中北大学&lt;/option&gt; &lt;option value=&quot;衢职&quot;&gt;衢职&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;!--复选框，可以同时选择多个选项，名称必须一样，其中value为真正需要的内容--&gt; 兴&amp;nbsp;&amp;nbsp;趣(复选框)： &lt;input type=&quot;checkbox&quot; name=&quot;inst&quot; value=&quot;唱歌&quot; checked&gt;唱歌 &lt;input type=&quot;checkbox&quot; name=&quot;inst&quot; value=&quot;游泳&quot;&gt;游泳 &lt;input type=&quot;checkbox&quot; name=&quot;inst&quot; value=&quot;跳舞&quot;&gt;跳舞 &lt;input type=&quot;checkbox&quot; name=&quot;inst&quot; value=&quot;编程&quot;&gt;编程 &lt;input type=&quot;checkbox&quot; name=&quot;inst&quot; value=&quot;上网&quot;&gt;上网 &lt;br&gt; &lt;!--大文本输入框，宽度为34列，高度为5行--&gt; 备&amp;nbsp;&amp;nbsp;注(文本域)： &lt;textarea name=&quot;note&quot; cols=&quot;34&quot; rows=&quot;5&quot;&gt; &lt;/textarea&gt; &lt;br&gt; &lt;!--隐藏域，在页面上无法看到，专门用来传递参数或者保存参数--&gt; &lt;input type=&quot;hidden&quot; name=&quot;hiddenField&quot; value=&quot;hiddenvalue&quot;/&gt; &lt;!--提交表单按钮，当点击提交后，所有填写的表单内容都会被传输到服务器端--&gt; &lt;input type=&quot;submit&quot; value=&quot;提交(提交按钮)&quot;&gt; &lt;!--重置表单按钮，当点击重置后，所有表单恢复原始显示内容--&gt; &lt;input type=&quot;reset&quot; value=&quot;重置(重置按钮)&quot;&gt; &lt;/form&gt; &lt;!--表单结束--&gt;&lt;/fieldset&gt;&lt;/body&gt;&lt;/html&gt; 在服务器端使用getParameter方法和getParameterValues方法接收表单参数，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package qgx.request.study;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.text.MessageFormat;@WebServlet(name = &quot;RequestDemo3&quot;)public class RequestDemo3 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(&quot;UTF-8&quot;); String userid = request.getParameter(&quot;userid&quot;);//获取填写的编号 String username = request.getParameter(&quot;username&quot;); String userpass = request.getParameter(&quot;userpass&quot;); String sex = request.getParameter(&quot;sex&quot;);//获取选中的性别 String school = request.getParameter(&quot;school&quot;);//获取选中的学校 String[] insts = request.getParameterValues(&quot;inst&quot;); String note = request.getParameter(&quot;note&quot;);//获取填写的说明信息 String hiddenField = request.getParameter(&quot;hiddenField&quot;);//获取隐藏域的内容 String instStr = &quot;&quot;; /** * 获取数组数据的技巧，可以避免insts数组为null时引发的空指针异常错误！ */ for (int i = 0; insts != null &amp;&amp; i &lt; insts.length; i++) &#123; if (i == insts.length - 1) &#123; instStr += insts[i]; &#125; else &#123; instStr += insts[i] + &quot;,&quot;; &#125; &#125; String htmlStr = &quot;&lt;table&gt;&quot; + &quot;&lt;tr&gt;&lt;td&gt;填写的编号：&lt;/td&gt;&lt;td&gt;&#123;0&#125;&lt;/td&gt;&lt;/tr&gt;&quot; + &quot;&lt;tr&gt;&lt;td&gt;填写的用户名：&lt;/td&gt;&lt;td&gt;&#123;1&#125;&lt;/td&gt;&lt;/tr&gt;&quot; + &quot;&lt;tr&gt;&lt;td&gt;填写的密码：&lt;/td&gt;&lt;td&gt;&#123;2&#125;&lt;/td&gt;&lt;/tr&gt;&quot; + &quot;&lt;tr&gt;&lt;td&gt;选中的性别：&lt;/td&gt;&lt;td&gt;&#123;3&#125;&lt;/td&gt;&lt;/tr&gt;&quot; + &quot;&lt;tr&gt;&lt;td&gt;选中的学校：&lt;/td&gt;&lt;td&gt;&#123;4&#125;&lt;/td&gt;&lt;/tr&gt;&quot; + &quot;&lt;tr&gt;&lt;td&gt;选中的兴趣：&lt;/td&gt;&lt;td&gt;&#123;5&#125;&lt;/td&gt;&lt;/tr&gt;&quot; + &quot;&lt;tr&gt;&lt;td&gt;填写的说明：&lt;/td&gt;&lt;td&gt;&#123;6&#125;&lt;/td&gt;&lt;/tr&gt;&quot; + &quot;&lt;tr&gt;&lt;td&gt;隐藏域的内容：&lt;/td&gt;&lt;td&gt;&#123;7&#125;&lt;/td&gt;&lt;/tr&gt;&quot; + &quot;&lt;/table&gt;&quot;; htmlStr = MessageFormat.format(htmlStr, userid, username, userpass, sex, school, instStr, note, hiddenField); response.setCharacterEncoding(&quot;UTF-8&quot;);//设置服务器端以UTF-8编码输出数据到客户端 response.setContentType(&quot;text/html;charset=UTF-8&quot;);//设置客户端浏览器以UTF-8编码解析数据 response.getWriter().write(htmlStr);//输出htmlStr里面的内容到客户端浏览器显示 &#125;&#125; 在服务器端使用getParameterNames方法接收表单参数，代码如下：123456Enumeration&lt;String&gt; paramNames = request.getParameterNames();//获取所有的参数名 while (paramNames.hasMoreElements()) &#123; String name = paramNames.nextElement();//得到参数名 String value = request.getParameter(name);//通过参数名获取对应的值 System.out.println(MessageFormat.format(&quot;&#123;0&#125;=&#123;1&#125;&quot;, name,value)); &#125; 在服务器端使用getParameterMap方法接收表单参数，代码如下:1234567891011121314//request对象封装的参数是以Map的形式存储的 Map&lt;String, String[]&gt; paramMap = request.getParameterMap(); for(Map.Entry&lt;String, String[]&gt; entry :paramMap.entrySet())&#123; String paramName = entry.getKey(); String paramValue = &quot;&quot;; String[] paramValueArr = entry.getValue(); for (int i = 0; paramValueArr!=null &amp;&amp; i &lt; paramValueArr.length; i++) &#123; if (i == paramValueArr.length-1) &#123; paramValue+=paramValueArr[i]; &#125;else &#123; paramValue+=paramValueArr[i]+&quot;,&quot;; &#125; &#125; System.out.println(MessageFormat.format(&quot;&#123;0&#125;=&#123;1&#125;&quot;, paramName,paramValue)); &#125; 三、request接收表单提交中文参数乱码问题3.1、以POST方式提交表单中文参数的乱码问题index2.jsp12345678910111213141516171819&lt;%-- Created by IntelliJ IDEA. User: qgx Date: 2018/5/25 Time: 22:17 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;request接收中文参数乱码问题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&lt;%=request.getContextPath()%&gt;/RequestDemo4&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;post方式提交表单&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 服务器端接受代码和结果显示如下： 3.2、post方式提交中文数据乱码产生的原因和解决办法 之所以会产生乱码，就是因为服务器和客户端沟通的编码不一致造成的，因此解决的办法是：在客户端和服务器之间设置一个统一的编码，之后就按照此编码进行数据的传输和接收。 由于客户端是以UTF-8字符编码将表单数据传输到服务器端的，因此服务器也需要设置以UTF-8字符编码进行接收，要想完成此操作，服务器可以直接使用从ServletRequest接口继承而来的”setCharacterEncoding(charset)”方法进行统一的编码设置。修改后的代码如下： 12345protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(&quot;UTF-8&quot;); String username = request.getParameter(&quot;userName&quot;); System.out.println(&quot;userName&quot;+username); &#125; 3.3、以GET方式提交表单中文参数的乱码问题index3.jsp12345678910111213141516171819&lt;%-- Created by IntelliJ IDEA. User: qgx Date: 2018/5/25 Time: 22:17 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;request接收中文参数乱码问题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&lt;%=request.getContextPath()%&gt;/RequestDemo4&quot; method=&quot;get&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;Get方式提交表单&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 那么这个中文乱码问题又该如何解决呢，是否可以通过request.setCharacterEncoding(“UTF-8”);设置服务器以UTF-8的编码进行接收这种方式来解决中文乱码问题呢，注意，对于以get方式传输的中文数据，通过request.setCharacterEncoding(“UTF-8”);这种方式是解决不了中文乱码问题，如下所示： 3.4、get方式提交中文数据乱码产生的原因和解决办法对于以get方式传输的数据，request即使设置了以指定的编码接收数据也是无效的(至于为什么无效我也没有弄明白)，默认的还是使用ISO8859-1这个字符编码来接收数据，客户端以UTF-8的编码传输数据到服务器端，而服务器端的request对象使用的是ISO8859-1这个字符编码来接收数据，服务器和客户端沟通的编码不一致因此才会产生中文乱码的。解决办法：在接收到数据后，先获取request对象以ISO8859-1字符编码接收到的原始数据的字节数组，然后通过字节数组以指定的编码构建字符串，解决乱码问题。 3.5、以超链接形式传递中文参数的乱码问题 客户端想传输数据到服务器，可以通过表单提交的形式，也可以通过超链接后面加参数的形式，例如：1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/RequestDemo4?userName=&quot;刘俭梅&quot;&gt;点击&lt;/a&gt; 点击超链接，数据是以get的方式传输到服务器的，所以接收中文数据时也会产生中文乱码问题，而解决中文乱码问题的方式与上述的以get方式提交表单中文数据乱码处理问题的方式一致，如下所示： 1 String name = request.getParameter(“name”);2 name =new String(name.getBytes(“ISO8859-1”), “UTF-8”); 另外，需要提的一点就是URL地址后面如果跟了中文数据，那么中文参数最好使用URL编码进行处理，如下所示：11&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/RequestDemo4?userName=&lt;%=URLEncoder.encode(&quot;刘俭梅&quot;, &quot;UTF-8&quot;)%&gt;&quot;&gt;点击&lt;/a&gt; 3.6、提交中文数据乱码问题总结 1、如果提交方式为post，想不乱码，只需要在服务器端设置request对象的编码即可，客户端以哪种编码提交的，服务器端的request对象就以对应的编码接收，比如客户端是以UTF-8编码提交的，那么服务器端request对象就以UTF-8编码接收(request.setCharacterEncoding(“UTF-8”)) 2、如果提交方式为get，设置request对象的编码是无效的，request对象还是以默认的ISO8859-1编码接收数据，因此要想不乱码，只能在接收到数据后再手工转换，步骤如下： 1).获取获取客户端提交上来的数据，得到的是乱码字符串,data=”???è?????”String data = request.getParameter(“paramName”); 2).查找ISO8859-1码表，得到客户机提交的原始数据的字节数组 byte[] source = data.getBytes(“ISO8859-1”); 3).通过字节数组以指定的编码构建字符串，解决乱码 data = new String(source, “UTF-8”); 通过字节数组以指定的编码构建字符串，这里指定的编码是根据客户端那边提交数据时使用的字符编码来定的，如果是GB2312，那么就设置成data = new String(source, “GB2312”)，如果是UTF-8，那么就设置成data = new String(source, “UTF-8”)四、Request对象实现请求转发4.1、请求转发的基本概念请求转发：指一个web资源收到客户端请求后，通知服务器去调用另外一个web资源进行处理。请求转发的应用场景：MVC设计模式在Servlet中实现请求转发的两种方式： 1、通过ServletContext的getRequestDispatcher(String path)方法，该方法返回一个RequestDispatcher对象，调用这个对象的forward方法可以实现请求转发。例如：将请求转发的test.jsp页面12RequestDispatcher reqDispatcher =this.getServletContext().getRequestDispatcher(&quot;/test.jsp&quot;); reqDispatcher.forward(request, response); 2、通过request对象提供的getRequestDispatche(String path)方法，该方法返回一个RequestDispatcher对象，调用这个对象的forward方法可以实现请求转发。例如：将请求转发的test.jsp页面1request.getRequestDispatcher(&quot;/test.jsp&quot;).forward(request, response); request对象同时也是一个域对象(Map容器)，开发人员通过request对象在实现转发时，把数据通过request对象带给其它web资源处理。 例如：请求RequestDemo5 Servlet，RequestDemo5将请求转发到test.jsp页面RequestDemo512345678910111213141516171819202122232425package qgx.request.study;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = &quot;RequestDemo5&quot;)public class RequestDemo5 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String data = &quot;情不知所起，一往而情深&quot;; request.setAttribute(&quot;data&quot;, data); RequestDispatcher requestDispatcher = this.getServletContext().getRequestDispatcher(&quot;/test.jsp&quot;); requestDispatcher.forward(request, response);//request.setAttribute(&quot;data&quot;,data);//request.getRequestDispatcher(&quot;/test.jsp&quot;).forward(request,response); &#125;&#125; test.jsp12345678910111213141516171819&lt;%-- Created by IntelliJ IDEA. User: qgx Date: 2018/5/27 Time: 10:55 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Request对象实现请求转发&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 使用普通方式取出存储在request对象中的数据： &lt;h3 style=&quot;color:red;&quot;&gt;&lt;%=(String)request.getAttribute(&quot;data&quot;)%&gt;&lt;/h3&gt; 使用EL表达式取出存储在request对象中的数据： &lt;h3 style=&quot;color:red;&quot;&gt;$&#123;data&#125;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; request对象作为一个域对象(Map容器)使用时，主要是通过以下的四个方法来操作1234setAttribute(String name,Object o)方法，将数据作为request对象的一个属性存放到request对象中，例如：request.setAttribute(&quot;data&quot;, data);getAttribute(String name)方法，获取request对象的name属性的属性值，例如：request.getAttribute(&quot;data&quot;)removeAttribute(String name)方法，移除request对象的name属性，例如：request.removeAttribute(&quot;data&quot;)getAttributeNames方法，获取request对象的所有属性名，返回的是一个，例如：Enumeration&lt;String&gt; attrNames = request.getAttributeNames(); ####4.2、请求重定向和请求转发的区别 一个web资源收到客户端请求后，通知服务器去调用另外一个web资源进行处理，称之为请求转发/307。 一个web资源收到客户端请求后，通知浏览器去访问另外一个web资源进行处理，称之为请求重定向/302。","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://yoursite.com/categories/javaEE/"}],"tags":[{"name":"HttpServletRequest","slug":"HttpServletRequest","permalink":"http://yoursite.com/tags/HttpServletRequest/"}]},{"title":"我的第一个Android设计第二天","slug":"消息机制","date":"2018-07-20T04:10:37.821Z","updated":"2018-07-20T04:10:37.821Z","comments":true,"path":"2018/07/20/消息机制/","link":"","permalink":"http://yoursite.com/2018/07/20/消息机制/","excerpt":"","text":"Only the original thread that created a view hierarchy can touch its views主线程或者这里说的原始线程original thread 一般情况下是UI线程，当然UI线程并不一定是主线程，我们不能长时间的阻塞该应用举个栗子：12345678910111213141516171819202122final Handler cwjHandler = new Handler(); final Runnable mUpdateResults = new Runnable() &#123; public void run() &#123; updateUI(); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); NetworkOperation();//一个很费时间的I/O操作，比如网络或文件读写等等。 &#125; protected void NetworkOperation() &#123; Thread t = new Thread() &#123; public void run() &#123; doSomething(); //处理得到结果了，这里一些内容保存在主类的成员变量中 cwjHandler.post(mUpdateResults); //高速UI线程可以更新结果了 &#125; &#125;; t.start(); &#125; private void updateUI() &#123; //详细的更新 &#125; 在分析Android消息机制之前，我们先来看一段代码：1234567891011121314151617181920212223242526public class MainActivity extends Activity implements View.OnClickListener &#123; private TextView stateText; private Button btn; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); stateText = (TextView) findViewById(R.id.tv); btn = (Button) findViewById(R.id.btn); btn.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; new WorkThread().start(); &#125; //工作线程 private class WorkThread extends Thread &#123; @Override public void run() &#123; //......处理比较耗时的操作 //处理完成后改变状态 stateText.setText(&quot;completed&quot;); &#125; &#125; &#125; 这段代码似乎看上去很正常，但是当你运行时就会发现，它会报一个致命性的异常：123ERROR/AndroidRuntime(421): FATAL EXCEPTION: Thread-8 ERROR/AndroidRuntime(421): android.view.ViewRoot$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. 原因在于，Android系统中的视图组件并不是线程安全的，如果要更新视图，必须在主线程中更新，不可以在子线程中执行更新的操作。既然这样，我们就在子线程中通知主线程，让主线程来做更新操作。那么我们怎么通知主线程呢？我们就要用到Handler对象。我们修改一下上面的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MainActivity extends Activity implements View.OnClickListener &#123; private static final int COMPLETED = 0; private TextView stateText; private Button btn; private Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; if (msg.what == COMPLETED) &#123; stateText.setText(&quot;completed&quot;); &#125; &#125; &#125;; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); stateText = (TextView) findViewById(R.id.tv); btn = (Button) findViewById(R.id.btn); btn.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; new WorkThread().start(); &#125; //工作线程 private class WorkThread extends Thread &#123; @Override public void run() &#123; //......处理比较耗时的操作 //处理完成后给handler发送消息 Message msg = new Message(); msg.what = COMPLETED; handler.sendMessage(msg); &#125; &#125; &#125; 通过上面的这种方式，我们就可以解决线程安全问题，把复杂的任务处理工作交给子线程去完成，然后子线程通过handler对象告知主线程，由主线程更新视图，这个过程中消息机制起着重要的作用。下面我们来分析一下Android中的消息机制，熟悉Windows编程的应该知道Windows程序是消息驱动的，并且有全局的消息循环系统。Google 参考了Windows的消息循环机制，也在Android系统中实现了消息循环机制。Android通过Looper 、Handler 来实现消息循环机制。Android的消息循环是针对线程的，每个线程都可以有自己的消息队列和消息循环。Android系统中Looper.getMainLooper（）得到当前进程的主线程的Looper对象前面提到，Android的消息队列和消息循环都是针对具体线程的，一个线程可以存在一个消息队列和消息循环，特定线程的消息只能分发给本线程，不能跨线程和跨进程通讯。但是创建的工作线程默认是没有消息队列和消息循环的，如果想让工作线程具有消息队列和消息循环，就需要在线程中先调用Looper.prepare()来创建消息队列，然后调用Looper.loop()进入消息循环。下面是我们创建的工作线程：123456789101112131415class WorkThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare(); mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; // 处理收到的消息 &#125; &#125;; Looper.loop(); &#125; &#125; 这样一来，我们创建的工作线程就具有了消息处理机制了。 那么，为什么前边的示例中，我们怎么没有看到Looper.prepare()和Looper.loop()的调用呢？原因在于，我们的Activity是一个UI线程，运行在主线程中，Android系统会在Activity启动时为其创建一个消息队列和消息循环。前面提到最多的是消息队列(MessageQueue)和消息循环(Looper)，但是我们看到每个消息处理的地方都有Handler的存在，它是做什么的呢？Handler的作用是把消息加入特定的Looper所管理的消息队列中，并分发和处理该消息队列中的消息。构造Handler的时候可以指定一个Looper对象，如果不指定则利用当前线程的Looper对象创建。下面是Handler的两个构造方法：12345678910111213141516171819202122232425262728293031323334/** * Default constructor associates this handler with the queue for the * current thread. * * If there isn&apos;t one, this handler won&apos;t be able to receive messages. */ public Handler() &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; mCallback = null; &#125; /** * Use the provided queue instead of the default one. */ public Handler(Looper looper) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = null; &#125; 下面是消息机制中几个重要成员的关系图：一个Activity中可以创建出多个工作线程，如果这些线程把他们消息放入Activity主线程的消息队列中，那么消息就会在主线程中处理了。因为主线程一般负责视图组件的更新操作，对于不是线程安全的视图组件来说，这种方式能够很好的实现视图的更新。 那么，子线程如何把消息放入主线程的消息队列中呢？只要Handler对象以主线程的Looper创建，那么当调用Handler的sendMessage方法，系统就会把消息主线程的消息队列，并且将会在调用handleMessage方法时处理主线程消息队列中的消息。 对于子线程访问主线程的Handler对象，你可能会问，多个子线程都访问主线程的Handler对象，发送消息和处理消息的过程中会不会出现数据的不一致呢？答案是Handler对象不会出现问题，因为Handler对象管理的Looper对象是线程安全的，不管是添加消息到消息队列还是从消息队列中读取消息都是同步保护的，所以不会出现数据不一致现象","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android 课设","slug":"Android-课设","permalink":"http://yoursite.com/tags/Android-课设/"}]},{"title":"Spring Boot(一)","slug":"Spring Boot","date":"2018-07-20T04:10:37.821Z","updated":"2018-07-20T04:10:37.821Z","comments":true,"path":"2018/07/20/Spring Boot/","link":"","permalink":"http://yoursite.com/2018/07/20/Spring Boot/","excerpt":"","text":"Spring BootSpring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Boot致力于在蓬勃发展的快速应用开发领域（rapid application development）成为领导者。 Spring Boot的特点 创建独立的Spring应用程序 直接嵌入Tomcat，Jetty或Undertow，无需部署WAR文件 提供推荐的基础POM文件来简化Apache Maven配置 尽可能的根据项目依赖来自动配置Spring框架 提供生产就绪型功能，如指标，运行状况检查和外部配置 绝对没有代码生成和对XML没有要求配置 Spring Boot的优点spring boot可以支持开发人员快速的开发出restful风格的微服务架构；spring boot自动化确实方便，做微服务再合适不过了，单一jar包部署和管理都非常方便。只要系统架构设计合理，大型项目也能用，加上nginx负载均衡，轻松实现横向扩展；spring boot要解决的问题, 精简配置是一方面, 另外一方面是如何方便的让spring生态圈和其他工具链整合（比如Redis，email，elasticsearch）。 Spring Boot运行环境Spring Boot（2017-08-18）版本Spring Boot 1.5.6运行环境，Spring官方建议使用JDK1.8 Spring Boot使开发独立的，产品级别的基于Spring的应用变得非常简单，你只需”just run”。 为Spring平台及第三方库提供开箱即用的设置，这样就可以有条不紊地开始。多数Spring Boot应用需要很少的Spring配置。 使用Spring Boot创建Java应用，使用Spring启动或采用传统的war部署方式。Spring Boot提供了一个运行”Spring脚本”的命令行工具。Spring Boot推荐基础POM文件1234567891011121314151617181920spring-boot-starter 核心 POM，包含自动配置支持、日志库和对 YAML 配置文件的支持。spring-boot-starter-amqp 通过 spring-rabbit 支持 AMQP。spring-boot-starter-aop 包含 spring-aop 和 AspectJ 来支持面向切面编程（AOP）。spring-boot-starter-batch 支持 Spring Batch，包含 HSQLDB。spring-boot-starter-data-jpa 包含 spring-data-jpa、spring-orm 和 Hibernate 来支持 JPA。spring-boot-starter-data-mongodb 包含 spring-data-mongodb 来支持 MongoDB。spring-boot-starter-data-rest 通过 spring-data-rest-webmvc 支持以 REST 方式暴露 Spring Data 仓库。spring-boot-starter-jdbc 支持使用 JDBC 访问数据库。spring-boot-starter-security 包含 spring-security。spring-boot-starter-test 包含常用的测试所需的依赖，如 JUnit、Hamcrest、Mockito 和 spring-test 等。spring-boot-starter-velocity 支持使用 Velocity 作为模板引擎。spring-boot-starter-web 支持 Web 应用开发，包含 Tomcat 和 spring-mvc。spring-boot-starter-websocket 支持使用 Tomcat 开发 WebSocket 应用。spring-boot-starter-ws 支持 Spring Web Services。spring-boot-starter-actuator 添加适用于生产环境的功能，如性能指标和监测等功能。spring-boot-starter-remote-shell 添加远程 SSH 支持。spring-boot-starter-jetty 使用 Jetty 而不是默认的 Tomcat 作为应用服务器。spring-boot-starter-log4j 添加 Log4j 的支持。spring-boot-starter-logging 使用 Spring Boot 默认的日志框架 Logback。spring-boot-starter-tomcat 使用 Spring Boot 默认的 Tomcat 作为应用服务器。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"java 基础题(三)","slug":"Untitled22","date":"2018-07-20T04:10:37.821Z","updated":"2018-07-20T04:10:37.821Z","comments":true,"path":"2018/07/20/Untitled22/","link":"","permalink":"http://yoursite.com/2018/07/20/Untitled22/","excerpt":"","text":"21、ArrayList和Vector的区别 这两个类都实现了List接口（List接口继承了Collection接口），他们都是有序集合，即存储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引号取出某个元素，并且其中的数据是允许重复的，这是与HashSet之类的集合的最大不同处，HashSet之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素。 ArrayList与Vector的区别主要包括两个方面：. （1）同步性： Vector是线程安全的，也就是说是它的方法之间是线程同步的，而ArrayList是线程序不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是使用Vector，因为不需要我们自己再去考虑和编写线程安全的代码。 （2）数据增长： ArrayList与Vector都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加ArrayList与Vector的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。Vector默认增长为原来两倍，而ArrayList的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的1.5倍）。ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。 总结：即Vector增长原来的一倍，ArrayList增加原来的0.5倍。 22、HashMap和Hashtable的区别 HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，在只有一个线程访问的情况下，效率要高于Hashtable。 HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。 HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。 Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。 最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap就必须为之提供同步。 就HashMap与HashTable主要从三方面来说。 一.历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 二.同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 三.值：只有HashMap可以让你将空值作为一个表的条目的key或value 23、List和 Map区别? 一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合，List中存储的数据是有顺序，并且允许重复；Map中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的。 24、List,Set, Map是否继承自Collection接口? List，Set是，Map不是 25、List、Map、Set三个接口，存取元素时，各有什么特点？（这样的题比较考水平，两个方面的水平：一是要真正明白这些内容，二是要有较强的总结和表述能力。） 首先，List与Set具有相似性，它们都是单列元素的集合，所以，它们有一个共同的父接口，叫Collection。Set里面不允许有重复的元素，即不能有两个相等（注意，不是仅仅是相同）的对象，即假设Set集合中有了一个A对象，现在我要向Set集合再存入一个B对象，但B对象与A对象equals相等，则B对象存储不进去，所以，Set集合的add方法有一个boolean的返回值，当集合中没有某个元素，此时add方法可成功加入该元素时，则返回true，当集合含有与某个元素equals相等的元素时，此时add方法无法加入该元素，返回结果为false。Set取元素时，不能细说要取第几个，只能以Iterator接口取得所有的元素，再逐一遍历各个元素。 List表示有先后顺序的集合，注意，不是那种按年龄、按大小、按价格之类的排序。当我们多次调用add(Obje)方法时，每次加入的对象就像火车站买票有排队顺序一样，按先来后到的顺序排序。有时候，也可以插队，即调用add(intindex,Obj e)方法，就可以指定当前对象在集合中的存放位置。一个对象可以被反复存储进List中，每调用一次add方法，这个对象就被插入进集合中一次，其实，并不是把这个对象本身存储进了集合中，而是在集合中用一个索引变量指向这个对象，当这个对象被add多次时，即相当于集合中有多个索引指向了这个对象，如图x所示。List除了可以用Iterator接口取得所有的元素，再逐一遍历各个元素之外，还可以调用get(index i)来明确说明取第几个。 Map与List和Set不同，它是双列的集合，其中有put方法，定义如下：put(obj key,obj value)，每次存储时，要存储一对key/value，不能存储重复的key，这个重复的规则也是按equals比较相等。取则可以根据key获得相应的value，即get(Object key)返回值为key所对应的value。另外，也可以获得所有的key的结合，还可以获得所有的value的结合，还可以获得key和value组合成的Map.Entry对象的集合。 List以特定次序来持有元素，可有重复元素。Set无法拥有重复元素,内部排序。Map保存key-value值，value可多值。 26、说出ArrayList,Vector,LinkedList的存储性能和特性 ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差。而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，索引就变慢了，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。 LinkedList也是线程不安全的，LinkedList提供了一些方法，使得LinkedList可以被当作堆栈和队列来使用。 27、去掉一个Vector集合中重复的元素Vector newVector = new Vector();For (int i=0;i&lt;vector.size();i++){Object obj = vector.get(i); if(!newVector.contains(obj); newVector.add(obj); }还有一种简单的方式，利用了Set不允许重复元素：HashSetset = new HashSet(vector); 28、Collection和Collections的区别。 Collection是集合类的上级接口，继承他的接口主要有Set和List. Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。 29、Set里的元素是不能重复的，那么用什么方法来区分重复与否呢?是用==还是equals()?它们有何区别? Set里的元素是不能重复的，元素重复与否是使用equals()方法进行判断的。 ==和equal区别也是考烂了的题，这里说一下：==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符。 equals方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较的两个对象是独立的。 比如：两条new语句创建了两个对象，然后用a/b这两个变量分别指向了其中一个对象，这是两个不同的对象，它们的首地址是不同的，即a和b中存储的数值是不相同的，所以，表达式a==b将返回false，而这两个对象中的内容是相同的，所以，表达式a.equals(b)将返回true。 30、你所知道的集合类都有哪些？主要方法？ 最常用的集合类是 List 和 Map。 List的具体实现包括 ArrayList和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。 List适用于按数值索引访问元素的情形。 Map 提供了一个更通用的元素存储方法。 Map集合类用于存储元素对（称作&quot;键&quot;和&quot;值&quot;），其中每个键映射到一个值。 它们都有增删改查的方法。 对于set，大概的方法是add,remove, contains等 对于map，大概的方法就是put,remove，contains等 List类会有get(int index)这样的方法，因为它可以按顺序取元素，而set类中没有get(int index)这样的方法。List和set都可以迭代出所有元素，迭代时先要得到一个iterator对象，所以，set和list类都有一个iterator方法，用于返回那个iterator对象。map可以返回三个集合，一个是返回所有的key的集合，另外一个返回的是所有value的集合，再一个返回的key和value组合成的EntrySet对象的集合，map也有get方法，参数是key，返回值是key对应的value","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java题","slug":"java题","permalink":"http://yoursite.com/tags/java题/"}]},{"title":"java 基础知识","slug":"1、IO流概述","date":"2018-07-20T04:10:37.821Z","updated":"2018-07-20T04:10:37.821Z","comments":true,"path":"2018/07/20/1、IO流概述/","link":"","permalink":"http://yoursite.com/2018/07/20/1、IO流概述/","excerpt":"","text":"1、IO流概述 (1)用来处理设备(硬盘，控制台，内存)间的数据。 (2)java中对数据的操作都是通过流的方式。 (3)java用于操作流的类都在io包中。 (4)按照流操作的数据的类型不同：分为字节流和字符流。字符流是为了方便中文的操作而来的。 (5)按照流的流向不同分为：输入流，输出流 2、IO流常用基类：(1)字节流输出字节流：OutputStream：字节写入流抽象类 |—&gt;FileOutputStream：字节写入流|—&gt;BufferedOutputStream： 字节写入流缓冲区|—&gt;PrintStream： 打印流输入字节流：InputStream：字节读取流抽象类 |—&gt;FileInputStream：字节读取流 |—&gt;BufferedInputStream：字节读取流缓冲区 (2)字符流输出字符流：Writer：字符写入流的抽象|—&gt;FileWriter：字符写入流 |—&gt;BufferedWriter：字符写入流缓冲区 |—&gt;OutputStreamWriter：字符通向字节的转换流(涉及键盘录入时用) |—&gt;OutputStreamWriter：打印流，可处理各种类型的数据 输入字符流：Reader: 字符读取流的抽象类 |—&gt;FileReader：字符读取流|—&gt;LineNumberReader： 跟踪行号的缓冲字符读取流|—&gt;BufferedReader：字符读取流缓冲区 |—&gt;InputStreamReader：字节通向字符的转换流(涉及键盘录入时用) (3)IO流常用基类方法摘要：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354字节写入流：OutputStream：void close() 关闭此输出流并释放与此流有关的所有系统资源。void flush()刷新此输出流并强制写出所有缓冲的输出字节。abstract void write(int b) 将指定的字节写入此输出流。void write(byte[] b) 将 b.length 个字节从指定的 byte 数组写入此输出流。 void write(byte[] b, int off, int len) 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。 字节读取流：InputStream：void close() 关闭此输入流并释放与该流关联的所有系统资源。int available() (特有方法！！)返回此输入流下一个方法调用可以不受阻塞地从此输入流读取（或跳过）的估计字节数。 abstract int read() 从输入流中读取数据的下一个字节。 int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。int read(byte[] b, int off, int len) 将输入流中最多 len 个数据字节读入 byte 数组。long skip(long n) 跳过和丢弃此输入流中数据的 n 个字节。 字符写入流：Writer：abstract void close() 关闭此流，但要先刷新它。abstract void flush() 刷新该流的缓冲。void write(int c) 写入单个字符。void write(char[] cbuf) 写入字符数组。 abstract void write(char[] cbuf, int off, int len) 写入字符数组的某一部分。 void write(String str) 写入字符串。 void write(String str, int off, int len) 写入字符串的某一部分。 字符读取流：Reader：abstract void close() 关闭该流并释放与之关联的所有资源。int read() 读取单个字符。int read(char[] cbuf) 将字符读入数组abstract int read(char[] cbuf, int off, int len) 将字符读入数组的某一部分。long skip(long n) 跳过字符。 3、IO流常用字节流基类的子类：写入流： (1)FileOutputStream：构造方法： FileOutputStream(String name) 创建一个向具有指定名称的文件中写入数据的输出文件流。 FileOutputStream(String name, boolean append) 创建一个向具有指定 name 的文件中写入数据的输出文件流。 FileOutputStream(File file) 创建一个向指定 File 对象表示的文件中写入数据的文件输出流。 FileOutputStream(File file, boolean append) 创建一个向指定 File 对象表示的文件中写入数据的文件输出流。 方法摘要：1234567891011public void flush()void close() 关闭此文件输出流并释放与此流有关的所有系统资源。void write(int b) 将指定字节写入此文件输出流。void write(byte[] b, int off, int len) 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此文件输出流。 void write(int b) 将指定字节写入此文件输出流。 (2)BufferedOutputStream：构造方法：BufferedOutputStream(OutputStream out) 创建一个新的缓冲输出流，以将数据写入指定的底层输出流。 BufferedOutputStream(OutputStream out, int size) 创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。 方法摘要：12345void flush() 刷新此缓冲的输出流。 void write(byte[] b, int off, int len) 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此缓冲的输出流。 void write(int b) 将指定的字节写入此缓冲的输出流。 (3)PrintStream：打印流，可将各种类型的数据原样打印，有自动刷新功能构造方法： PrintStream(String fileName)创建具有指定文件名称且不带自动行刷新的新打印流。 PrintStream(File file) 创建具有指定文件且不带自动行刷新的新打印流。PrintStream(OutputStream out) 创建新的打印流。 PrintStream(OutputStream out, boolean autoFlush) (当autoFlush为true时具有自动刷新功能)创建新的打印流。 方法摘要：1234PrintStream append(char c) 将指定字符添加到此输出流。void close() 关闭流。 void flush() 刷新该流的缓冲。void print(各种类型的数据：) 打印各种类型的数据 void println(各种类型的数据：)：自动换行打印各种类型的数据 void write(byte[] buf, int off, int len) 将 len 字节从指定的初始偏移量为 off 的 byte 数组写入此流。 void write(int b) 将指定的字节写入此流。 读取流：(1)FileInputStream：构造方法：FileInputStream(String name) 通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的路径名 name 指定。FileInputStream(File file) 通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的 File 对象 file 指定。 方法摘要：12int available() (字节读取流特有方法！！！)返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取（或跳过）的估计剩余字节数。int read() 从此输入流中读取一个数据字节。 int read(byte[] b) 从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。 int read(byte[] b, int off, int len) 从此输入流中将最多 len 个字节的数据读入一个 byte 数组中。 long skip(long n) 从输入流中跳过并丢弃 n 个字节的数据。 (2)BufferedInputStream:构造方法：BufferedInputStream(InputStream in) 创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。 BufferedInputStream(InputStream in, int size)创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。 方法摘要：12int available() (字节读取流特有方法！！！)返回可以从此输入流读取（或跳过）、且不受此输入流接下来的方法调用阻塞的估计字节数。 int read() 参见 InputStream 的 read 方法的常规协定。 int read(byte[] b, int off, int len) 从此字节输入流中给定偏移量处开始将各字节读取到指定的 byte 数组中。 long skip(long n) 参见 InputStream 的 skip 方法的常规协定。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"IO流","slug":"IO流","permalink":"http://yoursite.com/tags/IO流/"}]},{"title":"Android ListView联动","slug":"ListView联动（二）","date":"2018-07-20T04:10:37.821Z","updated":"2018-07-20T04:10:37.817Z","comments":true,"path":"2018/07/20/ListView联动（二）/","link":"","permalink":"http://yoursite.com/2018/07/20/ListView联动（二）/","excerpt":"","text":"ListView联动（二）双ListView分为左侧ListView和右侧ListView，通过左侧ListView的点击来定位右侧ListView的位置，通过右侧ListView的滑动来定位左侧ListView的选中位置。左侧ListView我们直接使用原生ListView即可，右侧ListView由于需要头部标题和滑动监听，我们自己定义一个ListView，来设置下滑动事件的监听和头部标题。实现双ListView联动最关键的一点就是这个自定义ListView，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205package com.example.qgx.gouwuche;import android.content.Context;import android.graphics.Canvas;import android.util.AttributeSet;import android.view.View;import android.view.ViewGroup;import android.widget.AbsListView;import android.widget.AbsListView.OnScrollListener;import android.widget.AdapterView;import android.widget.HeaderViewListAdapter;import android.widget.ListAdapter;import android.widget.ListView;public class PinnedHeaderListView extends ListView implements OnScrollListener &#123; private OnScrollListener mOnScrollListener; public static interface PinnedSectionedHeaderAdapter &#123; public boolean isSectionHeader(int position); public int getSectionForPosition(int position); public View getSectionHeaderView(int section, View convertView, ViewGroup parent); public int getSectionHeaderViewType(int section); public int getCount(); &#125; private PinnedSectionedHeaderAdapter mAdapter; private View mCurrentHeader; private int mCurrentHeaderViewType = 0; private float mHeaderOffset; private boolean mShouldPin = true; private int mCurrentSection = 0; private int mWidthMode; private int mHeightMode; public PinnedHeaderListView(Context context) &#123; super(context); super.setOnScrollListener(this); &#125; public PinnedHeaderListView(Context context, AttributeSet attrs) &#123; super(context, attrs); super.setOnScrollListener(this); &#125; public PinnedHeaderListView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); super.setOnScrollListener(this); &#125; public void setPinHeaders(boolean shouldPin) &#123; mShouldPin = shouldPin; &#125; @Override public void setAdapter(ListAdapter adapter) &#123; mCurrentHeader = null; mAdapter = (PinnedSectionedHeaderAdapter) adapter; super.setAdapter(adapter); &#125; @Override public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) &#123; if (mOnScrollListener != null) &#123; mOnScrollListener.onScroll(view, firstVisibleItem, visibleItemCount, totalItemCount); &#125; if (mAdapter == null || mAdapter.getCount() == 0 || !mShouldPin || (firstVisibleItem &lt; getHeaderViewsCount())) &#123; mCurrentHeader = null; mHeaderOffset = 0.0f; for (int i = firstVisibleItem; i &lt; firstVisibleItem + visibleItemCount; i++) &#123; View header = getChildAt(i); if (header != null) &#123; header.setVisibility(VISIBLE); &#125; &#125; return; &#125; firstVisibleItem -= getHeaderViewsCount(); int section = mAdapter.getSectionForPosition(firstVisibleItem); int viewType = mAdapter.getSectionHeaderViewType(section); mCurrentHeader = getSectionHeaderView(section, mCurrentHeaderViewType != viewType ? null : mCurrentHeader); ensurePinnedHeaderLayout(mCurrentHeader); mCurrentHeaderViewType = viewType; mHeaderOffset = 0.0f; for (int i = firstVisibleItem; i &lt; firstVisibleItem + visibleItemCount; i++) &#123; if (mAdapter.isSectionHeader(i)) &#123; View header = getChildAt(i - firstVisibleItem); float headerTop = header.getTop(); float pinnedHeaderHeight = mCurrentHeader.getMeasuredHeight(); header.setVisibility(VISIBLE); if (pinnedHeaderHeight &gt;= headerTop &amp;&amp; headerTop &gt; 0) &#123; mHeaderOffset = headerTop - header.getHeight(); &#125; else if (headerTop &lt;= 0) &#123; header.setVisibility(INVISIBLE); &#125; &#125; &#125; invalidate(); &#125; @Override public void onScrollStateChanged(AbsListView view, int scrollState) &#123; if (mOnScrollListener != null) &#123; mOnScrollListener.onScrollStateChanged(view, scrollState); &#125; &#125; private View getSectionHeaderView(int section, View oldView) &#123; boolean shouldLayout = section != mCurrentSection || oldView == null; View view = mAdapter.getSectionHeaderView(section, oldView, this); if (shouldLayout) &#123; // a new section, thus a new header. We should lay it out again ensurePinnedHeaderLayout(view); mCurrentSection = section; &#125; return view; &#125; private void ensurePinnedHeaderLayout(View header) &#123; if (header.isLayoutRequested()) &#123; int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), mWidthMode); int heightSpec; ViewGroup.LayoutParams layoutParams = header.getLayoutParams(); if (layoutParams != null &amp;&amp; layoutParams.height &gt; 0) &#123; heightSpec = MeasureSpec.makeMeasureSpec(layoutParams.height, MeasureSpec.EXACTLY); &#125; else &#123; heightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED); &#125; header.measure(widthSpec, heightSpec); header.layout(0, 0, header.getMeasuredWidth(), header.getMeasuredHeight()); &#125; &#125; @Override protected void dispatchDraw(Canvas canvas) &#123; super.dispatchDraw(canvas); if (mAdapter == null || !mShouldPin || mCurrentHeader == null) return; int saveCount = canvas.save(); canvas.translate(0, mHeaderOffset); canvas.clipRect(0, 0, getWidth(), mCurrentHeader.getMeasuredHeight()); // needed // for // &lt; // HONEYCOMB mCurrentHeader.draw(canvas); canvas.restoreToCount(saveCount); &#125; @Override public void setOnScrollListener(OnScrollListener l) &#123; mOnScrollListener = l; &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); mWidthMode = MeasureSpec.getMode(widthMeasureSpec); mHeightMode = MeasureSpec.getMode(heightMeasureSpec); &#125; public void setOnItemClickListener(OnItemClickListener listener) &#123; super.setOnItemClickListener(listener); &#125; public static abstract class OnItemClickListener implements AdapterView.OnItemClickListener &#123; @Override public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int rawPosition, long id) &#123; SectionedBaseAdapter adapter; if (adapterView.getAdapter().getClass().equals(HeaderViewListAdapter.class)) &#123; HeaderViewListAdapter wrapperAdapter = (HeaderViewListAdapter) adapterView.getAdapter(); adapter = (SectionedBaseAdapter) wrapperAdapter.getWrappedAdapter(); &#125; else &#123; adapter = (SectionedBaseAdapter) adapterView.getAdapter(); &#125; int section = adapter.getSectionForPosition(rawPosition); int position = adapter.getPositionInSectionForPosition(rawPosition); if (position == -1) &#123; onSectionClick(adapterView, view, section, id); &#125; else &#123; onItemClick(adapterView, view, section, position, id); &#125; &#125; public abstract void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int section, int position, long id); public abstract void onSectionClick(AdapterView&lt;?&gt; adapterView, View view, int section, long id); &#125;&#125; 然后为PinnedHeaderListView定义Adapter，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209package com.example.qgx.gouwuche;import android.util.SparseArray;import android.view.View;import android.view.ViewGroup;import android.widget.BaseAdapter;public abstract class SectionedBaseAdapter extends BaseAdapter implements PinnedHeaderListView.PinnedSectionedHeaderAdapter &#123; private static int HEADER_VIEW_TYPE = 0; private static int ITEM_VIEW_TYPE = 0; /** * Holds the calculated values of @&#123;link getPositionInSectionForPosition&#125; */ private SparseArray&lt;Integer&gt; mSectionPositionCache; /** * Holds the calculated values of @&#123;link getSectionForPosition&#125; */ private SparseArray&lt;Integer&gt; mSectionCache; /** * Holds the calculated values of @&#123;link getCountForSection&#125; */ private SparseArray&lt;Integer&gt; mSectionCountCache; /** * Caches the item count */ private int mCount; /** * Caches the section count */ private int mSectionCount; public SectionedBaseAdapter() &#123; super(); mSectionCache = new SparseArray&lt;Integer&gt;(); mSectionPositionCache = new SparseArray&lt;Integer&gt;(); mSectionCountCache = new SparseArray&lt;Integer&gt;(); mCount = -1; mSectionCount = -1; &#125; @Override public void notifyDataSetChanged() &#123; mSectionCache.clear(); mSectionPositionCache.clear(); mSectionCountCache.clear(); mCount = -1; mSectionCount = -1; super.notifyDataSetChanged(); &#125; @Override public void notifyDataSetInvalidated() &#123; mSectionCache.clear(); mSectionPositionCache.clear(); mSectionCountCache.clear(); mCount = -1; mSectionCount = -1; super.notifyDataSetInvalidated(); &#125; @Override public final int getCount() &#123; if (mCount &gt;= 0) &#123; return mCount; &#125; int count = 0; for (int i = 0; i &lt; internalGetSectionCount(); i++) &#123; count += internalGetCountForSection(i); count++; // for the header view &#125; mCount = count; return count; &#125; @Override public final Object getItem(int position) &#123; return getItem(getSectionForPosition(position), getPositionInSectionForPosition(position)); &#125; @Override public final long getItemId(int position) &#123; return getItemId(getSectionForPosition(position), getPositionInSectionForPosition(position)); &#125; @Override public final View getView(int position, View convertView, ViewGroup parent) &#123; if (isSectionHeader(position)) &#123; return getSectionHeaderView(getSectionForPosition(position), convertView, parent); &#125; return getItemView(getSectionForPosition(position), getPositionInSectionForPosition(position), convertView, parent); &#125; @Override public final int getItemViewType(int position) &#123; if (isSectionHeader(position)) &#123; return getItemViewTypeCount() + getSectionHeaderViewType(getSectionForPosition(position)); &#125; return getItemViewType(getSectionForPosition(position), getPositionInSectionForPosition(position)); &#125; @Override public final int getViewTypeCount() &#123; return getItemViewTypeCount() + getSectionHeaderViewTypeCount(); &#125; public final int getSectionForPosition(int position) &#123; // first try to retrieve values from cache Integer cachedSection = mSectionCache.get(position); if (cachedSection != null) &#123; return cachedSection; &#125; int sectionStart = 0; for (int i = 0; i &lt; internalGetSectionCount(); i++) &#123; int sectionCount = internalGetCountForSection(i); int sectionEnd = sectionStart + sectionCount + 1; if (position &gt;= sectionStart &amp;&amp; position &lt; sectionEnd) &#123; mSectionCache.put(position, i); return i; &#125; sectionStart = sectionEnd; &#125; return 0; &#125; public int getPositionInSectionForPosition(int position) &#123; // first try to retrieve values from cache Integer cachedPosition = mSectionPositionCache.get(position); if (cachedPosition != null) &#123; return cachedPosition; &#125; int sectionStart = 0; for (int i = 0; i &lt; internalGetSectionCount(); i++) &#123; int sectionCount = internalGetCountForSection(i); int sectionEnd = sectionStart + sectionCount + 1; if (position &gt;= sectionStart &amp;&amp; position &lt; sectionEnd) &#123; int positionInSection = position - sectionStart - 1; mSectionPositionCache.put(position, positionInSection); return positionInSection; &#125; sectionStart = sectionEnd; &#125; return 0; &#125; public final boolean isSectionHeader(int position) &#123; int sectionStart = 0; for (int i = 0; i &lt; internalGetSectionCount(); i++) &#123; if (position == sectionStart) &#123; return true; &#125; else if (position &lt; sectionStart) &#123; return false; &#125; sectionStart += internalGetCountForSection(i) + 1; &#125; return false; &#125; public int getItemViewType(int section, int position) &#123; return ITEM_VIEW_TYPE; &#125; public int getItemViewTypeCount() &#123; return 1; &#125; public int getSectionHeaderViewType(int section) &#123; return HEADER_VIEW_TYPE; &#125; public int getSectionHeaderViewTypeCount() &#123; return 1; &#125; public abstract Object getItem(int section, int position); public abstract long getItemId(int section, int position); public abstract int getSectionCount(); public abstract int getCountForSection(int section); public abstract View getItemView(int section, int position, View convertView, ViewGroup parent); public abstract View getSectionHeaderView(int section, View convertView, ViewGroup parent); private int internalGetCountForSection(int section) &#123; Integer cachedSectionCount = mSectionCountCache.get(section); if (cachedSectionCount != null) &#123; return cachedSectionCount; &#125; int sectionCount = getCountForSection(section); mSectionCountCache.put(section, sectionCount); return sectionCount; &#125; private int internalGetSectionCount() &#123; if (mSectionCount &gt;= 0) &#123; return mSectionCount; &#125; mSectionCount = getSectionCount(); return mSectionCount; &#125;&#125; 这样我们就可以使用PinnedHeaderListView了，新建MainActivity,在布局文件中创建两个ListView。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153package com.example.qgx.gouwuche;import android.content.Context;import android.content.Intent;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.AttributeSet;import android.util.Log;import android.view.View;import android.widget.AbsListView;import android.widget.AdapterView;import android.widget.ListView;import com.example.qgx.gouwuche.mohu.BlurBehind;import com.example.qgx.gouwuche.mohu.OnBlurCompleteListener;public class MainActivity extends AppCompatActivity &#123; ListView leftListview; PinnedHeaderListView pinnedListView; private boolean isScroll = true; private LeftListAdapter adapter; private String[] a = new String[100]; private String[] leftStr = new String[]&#123;&quot;面食类&quot;, &quot;盖饭&quot;, &quot;寿司&quot;, &quot;烧烤&quot;, &quot;酒水&quot;, &quot;凉菜&quot;, &quot;小吃&quot;, &quot;粥&quot;, &quot;休闲&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;&#125;; private boolean[] flagArray = &#123;true, false, false, false, false, false, false, false, false, false, false, false&#125;; private String[][] rightStr = new String[][]&#123;&#123;&quot;热干面&quot;, &quot;臊子面&quot;, &quot;烩面&quot;&#125;, &#123;&quot;番茄鸡蛋&quot;, &quot;红烧排骨&quot;, &quot;农家小炒肉&quot;&#125;, &#123;&quot;芝士&quot;, &quot;丑小丫&quot;, &quot;金枪鱼&quot;&#125;, &#123;&quot;羊肉串&quot;, &quot;烤鸡翅&quot;, &quot;烤羊排&quot;&#125;, &#123;&quot;长城干红&quot;, &quot;燕京鲜啤&quot;, &quot;青岛鲜啤&quot;&#125;, &#123;&quot;拌粉丝&quot;, &quot;大拌菜&quot;, &quot;菠菜花生&quot;&#125;, &#123;&quot;小食组&quot;, &quot;紫薯&quot;&#125;, &#123;&quot;小米粥&quot;, &quot;大米粥&quot;, &quot;南瓜粥&quot;, &quot;玉米粥&quot;, &quot;紫米粥&quot;&#125;, &#123;&quot;儿童小汽车&quot;, &quot;悠悠球&quot;, &quot;熊大&quot;, &quot; 熊二&quot;, &quot;光头强&quot;&#125;,&#123;&quot;热干面&quot;, &quot;臊子面&quot;, &quot;烩面&quot;&#125;, &#123;&quot;番茄鸡蛋&quot;, &quot;红烧排骨&quot;, &quot;农家小炒肉&quot;&#125;, &#123;&quot;芝士&quot;, &quot;丑小丫&quot;, &quot;金枪鱼&quot;&#125; &#125;; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); leftListview =findViewById(R.id.left_listview); pinnedListView = (PinnedHeaderListView) findViewById(R.id.pinnedListView); final MainSectionedAdapter sectionedAdapter = new MainSectionedAdapter(this, leftStr, rightStr, a); pinnedListView.setAdapter(sectionedAdapter); adapter = new LeftListAdapter(this, leftStr, flagArray); leftListview.setAdapter(adapter); leftListview.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; arg0, View view, int position, long arg3) &#123; //String[] a = sectionedAdapter.getA();// Log.i(&quot;123&quot;, &quot;onCreate: &quot;+a[0]+a[1]+a[2]); isScroll = false; for (int i = 0; i &lt; leftStr.length; i++) &#123; if (i == position) &#123; flagArray[i] = true; &#125; else &#123; flagArray[i] = false; &#125; &#125; adapter.notifyDataSetChanged(); int rightSection = 0; for (int i = 0; i &lt; position; i++) &#123; rightSection += sectionedAdapter.getCountForSection(i) + 1; &#125; pinnedListView.setSelection(rightSection); &#125; &#125;); pinnedListView.setOnScrollListener(new AbsListView.OnScrollListener() &#123; @Override public void onScrollStateChanged(AbsListView arg0, int scrollState) &#123; switch (scrollState) &#123; // 当不滚动时 case AbsListView.OnScrollListener.SCROLL_STATE_IDLE: // 判断滚动到底部 if (pinnedListView.getLastVisiblePosition() == (pinnedListView.getCount() - 1)) &#123; leftListview.setSelection(ListView.FOCUS_DOWN); &#125; // 判断滚动到顶部 if (pinnedListView.getFirstVisiblePosition() == 0) &#123; leftListview.setSelection(0); &#125; break; &#125; &#125; int y = 0; int x = 0; int z = 0; @Override public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) &#123; if (isScroll) &#123; for (int i = 0; i &lt; rightStr.length; i++) &#123; if (i == sectionedAdapter.getSectionForPosition(pinnedListView.getFirstVisiblePosition())) &#123; flagArray[i] = true; x = i; &#125; else &#123; flagArray[i] = false; &#125; &#125; if (x != y) &#123; adapter.notifyDataSetChanged(); y = x; if (y == leftListview.getLastVisiblePosition()) &#123;// z = z + 3; leftListview.setSelection(z); &#125; if (x == leftListview.getFirstVisiblePosition()) &#123;// z = z - 1; leftListview.setSelection(z); &#125; if (firstVisibleItem + visibleItemCount == totalItemCount - 1) &#123; leftListview.setSelection(ListView.FOCUS_DOWN); &#125; &#125; &#125; else &#123; isScroll = true; &#125; &#125; &#125;); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); &#125; public void zongjie(View view) &#123; BlurBehind.getInstance().execute(MainActivity.this, new OnBlurCompleteListener() &#123; @Override public void onBlurComplete() &#123; Intent intent = new Intent(MainActivity.this,gouwucheActivity.class); Bundle b=new Bundle(); b.putStringArray(&quot;A&quot;, a); intent.putExtras(b); startActivity(intent); &#125; &#125;); &#125;&#125; MainActivity的布局文件如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#606364&quot; android:orientation=&quot;vertical&quot;&gt;&lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;460dp&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;ListView android:id=&quot;@+id/left_listview&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;2&quot; android:scrollbars=&quot;none&quot; android:divider=&quot;@null&quot;&gt; &lt;/ListView&gt; &lt;com.example.qgx.gouwuche.PinnedHeaderListView android:id=&quot;@+id/pinnedListView&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_weight=&quot;5&quot; android:background=&quot;@android:color/white&quot;&gt; &lt;/com.example.qgx.gouwuche.PinnedHeaderListView&gt;&lt;/LinearLayout&gt; &lt;RelativeLayout android:id=&quot;@+id/car_rl&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:layout_gravity=&quot;bottom&quot; android:background=&quot;#454545&quot;&gt; &lt;TextView android:id=&quot;@+id/car_nonselect&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginLeft=&quot;80dp&quot; android:text=&quot;未选购商品&quot; android:textColor=&quot;#a8a8a8&quot; android:textSize=&quot;13sp&quot; android:textStyle=&quot;bold&quot;/&gt; &lt;LinearLayout android:id=&quot;@+id/amount_container&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginLeft=&quot;80dp&quot; android:gravity=&quot;center_vertical&quot; android:orientation=&quot;vertical&quot; android:visibility=&quot;gone&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_amount&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;#fff&quot; android:textSize=&quot;18sp&quot; android:textStyle=&quot;bold&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;另需配送费¥4元&quot; android:textColor=&quot;#fff&quot; android:textSize=&quot;10sp&quot;/&gt; &lt;/LinearLayout&gt; &lt;TextView android:id=&quot;@+id/car_limit&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:layout_alignParentRight=&quot;true&quot; android:background=&quot;#535353&quot; android:gravity=&quot;center&quot; android:paddingLeft=&quot;8dp&quot; android:paddingRight=&quot;8dp&quot; android:text=&quot;确认下单&quot; android:textColor=&quot;#a8a8a8&quot; android:textSize=&quot;16sp&quot; android:textStyle=&quot;bold&quot;/&gt; &lt;ImageView android:id=&quot;@+id/iv_shop_car&quot; android:onClick=&quot;zongjie&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginBottom=&quot;8dp&quot; android:layout_marginLeft=&quot;-50dp&quot; android:src=&quot;@drawable/shop_car_empty&quot;/&gt; &lt;/RelativeLayout&gt;&lt;/LinearLayout&gt; 分别为左侧ListView和右侧ListView创建Adapter。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.example.qgx.gouwuche;import android.content.Context;import android.graphics.Color;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.BaseAdapter;import android.widget.TextView;/** * 基本功能：左侧Adapter * 创建：王杰 * 创建时间：16/4/14 * 邮箱：w489657152@gmail.com */public class LeftListAdapter extends BaseAdapter &#123; private String[] leftStr; boolean[] flagArray; private Context context; public LeftListAdapter(Context context, String[] leftStr, boolean[] flagArray) &#123; this.leftStr = leftStr; this.context = context; this.flagArray = flagArray; &#125; @Override public int getCount() &#123; return leftStr.length; &#125; @Override public Object getItem(int arg0) &#123; return leftStr[arg0]; &#125; @Override public long getItemId(int arg0) &#123; return arg0; &#125; @Override public View getView(int arg0, View arg1, ViewGroup arg2) &#123; Holder holder = null; if (arg1 == null) &#123; holder = new Holder(); arg1 = LayoutInflater.from(context).inflate(R.layout.left_list_item, null); holder.left_list_item = (TextView) arg1.findViewById(R.id.left_list_item); arg1.setTag(holder); &#125; else &#123; holder = (Holder) arg1.getTag(); &#125; holder.updataView(arg0); return arg1; &#125; private class Holder &#123; private TextView left_list_item; public void updataView(final int position) &#123; left_list_item.setText(leftStr[position]); if (flagArray[position]) &#123; left_list_item.setBackgroundColor(Color.rgb(255, 255, 255)); &#125; else &#123; left_list_item.setBackgroundColor(Color.TRANSPARENT); &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package com.example.qgx.gouwuche;import android.content.Context;import android.util.Log;import android.view.LayoutInflater;import android.view.View;import android.view.View.OnClickListener;import android.view.ViewGroup;import android.widget.Button;import android.widget.LinearLayout;import android.widget.RelativeLayout;import android.widget.TextView;import android.widget.Toast;public class MainSectionedAdapter extends SectionedBaseAdapter &#123; private Context mContext; private String[] leftStr; private String[][] rightStr; private int count1=0; private int[][] count= new int[100][100]; private String[] a = new String[100]; public MainSectionedAdapter(Context context, String[] leftStr, String[][] rightStr, String[] a) &#123; this.mContext = context; this.leftStr = leftStr; this.rightStr = rightStr; this.a = a; &#125; @Override public Object getItem(int section, int position) &#123; return rightStr[section][position]; &#125; public String[] getA()&#123; return a; &#125; @Override public long getItemId(int section, int position) &#123; return position; &#125; @Override public int getSectionCount() &#123; return leftStr.length; &#125; @Override public int getCountForSection(int section) &#123; return rightStr[section].length; &#125; @Override public View getItemView(final int section, final int position, final View convertView, final ViewGroup parent) &#123; RelativeLayout layout = null; if (convertView == null) &#123; LayoutInflater inflator = (LayoutInflater) parent.getContext() .getSystemService(Context.LAYOUT_INFLATER_SERVICE); layout = (RelativeLayout) inflator.inflate(R.layout.right_list_item, null); &#125; else &#123; layout = (RelativeLayout) convertView; &#125; ((TextView) layout.findViewById(R.id.textItem)).setText(rightStr[section][position]); ((TextView) layout.findViewById(R.id.count)).setText(count+&quot;&quot;); layout.findViewById(R.id.add).setOnClickListener( new OnClickListener() &#123; @Override public void onClick(View view) &#123; //TextView t =getItemView(section,position,convertView,parent).findViewById(R.id.count); count[section][position]++; Toast.makeText(mContext, rightStr[section][position]+count[section][position], Toast.LENGTH_SHORT).show(); a[count1]=rightStr[section][position]; count1++; Log.i(&quot;123&quot;, &quot;onClick: &quot;+a[0]+a[1]+a[2]); &#125; &#125; ); layout.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View arg0) &#123; Toast.makeText(mContext, rightStr[section][position], Toast.LENGTH_SHORT).show(); &#125; &#125;); return layout; &#125; @Override public View getSectionHeaderView(int section, View convertView, ViewGroup parent) &#123; LinearLayout layout = null; if (convertView == null) &#123; LayoutInflater inflator = (LayoutInflater) parent.getContext() .getSystemService(Context.LAYOUT_INFLATER_SERVICE); layout = (LinearLayout) inflator.inflate(R.layout.header_item, null); &#125; else &#123; layout = (LinearLayout) convertView; &#125; layout.setClickable(false); ((TextView) layout.findViewById(R.id.textItem)).setText(leftStr[section]); return layout; &#125;&#125; 三个ListView用到的Item。header_item.xml123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/gray_light&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:id=&quot;@+id/textItem&quot; android:layout_marginLeft=&quot;@dimen/dp10&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;@dimen/dp30&quot; android:layout_gravity=&quot;center_vertical&quot; android:gravity=&quot;center_vertical&quot; android:paddingLeft=&quot;@dimen/dp6&quot; android:textColor=&quot;@color/black&quot; /&gt;&lt;/LinearLayout&gt; left_list_item.xml12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/gray_light&quot; android:orientation=&quot;vertical&quot; &gt; &lt;TextView android:id=&quot;@+id/left_list_item&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;@dimen/dp60&quot; android:padding=&quot;@dimen/dp12&quot; android:gravity=&quot;center_vertical&quot; android:textColor=&quot;@color/black&quot;/&gt; &lt;/LinearLayout&gt; right_list_item.xml1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/white&quot; android:padding=&quot;@dimen/dp6&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageItem&quot; android:layout_width=&quot;@dimen/dp50&quot; android:layout_height=&quot;@dimen/dp50&quot; android:scaleType=&quot;fitXY&quot; android:src=&quot;@drawable/pic&quot;/&gt; &lt;TextView android:id=&quot;@+id/textItem&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;@dimen/dp50&quot; android:gravity=&quot;center_vertical&quot; android:paddingLeft=&quot;@dimen/dp6&quot; android:layout_toRightOf=&quot;@+id/imageItem&quot; android:textColor=&quot;@color/black&quot; /&gt;&lt;/RelativeLayout&gt;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"ListView联动","slug":"ListView联动","permalink":"http://yoursite.com/tags/ListView联动/"}]},{"title":"Apache下https服务的配置","slug":"Apache下https服务的配置","date":"2018-07-20T04:10:37.821Z","updated":"2018-07-20T04:10:37.821Z","comments":true,"path":"2018/07/20/Apache下https服务的配置/","link":"","permalink":"http://yoursite.com/2018/07/20/Apache下https服务的配置/","excerpt":"","text":"Apache下https服务的配置1.下载证书，一般为四个文件注意：服务器不一样，证书的数量可能不一样1234214132021230522.key214132021230522.pemchain.pempublic.pem 2.在apache的配置文件(httpd.conf)中,对以下两句话取消注释注意：第一条加载ssl，第二天引入配置文件12LoadModule ssl_module modules/mod_ssl.soInclude conf/extra/httpd-ssl.conf 3.配置httpd-ssl.conf文件，加入主机信息和证书路径注意: 路径配置错误可能打不开服务器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Listen 443SSLPassPhraseDialog builtinSSLSessionCache &quot;shmcb:/Apache24/logs/ssl_scache(512000)&quot;SSLSessionCacheTimeout 300&lt;VirtualHost _default_:443&gt;DocumentRoot &quot;E:\\web\\public&quot;ServerName www.abc.com:443ServerAdmin admin@example.comSSLEngine onSSLCipherSuite ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP:+eNULLSSLCertificateFile &quot;C:\\Apache24\\cert\\www\\public.pem&quot;SSLCertificateKeyFile &quot;C:\\Apache24\\cert\\www\\214132021230522.key&quot;SSLCertificateChainFile &quot;C:\\Apache24\\cert\\www\\chain.pem&quot;&lt;FilesMatch &quot;\\.(cgi|shtml|phtml|php)$&quot;&gt; SSLOptions +StdEnvVars&lt;/FilesMatch&gt;&lt;Directory &quot;/Apache24/cgi-bin&quot;&gt; SSLOptions +StdEnvVars&lt;/Directory&gt;BrowserMatch &quot;.*MSIE.*&quot; \\ nokeepalive ssl-unclean-shutdown \\ downgrade-1.0 force-response-1.0# Per-Server Logging:# The home of a custom SSL log file. Use this when you want a# compact non-error SSL logfile on a virtual host basis.CustomLog &quot;/Apache24/logs/ssl_request.log&quot; \\ &quot;%t %h %&#123;SSL_PROTOCOL&#125;x %&#123;SSL_CIPHER&#125;x \\&quot;%r\\&quot; %b&quot;&lt;/VirtualHost&gt; 4.在网站根目录的.htaccess文件中配置跳转123456&lt;IfModule mod_rewrite.c&gt;RewriteEngine onRewriteBase /RewriteCond %&#123;SERVER_PORT&#125; !^443$RewriteRule ^.*$ https://%&#123;SERVER_NAME&#125;%&#123;REQUEST_URI&#125; [L,R]&lt;/IfModule&gt;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://yoursite.com/categories/javaEE/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/服务器/"}]},{"title":"关于微信小程序webview的使用","slug":"小程序","date":"2018-07-20T04:10:37.821Z","updated":"2018-07-20T04:10:37.821Z","comments":true,"path":"2018/07/20/小程序/","link":"","permalink":"http://yoursite.com/2018/07/20/小程序/","excerpt":"","text":"小程序微信小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。同时提供一系列工具帮助开发者快速接入并完成小程序开发。关于如何注册配置就不多言了，本文主要还是体验了下web-view的功能。 web-view详解有了这个组件之后，小程序可以很好的嵌入一些页面，可以环境小程序size告急的问题，同样也使开发更加便捷，毕竟小程序开发者基本都对前端开发较为了解。 web-view能力说再多还是需要去看官方文档，web-view文档, 兼容首先就需要注意：兼容问题，版本库和对应版本比例 基础库 1.6.4 开始支持，低版本需做兼容处理，个人类型与海外类型的小程序暂不支持使用。 目前而言，基本80%的用户会升级微信，所以其实不必担心版本问题，官方截止2017-12-01提供的数据也说明88%的用户支持web-view。 使用web-view 组件是一个可以用来承载网页的容器，会自动铺满整个小程序页面； ####属性：src 是String类型，是一个网站的url，默认值是none，webview 指向网页的链接。需登录小程序管理后台配置域名白名单。1234&lt;!-- wxml --&gt;&lt;!-- 指向微信公众平台首页的web-view --&gt;&lt;web-view src=&quot;https://mp.weixin.qq.com/&quot;&gt;&lt;/web-view&gt;可以配合Page实例的onLoad方法来获取url的具体值，也就是一个微信小程序页面中只有一个web-view，但是这个web-view的内容可以根据上一个页面传递的参数来获取页面URL，后面会讲如何实践， 官方提供如下接口： web-view和小程序的通信由小程序到web-view,其实本质上WEB-VIEW也是小程序的一个页面，所以小程序到web-view是正常的小程序间的通信，通过wx.navigateTo、wx.redirectTo，带上url参数,query参数就像正常url的参数一样跟着后面，然后在web-view的页面的Page实例里面通过onLoad的方法的参数来获取url的值，设置给web-view的src属性为改值即可。由web-view到小程序，由于在web-view的跳转通常是在src对应的网页中的操作来处理的，所以需要结合jssdk来处理，不需要wx.config配置，直接通过script标签来引入https://res.wx.qq.com/open/js/jweixin-1.3.0.js，就可以使用wx.miniProgram.navigateTo、wx.miniProgram.navigateBack、wx.miniProgram.switchTab、wx.miniProgram.reLaunch、wx.miniProgram.redirectTo接口，就像小程序之间的跳转一样，单是只能在当前小程序页面内跳转。支持以下部分JSSDK接口图像、音频、摇一摇、地理位置等信息，具体可以查看web-view文档,不过这些需要通过wx.config来授权，就和服务号开发类似。用户分享时可获取当前的URL，即在onShareAppMessage回调中返回webViewUrl参数。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071Page(&#123; onShareAppMessage(options) &#123; console.log(options.webViewUrl) &#125;&#125;)在网页内可通过window.__wxjs_environment变量判断是否在小程序环境。// web-view下的页面内console.log(window.__wxjs_environment === &apos;miniprogram&apos;) // trueweb-view实践在目前实践了部分web-view的功能，//index.jsPage(&#123; data: &#123; url: &apos;https://test.com&apos; &#125;, onLoad: function(options)&#123; options.url ? this.setData(&#123;url: options.url&#125;) : wx.navigateBack(&#123;delta: 2&#125;); &#125;&#125;);//index.wxml&lt;web-view src=&quot;&#123;&#123;url&#125;&#125;&quot;&gt;&lt;/web-view&gt;在这个web-view中，指向的就是https://test.com的内容，所以在在https://test.com中跳转出回到小程序，需要修改https://test.com中的JavaScript,&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;test&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://test.com/index.css&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;app&quot;&gt; &lt;h1&gt;webview-wechat-detail&lt;/h1&gt; &lt;p&gt; detail &lt;/p&gt; &lt;button type=&quot;button&quot; id=&quot;btn&quot;&gt;返回小程序&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;https://test.com/jquery.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://res.wx.qq.com/open/js/jweixin-1.3.0.js&quot;&gt;&lt;/script&gt; &lt;script&gt; /* eslint-disable */$(function()&#123; doucument.cookie = &apos;bb=bbbbbb&apos;; $(&apos;#btn&apos;).on(&apos;click&apos;,function(s) &#123; document.cookie = &apos;aa=ssssss&apos;; wx.miniProgram.navigateTo(&#123; url:&apos;/pages/index?test=testtest&apos;, success: function()&#123; console.log(&apos;success&apos;) &#125;, fail: function()&#123; console.log(&apos;fail&apos;); &#125;, complete:function()&#123; console.log(&apos;complete&apos;); &#125; &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;如果需要使用一些其他的的jssdk的方法，那就需要参照公众号的开发配置了。 web-view采坑由于很多使用中的一些问题123456781.打开的域名没有在小程序管理后台设置业务域名（注意是业务域名，不是服务器域名）2.打开的页面必须为https服务3.打开的页面302过去的地址也必须设置过业务域名4.web-view空白问题，请升级微信客户端到 6.5.165.页面可以包含iframe，但是iframe的地址必须为业务域名6.web-view不支持支付能力，web-view的API能力见web-view的文档说明7.开发者自己检查自己的https服务是否正常，测试方法：普通浏览器打开对应的地址8.如果web-view使用了公众号授权的服务，开发者工具提示网页开发者的问题，请见：公众号开发 其他的问题注意：123456每个页面只能有一个&lt;web-view/&gt;，&lt;web-view/&gt;会自动铺满整个页面，并覆盖其他组件，小程序对webview的监控状态基本没有，只能设置src设置url。关于小程序和web-view的通信，&lt;web-view/&gt; → 小程序只能通过JSSDK 1.3.0提供的接口返回小程序页面，设置参数来传值，反之，小程序到webview也是一样的，只能是src的路径带上参数；web-view不支持支付能力,是指无法唤起小程序的直接支付窗口，对于h5的那套支付应该是支持的，但是web-view 里边没法使用 微信支付的 JSAPI，也就是可能可以h5的相关的的支付中心来支付；关于层级，在webview中可以无限跳转，对于导航条返回和物理键返回都会回到上一个页面直到退出webview，就像history.back。webview中的html的title会自动放到小程序的头部作为标题；webview中可以正常使用ajax之类的操作。","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"http://yoursite.com/categories/杂七杂八/"}],"tags":[{"name":"关于微信小程序webview的使用","slug":"关于微信小程序webview的使用","permalink":"http://yoursite.com/tags/关于微信小程序webview的使用/"}]},{"title":"深入理解Tomcat系列之一","slug":"深入理解Tomcat系列之一：系统架构","date":"2018-07-20T04:10:37.817Z","updated":"2018-07-20T04:10:37.817Z","comments":true,"path":"2018/07/20/深入理解Tomcat系列之一：系统架构/","link":"","permalink":"http://yoursite.com/2018/07/20/深入理解Tomcat系列之一：系统架构/","excerpt":"","text":"深入理解Tomcat系列之一：系统架构Tomcat的系统架构首先我们从一个宏观的角度来看一下Tomcat的系统的架构：从这张图中可以看到，Tomcat的核心组件就两个Connector和Container（后面还有详细说明），一个Connector+一个Container构成一个Service，Service就是对外提供服务的组件，有了Service组件Tomcat就可以对外提供服务了，但是光有服务还不行，还得有环境让你提供服务才行，所以最外层的Server就为Service提供了生存的土壤。那么这些个组件到底是干嘛用的呢？Connector是一个连接器，主要负责接收请求并把请求交给Container，Container就是一个容器，主要装的是具体处理请求的组件。Service主要是为了关联Container与Connector，一个单独的Container或者一个单独的Connector都不能完整处理一个请求，只有两个结合在一起才能完成一个请求的处理。Server这是负责管理Service集合，从图中我们看到一个Tomcat可以提供多种服务，那么这些Serice就是由Server来管理的，具体的工作包括：对外提供一个接口访问Service，对内维护Service集合，维护Service集合又包括管理Service的生命周期、寻找一个请求的Service、结束一个Service等。以上就是对Tomcat的核心组件的简要说明，下面我们详细看看每一个组件的执行流程： Server上面说Server是管理Service接口的，Server是Tomcat的顶级容器，是一个接口，Server接口的标准实现类是StandardServer类，在Server接口中有许多方法，我们重点关注两个方法：addService()和findService(String)。我们先来看看Server接口的全貌：接着看看addService()和findService(String)的实现代码：代码清单1-1:1234567891011121314151617181920212223242526272829/** * Add a new Service to the set of defined Services. * * @param service The Service to be added */@Overridepublic void addService(Service service) &#123; service.setServer(this); synchronized (services) &#123; Service results[] = new Service[services.length + 1]; System.arraycopy(services, 0, results, 0, services.length); results[services.length] = service; services = results; if (getState().isAvailable()) &#123; try &#123; service.start(); &#125; catch (LifecycleException e) &#123; // Ignore &#125; &#125; // Report this property change to interested listeners support.firePropertyChange(&quot;service&quot;, null, service); &#125;&#125; 可以看到，Server使用一个数组来管理Service的，每添加一个Service就把原来的Service拷贝到一个新的数组中，再把新的Service放入Service数组中。所以Server与Service是关联在一起的，那么后面的getState().isAvailable()是干嘛的呢？判断状态是否无效，从而决定是否执行service方法。这里说到了状态，就不得不说Tomcat管理各组件生命周期的Lifecycle接口了： Lifecycle接口Tomcat中的组件都交给这个接口管理，但是具体组件的生命周期是由包含组件的父容器来管理的，Tomcat中顶级容器管理着Service的生命周期，Service容器又是Connector和Container的父容器，所以这两个组件的生命周期是由Service管理的，Container也有子容器，所以管理着这些子容器的生命周期。这样，只要所有组件都实现了Lifecycle接口，从顶层容器Server开始，就可以控制所有容器的生命周期了。Lifecycle接口中定义了很多状态，在api中详细说明了调用不同方法后的状态转变，同时定义了不同的方法，这些方法在执行后状态会发生相应的改变，在Lifecycle接口中定义了如下方法：在StandServer中实现了startInernal()方法，就是循环启动StandServer管理的Service的过程，Tomcat的Service都实现了Lifecycle接口，所以被管理的Service都将被通知到，从而执行start()方法，startIntenal()方法是这样的：代码清单1-2：12345678910111213141516171819202122/** * Start nested components (&#123;@link Service&#125;s) and implement the requirements * of &#123;@link org.apache.catalina.util.LifecycleBase#startInternal()&#125;. * * @exception LifecycleException if this component detects a fatal error * that prevents this component from being used */@Overrideprotected void startInternal() throws LifecycleException &#123; fireLifecycleEvent(CONFIGURE_START_EVENT, null); setState(LifecycleState.STARTING); globalNamingResources.start(); // Start our defined Services synchronized (services) &#123; for (int i = 0; i &lt; services.length; i++) &#123; services[i].start(); &#125; &#125;&#125; 现在所有的Service就会收到通知继而执行start方法。如果一个Service不允许被使用将会抛出一个LifecycleException异常。 stopIntenal()会通知所有Service执行stop方法，具体处理流程与startIntenal()方法类似。这个执行过程涉及一个非常重要的设计模式，就是观察者模式。 现在我们已经能够知道了容器通过Lifecycle接口管理容器的生命周期，那么在父容器的状态改变具体是怎么样通知给子容器的呢？回到代码清单1-2，我们注意到有一个fireLifecycleEvent()方法，fireLifecycleEvent()的执行流程如下： 调用LifecycleBase的fireLifecycleEvent(LifecycleListener listener)方法，LifecycleBase是一个抽象类，实现了Lifecycle接口 继续调用LifecycleSupport（是一个辅助完成对已经注册监听器的事件通知类，不可被继承，使用final)的fireLifecycleEvent(String type, Object data)方法 完成事件通知 fireLifecycleEvent(String type, Object data)的方法如下： 代码清单1-3：12345678910111213141516/** * Notify all lifecycle event listeners that a particular event has * occurred for this Container. The default implementation performs * this notification synchronously using the calling thread. * * @param type Event type * @param data Event data */public void fireLifecycleEvent(String type, Object data) &#123; LifecycleEvent event = new LifecycleEvent(lifecycle, type, data); LifecycleListener interested[] = listeners; for (int i = 0; i &lt; interested.length; i++) interested[i].lifecycleEvent(event);&#125; 所以，具体事件的通知是由LifecycleListener接口的lifecycleEvent方法完成的，各实现类可以根据不同的情况实现不同的事件监听逻辑 ServiceService是具体提供服务的接口，一个Service包装了Connector和一个Container，在Tomcat中这点是如何实现的呢？Service是一个接口，其标准实现类是StandardService，下面是这两个类的鸟瞰图：这里，我们只关心与Connector和Container最紧密的方法：setContainer()和addConnector()方法，先看一下setContainer()方法的源码：代码清单2-1：12345678910111213141516171819202122232425262728293031323334/** * Set the &lt;code&gt;Container&lt;/code&gt; that handles requests for all * &lt;code&gt;Connectors&lt;/code&gt; associated with this Service. * * @param container The new Container */@Overridepublic void setContainer(Container container) &#123; Container oldContainer = this.container; if ((oldContainer != null) &amp;&amp; (oldContainer instanceof Engine)) ((Engine) oldContainer).setService(null); this.container = container; if ((this.container != null) &amp;&amp; (this.container instanceof Engine)) ((Engine) this.container).setService(this); if (getState().isAvailable() &amp;&amp; (this.container != null)) &#123; try &#123; this.container.start(); &#125; catch (LifecycleException e) &#123; // Ignore &#125; &#125; if (getState().isAvailable() &amp;&amp; (oldContainer != null)) &#123; try &#123; oldContainer.stop(); &#125; catch (LifecycleException e) &#123; // Ignore &#125; &#125; // Report this property change to interested listeners support.firePropertyChange(&quot;container&quot;, oldContainer, this.container);&#125; 从代码中可以看到这个方法主要的任务是设置一个Container容器来处理一个或者多个Connector传送过来的请求。首先判断当前的Service是否已经关联了Container容器，如果已经关联了就去除这个关联关系。如果原来的Container容器已经启动了就终止其生命周期，结束运行并设置新的关联关系，这个新的Container容器开始新的生命周期。最后把这个过程通知给感兴趣的事件监听程序。 下面看看addConnector的方法： 代码清单2-2：123456789101112131415161718192021222324252627282930/** * Add a new Connector to the set of defined Connectors, and associate it * with this Service&apos;s Container. * * @param connector The Connector to be added */@Overridepublic void addConnector(Connector connector) &#123; synchronized (connectors) &#123; connector.setService(this); Connector results[] = new Connector[connectors.length + 1]; System.arraycopy(connectors, 0, results, 0, connectors.length); results[connectors.length] = connector; connectors = results; if (getState().isAvailable()) &#123; try &#123; connector.start(); &#125; catch (LifecycleException e) &#123; log.error(sm.getString( &quot;standardService.connector.startFailed&quot;, connector), e); &#125; &#125; // Report this property change to interested listeners support.firePropertyChange(&quot;connector&quot;, null, connector); &#125;&#125; 执行过程也比较清楚：用一个同步代码块包住connectors数组，首先设置connector与container和service的关联关系，然后让connector开始新的生命周期，最后通知感兴趣的事件监听程序。注意到Connector的管理和Server管理Service一样都使用了数组拷贝并把新的数组赋给当前的数组，从而间接实现了动态数组。之所以使用数组我想可能是出于性能的考虑吧。","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://yoursite.com/categories/javaEE/"}],"tags":[{"name":"Tomcat那些事","slug":"Tomcat那些事","permalink":"http://yoursite.com/tags/Tomcat那些事/"}]},{"title":"装饰者模式","slug":"装饰者模式","date":"2018-07-20T04:10:37.817Z","updated":"2018-07-20T04:10:37.817Z","comments":true,"path":"2018/07/20/装饰者模式/","link":"","permalink":"http://yoursite.com/2018/07/20/装饰者模式/","excerpt":"","text":"装饰者模式定义：在不必改变原类文件和原类使用的继承的情况下，动态地扩展一个对象的功能。 它是通过创建一个包装对象，也就是用装饰来包裹真实的对象来实现。 角色：######抽象构件角色（Project）：给出一个接口，以规范准备接收附加责任的对象。 具体构件角色（Employe）：定义一个将要接收附加责任的类。 装饰角色（Manager）：持有一个构件对象的实例，并定义一个与抽象构件接口一致的接口。 具体装饰角色（ManagerA、ManagerB）：负责给构件对象“贴上”附加的责任。 示例：公共接口：1234567891011121314151617181920212223242526public interface Person &#123; void eat(); &#125;被装饰对象：public class OldPerson implements Person &#123; @Override public void eat() &#123; System.out.println(&quot;吃饭&quot;); &#125; &#125; 装饰对象：public class NewPerson implements Person &#123; private OldPerson p; NewPerson(OldPerson p) &#123; this.p = p; &#125; @Override public void eat() &#123; System.out.println(&quot;生火&quot;); System.out.println(&quot;做饭&quot;); p.eat(); System.out.println(&quot;刷碗&quot;); &#125; &#125; 测试：12345678public class PersonDemo &#123; public static void main(String[] args) &#123; OldPerson old = new OldPerson(); //old.eat(); NewPerson np = new NewPerson(old); np.eat(); &#125; &#125; 通过例子可以看到，没有改变原来的OldPerson类，同时也没有定义他的子类而实现了Person的扩展，这就是装饰者模式的作用。 优点：1，使用装饰者模式比使用继承更加灵活，因为它选择通过一种动态的方式来扩展一个对象的功能，在运行时可以选择不同的装饰器，从而实现不同的行为。 2，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。 3，具体构件类与具体装饰类可以独立变化，他能是低耦合的。用户可以根据需要来增加新的具体构件类和具体装饰类，在使用时再对其进行各种组合，原有代码无须改变，符合“开闭原则”。 缺点：1，会产生很多的小对象，增加了系统的复杂性 2，这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。 装饰者与适配者模式的区别： 1，适配器模式主要用来兼容那些不能在一起工作的类，使他们转化为可以兼容目标接口，虽然也可以实现和装饰者一样的增加新职责，但目的不在此。 装饰者模式主要是给被装饰者增加新职责的。 2，适配器模式是用新接口来调用原接口，原接口对新系统是不可见或者说不可用的。 装饰者模式原封不动的使用原接口，系统对装饰的对象也通过原接口来完成使用。 3，适配器是知道被适配者的详细情况的（就是那个类或那个接口）。 装饰者只知道其接口是什么，至于其具体类型（是基类还是其他派生类）只有在运行期间才知道。 装饰者和继承的区别：继承： 优点：代码结构清晰，而且实现简单 缺点：对于每一个的需要增强的类都要创建具体的子类来帮助其增强，这样会导致继承体系过于庞大。 装饰者： 优点：内部可以通过多态技术对多个需要增强的类进行增强 缺点：需要内部通过多态技术维护需要增强的类的实例。进而使得代码稍微复杂。 使用场景：1，需要扩展一个类的功能，或给一个类添加附加职责。 2，需要动态的给一个对象添加功能，这些功能可能不明确或者暂时的，可以随时很方便的动态撤销掉。 3，需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。 4. 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"外观者模式","slug":"外观者模式","date":"2018-07-20T04:10:37.817Z","updated":"2018-07-20T04:10:37.817Z","comments":true,"path":"2018/07/20/外观者模式/","link":"","permalink":"http://yoursite.com/2018/07/20/外观者模式/","excerpt":"","text":"外观者模式定义： 为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 角色：1、外观(Facade)角色 ：客户端可以调用这个角色的方法。此角色知晓相关子系统的功能和责任。在正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去。 2、子系统(SubSystem)角色 ：可以同时有一个或者多个子系统。每个子系统都不是一个单独的类，而是一个类的集合。每个子系统都可以被客户端直接调用，或者被外观角色调用。子系统并不知道外观角色的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。 示例：1、子系统角色，由若干个类组成123456789101112131415161718192021222324public class SubClass1 &#123; public void method1()&#123; System.out.println(&quot;这是子系统类1中的方法1&quot;); &#125; public void method2()&#123; System.out.println(&quot;这是子系统类1中的方法2&quot;); &#125;&#125;public class SubClass2 &#123; public void method1()&#123; System.out.println(&quot;这是子系统类2中的方法1&quot;); &#125; public void method2()&#123; System.out.println(&quot;这是子系统类2中的方法2&quot;); &#125;&#125;public class SubClass3 &#123; public void method1()&#123; System.out.println(&quot;这是子系统类3中的方法1&quot;); &#125; public void method2()&#123; System.out.println(&quot;这是子系统类3中的方法2&quot;); &#125;&#125; 2、外观角色类12345678910public class FacadeClass &#123; public void FacadeMethod()&#123; SubClass1 s1 = new SubClass1(); s1.method1(); SubClass2 s2 = new SubClass2(); s2.method1(); SubClass3 s3 = new SubClass3(); s3.method1(); &#125;&#125; 3、客户端测试方法123456public class ClientClass &#123; public static void main(String[] args) &#123; FacadeClass fc = new FacadeClass(); fc.FacadeMethod(); &#125;&#125; Facade类其实相当于子系统中SubClass类的外观界面，有了这个Facade类，那么客户端就不需要亲自调用子系统中的那些具体实现的子类了，也不需要知道系统内部的实现细节，甚至都不需要知道这些子类的存在，客户端只需要跟Facade类交互就好了，从而更好地实现了客户端和子系统中具体类的解耦，让客户端更容易地使用系统。 同时，这样定义一个Facade类可以有效地屏蔽内部的细节，免得客户端去调用Module类时，发现一些不需要它知道的方法。如上代码，我的所有子类中的方法二都是方法一调用的方法，是配合方法一的，他们不需要被客户端调用，而且具有一定的保密性，这样使用外观模式时就可以不被客户端知道。 优点： 实现了子系统与客户端之间的松耦合关系。 客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。 适用场景： 设计初期阶段，应该有意识的将不同层分离，层与层之间建立外观模式。 开发阶段，子系统越来越复杂，增加外观模式提供一个简单的调用接口。 维护一个大型遗留系统的时候，可能这个系统已经非常难以维护和扩展，但又包含非常重要的功能，为其开发一个外观类，以便新系统与其交互。 外观模式总结： 1、外观模式为复杂子系统提供了一个简单接口，并不为子系统添加新的功能和行为。 2、外观模式实现了子系统与客户端之间的松耦合关系。 3、外观模式没有封装子系统的类，只是提供了简单的接口。 如果应用需要，它并不限制客户使用子系统类。因此可以灵活的在系统易用性与通用性之间选择。 4、外观模式注重的是简化接口，它更多的时候是从架构的层次去看整个系统，而并非单个类的层次。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"javaweb (二)","slug":"Servlet 的线程安全问题","date":"2018-07-20T04:10:37.817Z","updated":"2018-07-20T04:10:37.817Z","comments":true,"path":"2018/07/20/Servlet 的线程安全问题/","link":"","permalink":"http://yoursite.com/2018/07/20/Servlet 的线程安全问题/","excerpt":"","text":"Servlet 的线程安全问题 当多个客户端并发访问同一个Servlet时，web服务器会为每一个客户端的访问请求创建一个线程，并在这个线程上调用Servlet的service方法，因此service方法内如果访问了同一个资源的话，就有可能引发线程安全问题。例如下面的代码： 不存在线程安全问题的代码：123456789101112131415161718192021222324import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = &quot;Servlet&quot;)public class ServletDemo3 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;doGet(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;/** * 当多线程并发访问这个方法里面的代码时，会存在线程安全问题吗 * i变量被多个线程并发访问，但是没有线程安全问题，因为i是doGet方法里面的局部变量， * 当有多个线程并发访问doGet方法时，每一个线程里面都有自己的i变量， * 各个线程操作的都是自己的i变量，所以不存在线程安全问题 * 多线程并发访问某一个方法的时候，如果在方法内部定义了一些资源(变量，集合等) * 那么每一个线程都有这些东西，所以就不存在线程安全问题了 */ int i=1; i++; response.getWriter().write(i+&quot;&quot;); &#125;&#125; 存在线程安全问题的代码：12345678910111213141516171819202122import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = &quot;ServletDemo4&quot;)public class ServletDemo4 extends HttpServlet &#123; int i=1; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;doGet(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; i++; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; response.getWriter().write(i+&quot;&quot;); &#125;&#125; 把i定义成全局变量，当多个线程并发访问变量i时，就会存在线程安全问题了，如下图所示：同时开启两个浏览器模拟并发访问同一个Servlet，本来正常来说，第一个浏览器应该看到2，而第二个浏览器应该看到3的，结果两个浏览器都看到了3，这就不正常。 线程安全问题只存在多个线程并发操作同一个资源的情况下，所以在编写Servlet的时候，如果并发访问某一个资源(变量，集合等)，就会存在线程安全问题，那么该如何解决这个问题呢？123456789101112131415161718192021public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; /** * 加了synchronized后，并发访问i时就不存在线程安全问题了， * 为什么加了synchronized后就没有线程安全问题了呢？ * 假如现在有一个线程访问Servlet对象，那么它就先拿到了Servlet对象的那把锁 * 等到它执行完之后才会把锁还给Servlet对象，由于是它先拿到了Servlet对象的那把锁， * 所以当有别的线程来访问这个Servlet对象时，由于锁已经被之前的线程拿走了，后面的线程只能排队等候了 * */ synchronized (this) &#123;//在java中，每一个对象都有一把锁，这里的this指的就是Servlet对象 i++; try &#123; Thread.sleep(1000*4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; response.getWriter().write(i+&quot;&quot;); &#125; &#125; 现在这种做法是给Servlet对象加了一把锁，保证任何时候都只有一个线程在访问该Servlet对象里面的资源，这样就不存在线程安全问题了，如下图所示：这种做法虽然解决了线程安全问题，但是编写Servlet却万万不能用这种方式处理线程安全问题，假如有9999个人同时访问这个Servlet，那么这9999个人必须按先后顺序排队轮流访问。针对Servlet的线程安全问题，Sun公司是提供有解决方案的：让Servlet去实现一个SingleThreadModel接口，如果某个Servlet实现了SingleThreadModel接口，那么Servlet引擎将以单线程模式来调用其service方法。查看Sevlet的API可以看到，SingleThreadModel接口中没有定义任何方法和常量，在Java中，把没有定义任何方法和常量的接口称之为标记接口，经常看到的一个最典型的标记接口就是”Serializable”，这个接口也是没有定义任何方法和常量的，标记接口在Java中有什么用呢？主要作用就是给某个对象打上一个标志，告诉JVM，这个对象可以做什么，比如实现了”Serializable”接口的类的对象就可以被序列化，还有一个”Cloneable”接口，这个也是一个标记接口，在默认情况下，Java中的对象是不允许被克隆的，就像现实生活中的人一样，不允许克隆，但是只要实现了”Cloneable”接口，那么对象就可以被克隆了。 让Servlet实现了SingleThreadModel接口，只要在Servlet类的定义中增加实现SingleThreadModel接口的声明即可。 对于实现了SingleThreadModel接口的Servlet，Servlet引擎仍然支持对该Servlet的多线程并发访问，其采用的方式是产生多个Servlet实例对象，并发的每个线程分别调用一个独立的Servlet实例对象。 实现SingleThreadModel接口并不能真正解决Servlet的线程安全问题，因为Servlet引擎会创建多个Servlet实例对象，而真正意义上解决多线程安全问题是指一个Servlet实例对象被多个线程同时调用的问题。事实上，在Servlet API 2.4中，已经将SingleThreadModel标记为Deprecated（过时的）。 实现 SingleThreadModel 接口（已过时） 同步对共享数据的操作 使用synchronized 关键字能保证一次只有一个线程可以访问被保护的区段，在本论文中的Servlet可以通过同步块操作来保证线程的安全。 避免使用实例变量—-最佳选择。 本实例中的线程安全问题是由实例变量造成的，只要在Servlet里面的任何方法里面都不使用实例变量，那么该Servlet就是线程安全的。","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://yoursite.com/categories/javaEE/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"}]},{"title":"javaweb (四 )","slug":"利用ServletContext对象读取资源文件","date":"2018-07-20T04:10:37.817Z","updated":"2018-07-20T04:10:37.817Z","comments":true,"path":"2018/07/20/利用ServletContext对象读取资源文件/","link":"","permalink":"http://yoursite.com/2018/07/20/利用ServletContext对象读取资源文件/","excerpt":"","text":"利用ServletContext对象读取资源文件项目目录结构如下： 代码范例：使用servletContext读取资源文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.text.MessageFormat;import java.util.Properties;@WebServlet(name = &quot;ServletContextDemo7&quot;)public class ServletContextDemo7 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;/** * response.setContentType(&quot;text/html;charset=UTF-8&quot;);目的是控制浏览器用UTF-8进行解码； * 这样就不会出现中文乱码了 */ response.setHeader(&quot;content-type&quot;, &quot;text/html;charset=UTF-8&quot;); readSrcDirPropCfgFile(response);//读取src目录下的properties配置文件 response.getWriter().println(&quot;&lt;hr/&gt;&quot;); readWebRootDirPropCfgFile(response);//读取WebRoot目录下的properties配置文件 response.getWriter().println(&quot;&lt;hr/&gt;&quot;); readPropCfgFile(response);//读取src目录下的db.config包中的db3.properties配置文件 response.getWriter().println(&quot;&lt;hr/&gt;&quot;); readPropCfgFile2(response);//读取src目录下的包中的db4.properties配置文件 &#125; private void readPropCfgFile2(HttpServletResponse response) throws IOException &#123; InputStream in = this.getServletContext().getResourceAsStream(&quot;/WEB-INF/classes/db4.properties&quot;); Properties prop = new Properties(); prop.load(in); String driver = prop.getProperty(&quot;driver&quot;); String url = prop.getProperty(&quot;url&quot;); String username = prop.getProperty(&quot;username&quot;); String password = prop.getProperty(&quot;password&quot;); response.getWriter().println(&quot;读取src目录下的db.config包中的db3.properties配置文件：&quot;); response.getWriter().print( MessageFormat.format( &quot;driver=&#123;0&#125;,url=&#123;1&#125;,username=&#123;2&#125;,password=&#123;3&#125;&quot;, driver,url, username, password) ); &#125; /** * 读取src目录下的db.config包中的db3.properties配置文件 * @param response * @throws IOException */ private void readPropCfgFile(HttpServletResponse response) throws IOException &#123; //通过ServletContext获取web资源的绝对路径 String path = this.getServletContext().getRealPath(&quot;/WEB-INF/classes/db/config/db3.properties&quot;); InputStream in = new FileInputStream(path); Properties prop = new Properties(); prop.load(in); String driver = prop.getProperty(&quot;driver&quot;); String url = prop.getProperty(&quot;url&quot;); String username = prop.getProperty(&quot;username&quot;); String password = prop.getProperty(&quot;password&quot;); response.getWriter().println(&quot;读取src目录下的db.config包中的db3.properties配置文件：&quot;); response.getWriter().print( MessageFormat.format( &quot;driver=&#123;0&#125;,url=&#123;1&#125;,username=&#123;2&#125;,password=&#123;3&#125;&quot;, driver,url, username, password) ); &#125; /** * 通过ServletContext对象读取WebRoot目录下的properties配置文件 * “/”代表的是项目根目录 * @param response * @throws IOException */ private void readWebRootDirPropCfgFile(HttpServletResponse response) throws IOException &#123; InputStream in = this.getServletContext().getResourceAsStream(&quot;/db2.properties&quot;); Properties prop = new Properties(); prop.load(in); String driver = prop.getProperty(&quot;driver&quot;); String url = prop.getProperty(&quot;url&quot;); String username = prop.getProperty(&quot;username&quot;); String password = prop.getProperty(&quot;password&quot;); response.getWriter().println(&quot;读取WebRoot目录下的db2.properties配置文件：&quot;); response.getWriter().print( MessageFormat.format( &quot;driver=&#123;0&#125;,url=&#123;1&#125;,username=&#123;2&#125;,password=&#123;3&#125;&quot;, driver,url, username, password) ); &#125; /** * 读取src目录下的db.config包中的db3.properties配置文件 * * @param response * @throws IOException */ private void readSrcDirPropCfgFile(HttpServletResponse response) throws IOException &#123; //通过ServletContext获取web资源的绝对路径 String path = this.getServletContext().getRealPath(&quot;/WEB-INF/classes/db/config/db3.properties&quot;); InputStream in = new FileInputStream(path); Properties prop = new Properties(); prop.load(in); String driver = prop.getProperty(&quot;driver&quot;); String url = prop.getProperty(&quot;url&quot;); String username = prop.getProperty(&quot;username&quot;); String password = prop.getProperty(&quot;password&quot;); response.getWriter().println(&quot;读取src目录下的db.config包中的db3.properties配置文件：&quot;); response.getWriter().println( MessageFormat.format(&quot;driver=&#123;0&#125;,url=&#123;1&#125;,username=&#123;2&#125;,password=&#123;3&#125;&quot;, driver, url, username, password) ); &#125;&#125; 通过ServletContext对象读取src目录下的db1.properties配置文件InputStream in = this.getServletContext().getResourceAsStream(“/WEB-INF/classes/db1.properties”); 通过ServletContext对象读取WebRoot目录下的properties配置文件InputStream in = this.getServletContext().getResourceAsStream(“/db2.properties”); 读取src目录下的db.config包中的db3.properties配置文件String path = this.getServletContext().getRealPath(“/WEB-INF/classes/db/config/db3.properties”);InputStream in = new FileInputStream(path); 读取src目录下的gacl.servlet.study包中的db4.properties配置文件InputStream in = this.getServletContext().getResourceAsStream(“/WEB-INF/db4.properties”); 运行结果： 代码范例：使用类装载器读取资源文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.*;import java.text.MessageFormat;import java.util.Properties;@WebServlet(name = &quot;ServletContextDemo8&quot;)public class ServletContextDemo8 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=UTF-8&quot;); //response.setHeader(&quot;content-type&quot;,&quot;text/html;charset=UTF-8&quot;); test1(response); response.getWriter().println(&quot;&lt;hr/&gt;&quot;); test2(response); response.getWriter().println(&quot;&lt;hr/&gt;&quot;); //test3();//并没有成功 test4(); &#125; private void test4() throws IOException &#123; String path = this.getServletContext().getRealPath(&quot;/WEB-INF/classes/01.avi&quot;); String filename = path.substring(path.lastIndexOf(&quot;\\\\&quot;) + 1);//获取文件名 InputStream in = this.getServletContext().getResourceAsStream(&quot;/WEB-INF/classes/01.avi&quot;); byte buffer[] = new byte[1024]; int len = 0; OutputStream out = new FileOutputStream(&quot;e:\\\\&quot; + filename); while ((len = in.read(buffer))&gt;0)&#123; out.write(buffer,0,len); &#125; out.close(); in.close(); &#125; /** * 通过类装载器读取资源文件的注意事项:不适合装载大文件，否则会导致jvm内存溢出 */ private void test3() &#123; /** * 01.avi是一个60多M的文件，使用类加载器去读取这个大文件时会导致内存溢出： * 01.pdf 是一个200多M的文件， * java.lang.OutOfMemoryError: Java heap space */ InputStream in = ServletContextDemo8.class.getClassLoader().getResourceAsStream(&quot;01.pdf&quot;); System.out.println(in); //并没有试验成功 &#125; /** * 读取类路径下面、包下面的资源文件 * @param response * @throws IOException */ private void test2(HttpServletResponse response) throws IOException &#123; //获取到装载当前类的类装载器 ClassLoader loader = ServletContextDemo8.class.getClassLoader(); //用类装载器读取src目录下的db1.properties配置文件 InputStream in = loader.getResourceAsStream(&quot;db4.properties&quot;); Properties prop = new Properties(); prop.load(in); String driver = prop.getProperty(&quot;driver&quot;); String url = prop.getProperty(&quot;url&quot;); String username = prop.getProperty(&quot;username&quot;); String password = prop.getProperty(&quot;password&quot;); response.getWriter().println(&quot;用类装载器读取src目录下的db4.properties配置文件：&quot;); response.getWriter().print( MessageFormat.format( &quot;driver=&#123;0&#125;,url=&#123;1&#125;,username=&#123;2&#125;,password=&#123;3&#125;&quot;, driver,url, username, password) ); &#125; /** * 读取类路径下的资源文件 * @param response * @throws IOException */ private void test1(HttpServletResponse response) throws IOException &#123; //获取到装载当前类的类装载器 ClassLoader loader = ServletContextDemo8.class.getClassLoader(); //用类装载器读取src目录下的db1.properties配置文件 InputStream in = loader.getResourceAsStream(&quot;db1.properties&quot;); Properties prop = new Properties(); prop.load(in); String driver = prop.getProperty(&quot;driver&quot;); String url = prop.getProperty(&quot;url&quot;); String username = prop.getProperty(&quot;username&quot;); String password = prop.getProperty(&quot;password&quot;); response.getWriter().println(&quot;用类装载器读取src目录下的db1.properties配置文件：&quot;); response.getWriter().print( MessageFormat.format( &quot;driver=&#123;0&#125;,url=&#123;1&#125;,username=&#123;2&#125;,password=&#123;3&#125;&quot;, driver,url, username, password) ); &#125;&#125; 在客户端缓存Servlet的输出对于不经常变化的数据，在servlet中可以为其设置合理的缓存时间值，以避免浏览器频繁向服务器发送请求，提升服务器的性能。例如在ServletContextDemo5的doGet()方法添加如下代码： response.setDateHeader(“expires”,System.currentTimeMillis() + 24 3600 1000); 找到浏览器缓存如图","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://yoursite.com/categories/javaEE/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"}]},{"title":"apache和tomcat区别","slug":"apache和tomcat区别","date":"2018-07-20T04:10:37.817Z","updated":"2018-07-20T04:10:37.817Z","comments":true,"path":"2018/07/20/apache和tomcat区别/","link":"","permalink":"http://yoursite.com/2018/07/20/apache和tomcat区别/","excerpt":"","text":"apache和tomcat区别经常在用apache和tomcat等这些服务器，可是总感觉还是不清楚他们之间有什么关系，在用tomcat的时候总出现apache，总感到迷惑，到底谁是主谁是次，因此特意在网上查询了一些这方面的资料，总结了一下： 解析一 ：apache支持静态页，tomcat支持动态的，比如servlet等，一般使用apache+tomcat的话，apache只是作为一个转发，对jsp的处理是由tomcat来处理的。apche可以支持php cgi perl,但是要使用java的话，你需要tomcat在apache后台支撑，将java请求由apache转发给tomcat处理。apache是web服务器，tomcat是应用（java）服务器，它只是一个servlet(jsp也翻译成servlet)容器，可以认为是apache的扩展，但是可以独立于apache运行。 这两个有以下几点可以比较的：1、两者都是apache组织开发的2、两者都有HTTP服务的功能3、两者都是免费的 不同点：Apache是专门用了提供HTTP服务的，以及相关配置的（例如虚拟主机、URL转发等等）Tomcat是Apache组织在符合J2EE的JSP、Servlet标准下开发的一个JSP服务器12345678910Runtime r=Runtime.getRuntime(); Process p=null; try&#123; p=r.exec(&quot;notepad&quot;); &#125; catch(Exception ex) &#123; System.out.println(&quot;fffff&quot;); &#125; 解析二：APACHE是一个web服务器环境程序 启用他可以作为web服务器使用 不过只支持静态网页 如(asp,php,cgi,jsp)等动态网页的就不行如果要在APACHE环境下运行jsp 的话就需要一个解释器来执行jsp网页 而这个jsp解释器就是TOMCAT, 为什么还要JDK呢？因为jsp需要连接数据库的话 就要jdk来提供连接数据库的驱程，所以要运行jsp的web服务器平台就需要APACHE+TOMCAT+JDK 整合的好处是：如果客户端请求的是静态页面，则只需要Apache服务器响应请求如果客户端请求动态页面，则是Tomcat服务器响应请求因为jsp是服务器端解释代码的，这样整合就可以减少Tomcat的服务开销C是一个结构化语言，如谭老爷子所说：它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。 解析三： apache:侧重于http server tomcat:侧重于servlet引擎，如果以standalone方式运行，功能上与apache等效 ， 支持JSP，但对静态网页不太理想； apache是web服务器，tomcat是应用（java）服务器，它只是一个servlet(jsp也翻译成servlet)容器，可以认为是apache的扩展，但是可以独立于apache运行。换句话说，apache是一辆卡车，上面可以装一些东西如html等。但是不能装水，要装水必须要有容器（桶），而这个桶也可以不放在卡车上。","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://yoursite.com/categories/javaEE/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/服务器/"}]},{"title":"代理模式","slug":"代理模式","date":"2018-07-20T04:10:37.817Z","updated":"2018-07-20T04:10:37.817Z","comments":true,"path":"2018/07/20/代理模式/","link":"","permalink":"http://yoursite.com/2018/07/20/代理模式/","excerpt":"","text":"代理模式定义： 为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用 角色：1、抽象角色：声明真实对象和代理对象的共同接口。 2、 代理角色：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。 3、真实角色：代理角色所代表的真实对象，是我们最终要引用的对象。 分类：静态代理静态代理也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。 示例：抽象角色，真实对象和代理对象共同的接口1234public interface UserInfo&#123; public void queryUser (); public void updateUser (); &#125; 真实角色123456789101112public class UserImpl implementsUserInfo&#123; @Override public void queryUser() &#123; //查询方法略... &#125; @Override public void updateUser() &#123; //修改方法略... &#125; &#125; 代理角色12345678910111213141516171819202122232425262728293031public class UserProxy implements UserInfo&#123; private UserInfo userImpl; public UserProxy(UserInfo userImpl) &#123; this.userImpl = userImpl; &#125; @Override public void queryUser() &#123; //这里可以扩展，增加一些查询之前需要执行的方法 //查询方法略... //这里可以扩展，增加一些查询之后需要执行的方法 &#125; @Override public void updateUser() &#123; //这里可以扩展，增加一些修改之前需要执行的方法 //修改方法略... //这里可以扩展，增加一些修改之后需要执行的方法 &#125; &#125;使用代理之后如何调用他的方法？public class Test &#123; public static void main(String[] args) &#123; UserInfo userImpl = new UserImpl(); UserInfo userProxy = new UserProxy(userImpl); userProxy.queryUser(); userProxy.updateUser(); &#125; &#125; 动态代理动态代理类的源码是程序在运行期间由JVM根据反射等机制动态生成的，所以不存在代理类的字节码文件。代理角色和真实角色的联系在程序运行时确定。 示例：抽象角色，真实对象和代理对象共同的接口1234public interface UserInfo&#123; public void queryUser (); public void updateUser (); &#125; 真实角色12345678910111213public class UserImpl implements UserInfo&#123; @Override public void queryUser() &#123; //查询方法略... &#125; @Override public void updateUser() &#123; //修改方法略... &#125; &#125; 代理角色处理器：12345678910111213141516171819202122232425262728293031public class UserHandler implements InvocationHandler&#123; privateUserInfo userImpl; publicUserHandler(UserInfo userImpl2)&#123; this.userImpl= userImpl2; &#125; @Override publicObject invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Objectobject = null; //方法开始前做一些事情 if (method.getName().equals(&quot;queryUser&quot;)) &#123; object = method.invoke(userImpl, args); //激活调用的方法 &#125; //方法结束后做一些事情 return object; &#125;&#125;如何调用（和静态代理略有不同）public class Test &#123; public static void main(String[] args) &#123; UserInfouserImpl =new UserImpl(); UserHandlerhandler = new UserHandler(userImpl); UserInfouserProxy = (UserInfo)Proxy.newProxyInstance (ClassLoader.getSystemClassLoader(), newClass[]&#123;UserInfo.class&#125;, handler); userProxy.queryUser(); &#125;&#125; 优点： 业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。 能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。 缺点： 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理。 实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂，例如远程代理。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"javaweb (七)","slug":"HttpServletResponse常见应用——生成验证码","date":"2018-07-20T04:10:37.817Z","updated":"2018-07-20T04:10:37.817Z","comments":true,"path":"2018/07/20/HttpServletResponse常见应用——生成验证码/","link":"","permalink":"http://yoursite.com/2018/07/20/HttpServletResponse常见应用——生成验证码/","excerpt":"","text":"HttpServletResponse常见应用——生成验证码生成随机图片用作验证码生成图片主要用到了一个BufferedImage类，生成随机图片范例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package qgx.response.study;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;@WebServlet(name = &quot;ResponseDemo3&quot;)public class ResponseDemo3 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setHeader(&quot;refresh&quot;, &quot;5&quot;);//设置refresh响应头控制浏览器每隔5秒钟刷新一次 //1.在内存中创建一张图片 BufferedImage image = new BufferedImage(80, 20, BufferedImage.TYPE_INT_RGB); //2.得到图片 Graphics g = (Graphics)image.getGraphics(); g.setColor(Color.WHITE);//设置图片的背景色 g.fillRect(0, 0, 80, 20);//填充背景色 //3.向图片上写数据 g.setColor(Color.BLUE);//设置图片上字体的颜色 g.setFont(new Font(null, Font.BOLD, 20)); g.drawString(makeNum(), 0, 20); //4.设置响应头控制浏览器浏览器以图片的方式打开 response.setContentType(&quot;image/jpeg&quot;);//等同于response.setHeader(&quot;Content-Type&quot;, &quot;image/jpeg&quot;); //5.设置响应头控制浏览器不缓存图片数据 response.setDateHeader(&quot;expries&quot;, -1); response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;); response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;); //6.将图片写给浏览器 ImageIO.write(image, &quot;jpg&quot;, response.getOutputStream()); &#125; private String makeNum() &#123; Random random = new Random(); String num = random.nextInt(9999999)+&quot;&quot;; StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; 7-num.length(); i++) &#123; sb.append(&quot;0&quot;); &#125; num = sb.toString()+num; return num; &#125;&#125; HttpServletResponse常见应用——设置响应头控制浏览器的行为设置http响应头控制浏览器禁止缓存当前文档内容123response.setDateHeader(&quot;expries&quot;, -1);response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;); 设置http响应头控制浏览器定时刷新网页(refresh)1response.setHeader(&quot;refresh&quot;, &quot;5&quot;);//设置refresh响应头控制浏览器每隔5秒钟刷新一次 通过response实现请求重定向 请求重定向指：一个web资源收到客户端请求后，通知客户端去访问另外一个web资源，这称之为请求重定向。 应用场景：用户登陆，用户首先访问登录页面，登录成功后，就会跳转到某个页面，这个过程就是一个请求重定向的过程 实现方式：response.sendRedirect(String location)，即调用response对象的sendRedirect方法实现请求重定向 sendRedirect内部的实现原理：使用response设置302状态码和设置location响应头实现重定向 1234 response.sendRedirect(&quot;/index.jsp&quot;);1.调用sendRedirect方法实现请求重定向, sendRedirect方法内部调用了response.setHeader(&quot;Location&quot;, &quot;/index.jsp&quot;);response.setStatus(HttpServletResponse.SC_FOUND);//设置302状态码，等同于response.setStatus(302); web工程中URL地址的推荐写法 在JavaWeb开发中，只要是写URL地址，那么建议最好以”/“开头，也就是使用绝对路径的方式，那么这个”/“到底代表什么呢？可以用如下的方式来记忆”/“：如果”/“是给服务器用的，则代表当前的web工程，如果”/“是给浏览器用的，则代表webapps目录。 “/“代表当前web工程的常见应用场景①.ServletContext.getRealPath(String path)获取资源的绝对路径 this.getServletContext().getRealPath(“/download/1.JPG”); ServletContext.getRealPath(“/download/1.JPG”)表示的就是读取web工程下的download文件夹中的1.JPG这个资源 ②.在服务器端forward到其他页面 this.getServletContext().getRequestDispatcher(“/index.jsp”).forward(request, response); forward 客户端请求某个web资源，服务器跳转到另外一个web资源，这个forward也是给服务器用的，那么这个”/“就是给服务器用的，所以此时”/“代表的就是web工程 ③.使用include指令或者jsp:include标签引入页面1&lt;jsp:include page=&quot;/jspfragments/demo.jsp&quot; /&gt; 此时”/“代表的都是web工程。 “/“代表webapps目录的常见应用场景①.使用sendRedirect实现请求重定向1response.sendRedirect(&quot;/Servlet_Study/index.jsp&quot;); 服务器发送一个URL地址给浏览器，浏览器拿到URL地址之后，再去请求服务器，所以这个”/“是给浏览器使用的，此时”/“代表的就是webapps目录，”/Servlet_Study/index.jsp”这个地址指的就是”webapps\\Servlet_Study\\index.jsp” response.sendRedirect(“/项目名称/文件夹目录/页面”);这种写法是将项目名称写死在程序中的做法，不灵活，万一哪天项目名称变了，此时就得改程序，所以推荐使用下面的灵活写法：1response.sendRedirect(request.getContextPath()+&quot;/index.jsp&quot;); ②.使用超链接跳转1&lt;a href=&quot;/Servlet_Study/index.jsp&quot;&gt;跳转到首页&lt;/a&gt; 这是客户端浏览器使用的超链接跳转，这个”/“是给浏览器使用的，此时”/“代表的就是webapps目录。 使用超链接访问web资源，绝对路径的写法推荐使用下面的写法改进：1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/index.jsp&quot;&gt;跳转到首页&lt;/a&gt; ③.Form表单提交123&lt;form action=&quot;/Servlet_Study/servlet/CheckServlet&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; 这是客户端浏览器将form表单提交到服务器，所以这个”/“是给浏览器使用的，此时”/“代表的就是webapps目录。对于form表单提交中action属性绝对路径的写法，也推荐使用如下的方式改进：123&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/servlet/CheckServlet&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; ④.js脚本和css样式文件的引用 123456&lt;%--使用绝对路径的方式引用js脚本--%&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;$&#123;pageContext.request.contextPath&#125;/js/index.js&quot;&gt;&lt;/script&gt; &lt;%--$&#123;pageContext.request.contextPath&#125;与request.getContextPath()写法是得到的效果是一样的--%&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%=request.getContextPath()%&gt;/js/login.js&quot;&gt;&lt;/script&gt; &lt;%--使用绝对路径的方式引用css样式--%&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123;pageContext.request.contextPath&#125;/css/index.css&quot; type=&quot;text/css&quot;/&gt; response细节问题 getOutputStream和getWriter方法分别用于得到输出二进制数据、输出文本数据的ServletOuputStream、Printwriter对象。 getOutputStream和getWriter这两个方法互相排斥，调用了其中的任何一个方法后，就不能再调用另一方法。 Servlet程序向ServletOutputStream或PrintWriter对象中写入的数据将被Servlet引擎从response里面获取，Servlet引擎将这些数据当作响应消息的正文，然后再与响应状态行和各响应头组合后输出到客户端。 Serlvet的service方法结束后，Servlet引擎将检查getWriter或getOutputStream方法返回的输出流对象是否已经调用过close方法，如果没有，Servlet引擎将调用close方法关闭该输出流对象。","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://yoursite.com/categories/javaEE/"}],"tags":[{"name":"HttpServletResponse","slug":"HttpServletResponse","permalink":"http://yoursite.com/tags/HttpServletResponse/"}]},{"title":"java 多线程","slug":"对象和变量的并发访问","date":"2018-07-20T04:10:37.813Z","updated":"2018-07-20T04:10:37.813Z","comments":true,"path":"2018/07/20/对象和变量的并发访问/","link":"","permalink":"http://yoursite.com/2018/07/20/对象和变量的并发访问/","excerpt":"","text":"对象和变量的并发访问技术点： synchronized 对象监视器为 Object 时的使用 synchronized 对象监视器为 Class 时的使用 非线程安全是如何出现的 关键字 volatile 的主要作用 关键字 volatile 与 synchronized 的区别及使用情况synchronized 同步方法方法内的变量为线程安全“非线程安全”问题存在于“实例变量”中，如果是方法内部的私有变量，则不存在“非线程安全”问题，所得结果也就是“线程安全”了实例变量非线程安全 如果多线程共同访问一个对象中的实例变量，则有可能出现“非线程安全”问题 在两个线程访问同一个对象中的同步方法时一定时线程安全的。脏读发生脏读的情况是在读取实例变量时，此值已经被其他线程更改过了。如下例子就可以说明，如果不加 synchronized 关键字在 setValue 和 getValue 方法上，就会出现数据脏读。123456789101112131415161718192021222324252627282930313233343536373839404142class VarName&#123;private String userName = &quot;A&quot;;private String password = &quot;AA&quot;;synchronized public void setValue(String userName, String password) &#123;try &#123;this.userName = userName;Thread.sleep(500);this.password = password;System.out.println(&quot;setValue method Thread name is : &quot; + Thread.currentThread().getName() + &quot; userName = &quot; + userName + &quot; password = &quot; + password);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;//synchronizedpublic void getValue() &#123;System.out.println(&quot;getValue method Thread name is : &quot; + Thread.currentThread().getName() + &quot; userName = &quot; + userName + &quot; password = &quot; + password);&#125;&#125;class Thread1 extends Thread&#123;private VarName varName;public Thread1(VarName varName) &#123;this.varName = varName;&#125;@Overridepublic void run() &#123;varName.setValue(&quot;B&quot;, &quot;BB&quot;);&#125;&#125;public class Test&#123;public static void main(String[] args) throws InterruptedException &#123;VarName v = new VarName();Thread1 thread1 = new Thread1(v);thread1.start();Thread.sleep(200);//打印结果受睡眠时间的影响v.getValue();&#125;&#125; synchronized 锁重入关键字synchronized 拥有锁重入的功能，也就是在使用 synchronized 时，当一个线程得到一个对象锁后，再次请求此对象锁是可以再次得到该对象的锁的。这也证明了在一个 synchronized 方法/块的内部调用本类的其他 synchronized 方法/块时，是永远可以得到锁的。12345678910111213141516171819202122232425262728293031class Service&#123;synchronized public void service1() &#123;System.out.println(&quot;service 1&quot;);service2();&#125;synchronized public void service2() &#123;System.out.println(&quot;service 2&quot;);service3();&#125;synchronized public void service3() &#123;System.out.println(&quot;service 3&quot;);&#125;&#125;class Thread2 extends Thread&#123;@Overridepublic void run() &#123;Service s = new Service();s.service1();&#125;&#125;public class Test2&#123;public static void main(String[] args) &#123;Thread2 t2 = new Thread2();t2.start();&#125;&#125; 运行结果：123service 1service 2service 3 同步不具有继承性同步不可以继承。 synchronized 同步语句块当一个线程访问 object 的一个 synchronized(this) 同步代码块时，其他线程对同一个 object 中所有其他 synchronized(this) 同步代码块的访问将被阻塞，这说明 synchronized 使用的 “对象监视器” 是一个。 将任意对象作为对象监视器多个线程调用同一个对象中的不同名称的 synchronized 同步方法或者 synchronized(this) 同步代码块时，调用的效果就是按顺序执行，也就是同步的，阻塞的。 静态同步 synchronized 方法与 synchronized(class) 代码块关键字 synchronized 还可以应用在 static 静态方法上，如果这样写就是对当前的 *.java 文件对应的 Class 类进行加锁。而 synchronized 关键字加到非 static 静态方法上就是给对象加锁。 多线程的死锁volatile 关键字作用：使变量在多个线程间可见。通过使用 volatile 关键字，强制的从公共内存中读取变量的值。使用 volatile 关键字增加了实例变量在多个线程之间的可见性，但 volatile 关键字最致命的缺点就是不支持原子性。 关键字 synchronized 和 volatile 比较： 关键字 volatile 是线程同步的轻量实现，所以 volatile 性能肯定要比 synchronized 要好，并且 volatile 只能修饰于变量，而 synchronized 可以修饰方法，以及代码块。 多线程访问 volatile 不会发生阻塞，而 synchronized 会出现阻塞。 volatile 能保证数据的可见性，但不能保证原子性；而 synchronized 可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公有内存中的数据做同步。 关键字 volatile 解决的是变量在多个线程之间的可见性；而 synchronized 关键字解决的是多个线程之间访问资源的同步性。","categories":[{"name":"java 并发知识","slug":"java-并发知识","permalink":"http://yoursite.com/categories/java-并发知识/"}],"tags":[{"name":"对象和变量的并发访问","slug":"对象和变量的并发访问","permalink":"http://yoursite.com/tags/对象和变量的并发访问/"}]},{"title":"java 表达式中的陷阱","slug":"关于字符串的陷阱","date":"2018-07-20T04:10:37.813Z","updated":"2018-07-20T04:10:37.813Z","comments":true,"path":"2018/07/20/关于字符串的陷阱/","link":"","permalink":"http://yoursite.com/2018/07/20/关于字符串的陷阱/","excerpt":"","text":"关于字符串的陷阱JVM 对字符串的处理String java = new String(“Java”) 这句创建了两个字符串对象，一个是 “Java” 这个直接量对应的字符串对象，另外一个是 new String() 构造器返回的字符串对象。Java 程序中创建对象的方法： 通过 new 调用构造器创建 Java 对象 通过 Class 对象的 newInstance() 方法调用构造器创建 Java 对象 通过 Java 的反序列化机制从 IO 流中恢复 Java 对象 通过 Java 对象提供的 clone() 方法复制一个新的 Java 对象对于字符串以及 Byte、Short、Int、Long、Character、Float、Double 和 Boolean 这些基本类型的包装类直接量的方式来创建 Java 对象 Integer in = 5； 通过简单的算法表达式，连接运算来创建 Java 对象 String str = “a” + “b”; （如果这个字符串表达式的值在编译时确定下来，那么 JVM 会在编译时计算该字符串变量的值，并让它指向字符串池中对应的字符串。如果这些算法表达式都是字符串直接量、整数直接量，没有变量和方法参与，那么就可以在编译期就可以确定字符串的值；如果使用了变量、调用了方法，那么只有等到运行时才能确定字符串表达式的值；如果字符串连接运算所有的变量都可执行 “宏替换”（使用 final 修饰的变量），那在编译时期也能确定字符串连接表达式的值） 对于 Java 程序的字符直接量，JVM 会使用一个字符串池来保护它们；当第一次使用某个字符串直接量时，JVM 会将它放入字符串池进行缓存。在一般的情况下，字符串池中的字符串对象不会被垃圾回收器回收，当程序再次需要使用该字符串时，无需重新创建一个新的字符串，而是直接让引用变量指向字符串池中已有的字符串。 不可变的字符串 String 类是一个不可变类，当一个 String 对象创建完成后，该 String 类里包含的字符序列就被固定下来，以后永远不能修改。 如果程序需要一个字符序列会发生改变的字符串，那么建议使用 StringBuilder （效率比 StringBuffer 高）字符串比较 如果要比较两个字符串是否相同，用 == 进行判断就行，但如果要判断两个字符串所包含的字符序列是否相同，则应该用 String 重写过的 equals() 方法进行比较。 123456789101112131415161718192021222324252627public boolean equals(Object anObject) &#123;//如果两个字符串相同if (this == anObject) &#123;return true;&#125;//如果anObject是String类型if (anObject instanceof String) &#123;String anotherString = (String)anObject;//n代表字符串的长度int n = value.length;//如果两个字符串长度相等if (n == anotherString.value.length) &#123;//获取当前字符串、anotherString底层封装的字符数组char v1[] = value;char v2[] = anotherString.value;int i = 0;//逐一比较v1 和 v2数组中的每个字符while (n-- != 0) &#123;if (v1[i] != v2[i])return false;i++;&#125;return true;&#125;&#125;return false;&#125; 还可以使用 String 提供的 compareTo() 方法返回两个字符串的大小 123456789101112131415161718public int compareTo(String anotherString) &#123;int len1 = value.length;int len2 = anotherString.value.length;int lim = Math.min(len1, len2);char v1[] = value;char v2[] = anotherString.value;int k = 0;while (k &lt; lim) &#123;char c1 = v1[k];char c2 = v2[k];if (c1 != c2) &#123;return c1 - c2;&#125;k++;&#125;return len1 - len2;&#125; 表达式类型的陷阱表达式类型的自动提升 所有 byte、short、char类型将被提升到 int 类型参与运算 整个算术表达式的数据类型自动提升到与表达式中最高等级操作数同样的类型，操作数的等级排列如下：char -&gt; int -&gt; long -&gt;float -&gt; double byte -&gt; short -&gt; int -&gt; long -&gt;float -&gt; double复合赋值运算符的陷阱Java 语言允许所有的双目运算符和 = 一起结合组成复合赋值运算符，如 +=、-=、*=、/=、%= 、&amp;= 等，复合赋值运算符包含了一个隐式的类型转换。123//下面这两条语句不等价a = a + 5; //a += 5; //实际上等价于 a = (a的类型) (a + 5); 复合赋值运算符会自动的将它计算的结果值强制转换为其左侧变量的类型。 输入法导致的陷阱注释的字符必须合法转义字符的陷阱 慎用字符的 Unicode 转义形式 中止行注释的转义字符泛型可能引起的错误原始类型变量的赋值 当程序把一个原始类型的变量赋给一个带有泛型信息的变量时，总是可以通过编译（只是会提示警告信息） 当程序试图访问带泛型声明的集合的集合元素时，编译器总是把集合元素 当成泛型类型处理（它并不关心集合里集合元素的实际类型） 当程序试图访问带泛型声明的集合的集合元素时，JVM会遍历每个集合元素自动执行强制转型，如果集合元素的实际类型与集合所带的泛型信息不匹配，运行时将引发 ClassCastException原始类型带来的擦除当把一个具有泛型信息的对象赋给另一个没有泛型信息的变量时，所有在尖括号之间的类型信息都会丢弃。创建泛型数组的陷阱Java 中不允许创建泛型数组正则表达式的陷阱有些符号本身就是正则表达式，我们需要对符号做转义运算。多线程的陷阱不要调用 run 方法开启线程是用 start() 方法，而不是 run() 方法。静态的同步方法对于同步代码块而言，程序必须显式为它指定同步监视器；对于同步非静态方法而言，该方法的同步监视器是 this —— 即调用该方法的 Java 对象；对于静态的同步方法而言，该方法的同步监视器不是 this，而是该类本身。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"表达式中的陷阱","slug":"表达式中的陷阱","permalink":"http://yoursite.com/tags/表达式中的陷阱/"}]},{"title":"Android 编程知识","slug":"ListView 和 Adapter数据适配器简单介绍","date":"2018-07-20T04:10:37.813Z","updated":"2018-07-20T04:10:37.813Z","comments":true,"path":"2018/07/20/ListView 和 Adapter数据适配器简单介绍/","link":"","permalink":"http://yoursite.com/2018/07/20/ListView 和 Adapter数据适配器简单介绍/","excerpt":"","text":"ListView 和 Adapter数据适配器简单介绍ListView 显示大量的相同格式数据 常用属性： listSelector listView每项在选中、按下等不同状态时的Drawable divider ListView每项间的间隔Drawable dividerHeight ListView每项间间隔的间隔高度 常用方法 setAdapter() 设置数据适配器 setOnItemClickListener() 设置每项点击事件监听 addHeaderView() 添加头视图 addFooterView() 添加脚视图 setEmptyView() 设置数据项为0时的空数据视图Adapter数据适配器将各种数据以合适的形式绑定到控件上像listview, gridview, spinner 等等等控件 都会用到Adapter绑定数据 三种Adapter ArrayAdapter：支持泛型操作，最简单的一个Adapter，只能展现一行文字 SimpleAdapter：同样具有良好扩展性的一个Adapter，可以自定义多种效果 BaseAdapter：抽象类，实际开发中我们会继承这个类并且重写相关方法，用得最多的一个AdapterArrayAdapt参数1：当前上下文环境参数2：android.R.layout.simple_list_item_1 是android自带的一个简单布局 里面只包含一个id为text1的TextView 也就是参数3 ArrayAdapter只能显示一行数据 显示文本信息 使用这个系统提供的布局就可以android系统还给我们提供了其他一些好用的模板 simple_list_item_1 : 单独一行的文本框 simple_list_item_2 : 两个文本框组成 simple_list_item_checked : 每项都是由一个已选中的列表项 imple_list_item_multiple_choice : 都带有一个复选框 simple_list_item_single_choice : 都带有一个单选钮参数4：绑定的数据 这里使用是string数组 上面提到过ArrayAdapter支持泛型 也可以绑定一个list显示效果绑定了listviewSimpleAdapter simpleAdapter的扩展性最好，可以定义各种各样的布局出来，可以放上ImageView（图片），还可以放上Button（按钮），CheckBox（复选框）等等BaseAdapter BaseAdapter是开发中最常用的适配器ArrayAdapter, SimpleAdapter 都继承于BaseAdapter。BaseAdapter可以完成自己定义的Adapter，可以将任何复杂组合的数据和资源，以任何你想要的显示效果展示给大家。 继承BaseAdapter之后，需要重写以下四个方法：getCount，getItem，getItemId，getView。 系统在绘制ListView之前，将会先调用getCount方法来获取Item的个数。每绘制一个Item就会调用一次getView方法，在getView中引用事先定义好的layout布局确定显示的效果并返回一个View对象作为一个Item显示出来。 这两个方法是自定ListView显示效果中最为重要的，同时只要重写好了这两个方法，ListView就能完全按开发者的要求显示。而getItem和getItemId方法将会在调用ListView的响应方法的时候被调用到。 自定义布局文件（listview的项的显示效果）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;LinearLayout android:id=&quot;@+id/title&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center_vertical&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:id=&quot;@+id/et_id2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;0.8&quot; android:hint=&quot;id&quot; android:inputType=&quot;none&quot; /&gt; &lt;TextView android:id=&quot;@+id/et_name2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1.5&quot; android:hint=&quot;姓名&quot; android:maxLength=&quot;4&quot; android:maxLines=&quot;1&quot; /&gt; &lt;TextView android:id=&quot;@+id/et_author2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:hint=&quot;作者&quot; android:maxLength=&quot;1&quot; android:maxLines=&quot;1&quot; /&gt; &lt;TextView android:id=&quot;@+id/et_pages2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:hint=&quot;页数&quot; android:inputType=&quot;number&quot; android:maxLength=&quot;3&quot; android:maxLines=&quot;1&quot; /&gt; &lt;TextView android:id=&quot;@+id/et_price2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:hint=&quot;价格&quot; android:inputType=&quot;number&quot; android:maxLength=&quot;3&quot; android:maxLines=&quot;1&quot; /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; Book类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Book extends DataSupport &#123; private int id; private String name; private String author; private int pages; private double price; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; public int getPages() &#123; return pages; &#125; public void setPages(int pages) &#123; this.pages = pages; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125;&#125; MainActivity1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495ublic class MainActivity extends AppCompatActivity &#123; private Button create_database = null; private Button add_data = null; private Button detele_data = null; private Button update_data = null; private Button query_data = null; private LinearLayout title = null; private ListView listViewcontent =null; private EditText et_id = null; private EditText et_name = null; private EditText et_author = null; private EditText et_pages = null; private EditText et_price = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(); listener(); &#125;private void listener()&#123; create_database.setOnClickListener( new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Connector.getDatabase(); &#125; &#125; ); add_data.setOnClickListener( new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Book book = new Book(); book.setName(et_name.getText().toString().trim()); book.setAuthor(et_author.getText().toString().trim()); book.setPages(Integer.parseInt(et_pages.getText().toString().trim())); book.setPrice(Integer.parseInt(et_price.getText().toString().trim())); book.save(); &#125; &#125; ); detele_data.setOnClickListener( new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; DataSupport.deleteAll(Book.class, &quot;name = ?&quot;, et_name.getText().toString().trim()); &#125; &#125; ); update_data.setOnClickListener( new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Book book = new Book(); book.setPrice(Double.parseDouble(et_price.getText().toString().trim())); book.updateAll(&quot;name = ? and author = ?&quot;, et_name.getText().toString().trim(),et_author.toString().trim()); &#125; &#125; ); query_data.setOnClickListener( new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; List&lt;Book&gt; books = DataSupport.findAll(Book.class); Log.d(&quot;qgx&quot;, &quot;onClick: &quot;+books.toString()); listViewcontent.setAdapter( new MyAdapter(books,MainActivity.this)); for (Book book : books) &#123; Log.d(&quot;MainActivity&quot;, &quot;book name is&quot; + book.getName()); Log.d(&quot;MainActivity&quot;, &quot;book author is&quot; + book.getAuthor()); Log.d(&quot;MainActivity&quot;, &quot;book pages is&quot; + book.getPages()); Log.d(&quot;MainActivity&quot;, &quot;book price is&quot; + book.getPrice()); &#125; &#125; &#125; );&#125; //关联控件 private void findViewById() &#123; create_database = (Button) findViewById(R.id.create_database); add_data = (Button) findViewById(R.id.add_data); update_data = (Button) findViewById(R.id.update_data); query_data = (Button) findViewById(R.id.query_data); detele_data = (Button) findViewById(R.id.detele_data); et_id =(EditText) findViewById(R.id.et_id); et_name =(EditText) findViewById(R.id.et_name); et_author =(EditText) findViewById(R.id.et_author); et_pages =(EditText) findViewById(R.id.et_pages); et_price =(EditText) findViewById(R.id.et_price); title = (LinearLayout) findViewById(R.id.title); listViewcontent =(ListView) findViewById(R.id.content); &#125;&#125; MyAdapter12345678910111213141516171819202122232425262728293031323334353637383940public class MyAdapter extends BaseAdapter&#123; private List&lt;Book&gt; books; private LayoutInflater inflater; public MyAdapter(List&lt;Book&gt; books,Context context) &#123; this.books = books; this.inflater=LayoutInflater.from(context); &#125; @Override public int getCount() &#123; return books==null?0:books.size(); &#125; @Override public Object getItem(int i) &#123; return books.get(i); &#125; @Override public long getItemId(int i) &#123; return i; &#125; @Override public View getView(int i, View view, ViewGroup viewGroup) &#123; //加载布局为一个视图 view=inflater.inflate(R.layout.item_book,null); Book book = (Book)getItem(i) ; TextView et_id2 = view.findViewById(R.id.et_id2); TextView et_name2 = view.findViewById(R.id.et_name2); TextView et_author2 = view.findViewById(R.id.et_author2); TextView et_pages2 = view.findViewById(R.id.et_pages2); TextView et_price2 = view.findViewById(R.id.et_price2); et_id2.setText(book.getId()+&quot;&quot;); et_author2.setText(book.getAuthor()); et_name2.setText(book.getName()); et_pages2.setText(book.getPages()+&quot;&quot;); et_price2.setText(book.getPrice()+&quot;&quot;); return view; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"litepal","slug":"litepal","permalink":"http://yoursite.com/tags/litepal/"}]},{"title":"java 基础知识","slug":"集合框架","date":"2018-07-20T04:10:37.813Z","updated":"2018-07-20T04:10:37.813Z","comments":true,"path":"2018/07/20/集合框架/","link":"","permalink":"http://yoursite.com/2018/07/20/集合框架/","excerpt":"","text":"集合框架1：String类：字符串(重点) (1)多个字符组成的一个序列，叫字符串。生活中很多数据的描述都采用的是字符串的。而且我们还会对其进行操作。所以，java就提供了这样的一个类供我们使用。 (2)创建字符串对象 123456789101112131415161718192021222324252627282930313233A:String():无参构造举例： String s = new String(); s = &quot;hello&quot;; sop(s);B:String(byte[] bys):传一个字节数组作为参数 *****举例 byte[] bys = &#123;97,98,99,100,101&#125;; String s = new String(bys); sop(s);C:String(byte[] bys,int index,int length):把字节数组的一部分转换成一个字符串 *****举例 byte[] bys = &#123;97,98,99,100,101&#125;; String s = new String(bys,1,2); sop(s);D:String(char[] chs):传一个字符数组作为参数 *****举例 char[] chs = &#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;&#125;; String s = new String(chs); sop(s);E:String(char[] chs,int index,int length):把字符数组的一部分转换成一个字符串 *****举例 char[] chs = &#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;&#125;; String s = new String(chs,1,2); sop(s);F:String(String str):把一个字符串传递过来作为参数 char[] chs = &#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;&#125;; String ss = new String(s); sop(ss);G:直接把字符串常量赋值给字符串引用对象(最常用) *****举例 String s = &quot;hello&quot;; sop(s); (3)面试题123456789101112A:请问String s = new String(&quot;hello&quot;);创建了几个对象。 两个。一个&quot;hello&quot;字符串对象，在方法区的常量池；一个s对象，在栈内存。B:请写出下面的结果String s1 = new String(&quot;abc&quot;);Strign s2 = new String(&quot;abc&quot;);String s3 = &quot;abc&quot;;String s4 = &quot;abc&quot;;sop(s1==s2); //falsesop(s1==s3); //falsesop(s3==s4); //trueC:字符串对象一旦被创建就不能被改变。指的是字符串常量值不改变。 (4)字符串中各种功能的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657A:判断boolean equals(Object anObject):判断两个字符串的内容是否相同，复写了Object的方法boolean equalsIgnoreCase(String anotherString):判断两个字符串的内容是否相同，不区分大小写boolean contains(String s):判断一个字符串中是否包含另一个字符串注意：判断字符串是否包含特殊字符.直接表示为str.contains(&quot;.&quot;)boolean endsWith(String suffix):测试此字符串是否以指定的后缀结束boolean startsWith(String suffix):测试此字符串是否以指定的前缀开始boolean isEmpty():测试字符串是否为空B:获取int length():返回此字符串的长度char charAt(int index):返回指定索引处的 char值int indexOf(int ch):返回指定字符在此字符串中第一次出现处的索引。 int indexOf(int ch, int fromIndex):返回在此字符串中第一次出现指定字符处的索引， 从指定的索引开始搜索。 int indexOf(String str):返回指定子字符串在此字符串中第一次出现处的索引。 int indexOf(String str, int fromIndex):返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。 int lastIndexOf(int ch)：返回指定字符在此字符串中最后一次出现处的索引。 int lastIndexOf(int ch, int fromIndex) 返回指定字符在此字符串中最后一次出现处的索引,从指定的索引处开始进行反向搜索。 int lastIndexOf(String str) 返回指定子字符串在此字符串中最右边出现处的索引。 int lastIndexOf(String str, int fromIndex) 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。 String substring(int beginIndex) (注意：该方法substring的String是小写！！！)返回一个新的字符串，它是此字符串的一个子字符串。 String substring(int beginIndex, int endIndex) (注意该方法的String是小写！！！)返回一个新字符串，它是此字符串的一个子字符串,包含头不包含尾。 C:转换byte[] getBytes()：(很常用！)从字符串到字节数组的方法void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此字符串复制到目标字符数组。 char[] toCharArray()：(很常用！)从字符串到字符数组的方法static String copyValueOf(char[] data) 返回指定数组中表示该字符序列的 String。 static String copyValueOf(char[] data, int offset, int count) 返回指定数组中表示该字符序列的 String。 static String valueOf(数据类型):把该数据类型的数据转换成字符串。String toLowerCase()：把字符串转换成小写String toUpperCase()：把字符串转换成大写字符串的连接String concat(String str):将指定字符串连接到此字符串的结尾。D:替换String replace(char oldChar, char newChar):用新字符替换旧字符(替换所有)String replace(String target, String replacement):用新的子串换旧串E:分割String[] split(String regex)：根据指定的字符串把一个字符串分割成一个字符串数组F:String trim():去除字符串的前后空格G:int compareTo(String anotherString) 按字典顺序比较两个字符串。 int compareToIgnoreCase(String str) 按字典顺序比较两个字符串，不考虑大小写。 (5)练习12345678910111213141516171819201:模拟登录,给三次机会,并提示还有几次.默认的用户名和密码为admin。 区分大小写。自己从键盘输入用户名和密码。2:给定一个字符串统计,统计大写字母,小写字母,数字出现的个数.注意:不包括特殊字符从键盘输入一个不包含特殊字符的字符串(只有26个字母和0-9组成)。3:给定一个字符串,把它变成首字母大写,其他字母小写的字符串.从键盘输入一个字符串，全部26个字母组成的。4:子串在整串中出现的次数。也就是说:获取一个字符串中,指定的字串在该字符串中出现的次数.例如:&quot;nbasdnbafllgnbahjnbakqqqqlnba&quot; 在这个字符串中，多有个nba.5:对字符串中字符进行自然顺序排序。&quot;basckd&quot;--&gt;&quot;abcdks&quot;先留做思考内容：6:两个字符串的最大相同子串。两个字符串的最大相同子串。比如:&quot;sadabcdfghjkl&quot;werabcdtyu&quot; 2：StringBuffer(1)字符串的缓冲区，是一个容器。(2)它和String的区别它是缓冲区可变长度的。(3)构造方法StringBuffer() 构造一个其中不带字符的字符串缓冲区，初始容量为 16 个字符。StringBuffer(int num) 构造一个不带字符，但具有指定初始容量的字符串缓冲区。StringBuffer(String str) 构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容。(4)常用方法123456789101112131415161718192021A:增加数据append ：添加各种类型的数据insert : 在容器指定位置插入各种类型的数据。B:删除数据deleteCharAt : 删除指定位置的字符delete 还可以用于清空StringBuffer的缓冲区C:替换replaceD:获取 charAt E:长度和容量length() 元素的个数capacity 元素的理论值F:获取元素的位置indexOflastIndexOfG:截取substring(int start)substring(int start,int end)H:反转reverse (5)字符串和StringBuffer的转换String–&gt;StringBuffer通过构造:如:StringBuffer sb = new StringBuffer(String str)StringBuffer–String通过toString方法如:StringBuffer sb = new StringBuffer(); sb.toString(); 3：StringBuilder和StringBuffer的功能是一样的，但是有区别：StringBuffer(JDK1.0)是线程安全的。StringBuilder(JDK1.5)不保证线程安全。一般来说，我们写的程序都是单线程的，所以，用StringBuilder，效率高。JDK版本的升级原则：A:提高效率B:提高安全性C:简化书写 4：基本数据类型的对象包装类(1)为了更方便的操作每个基本数据类型，java对其提供了很多的属性和方法供我们使用。(2)用途：将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能操作该数据。常用的操作之一：用于基本数据类型与字符串之间的转换。 A:方便操作 B:用于和字符串进行相互转换 (3)基本数据类型和对象类型的对应byteByteshort Shortint Integerlong Longfloat Floatdouble Doubleboolean Booleanchar Character(4)构造方法字段摘要：static int MAX_VALUE 值为 2^31-1 的常量，它表示 int 类型能够表示的最大值static int MIN_VALUE 值为 -2^31 的常量，它表示 int 类型能够表示的最小值static Class TYPE 表示基本类型int的Class 实例 Integer(int value) 构造一个新分配的Integer对象，它表示指定的int值。Inreger(String s) 注意：s必须是纯数字的字符串。否则会有异常NumberFormatException (5)几个常用的方法Integer.toBinaryString();以二进制（基数 2）无符号整数形式返回一个整数参数的字符串表示形式。Integer.toOctalString();以八进制（基数 8）无符号整数形式返回一个整数参数的字符串表示形式。Integer.toHexString();以十六进制（基数 16）无符号整数形式返回一个整数参数的字符串表示形式。static int Integer.parseInt(String s) 将字符串参数作为有符号的十进制整数进行解析,字符串必须是int型范围内的数字字符串static int Integer.parseInt(String s,int basic)使用第二个参数指定的基数,将字符串参数解析为有符号的整数.字符串必须是int型范围内的数字字符串short shortValue() 以short类型返回该Integer的值。int intValue() 以int类型返回该Integer的值。static Integer valueOf(int num) 返回一个表示指定的 int 值的 Integer 实例。static Integer valueOf(String s) 返回保存指定的String的值的Integer对象。 static Integer valueOf(String s, int radix)返回一个Integer对象，该对象中保存了用第二个参数提供的基数进行解析时从指定的String中提取的值。(6)类型转换1234567891011121314151617int -- Integerint num = 20;A:Integer i = new Integer(num);B:Integer i = Integer.valueOf(num);Integer -- intInteger i = new Integer(20);A:int num = i.intValue();int -- Stringint num = 20;A:String s = String.valueOf(num);B:String s = &quot;&quot;+num;C:String s = Integer.toString(num);String -- intString s = &quot;20&quot;;A:int num = Integer.parseInt(s);B:Integer i = new Integer(s);或者Integer i = Integer.valueOf(s); int num = i.intValue(); 5、集合框架：(1)为什么出现集合类？面向对象对事物的体现都是以对象的形式，为了方便对多个对象的操作，就对对象进行存储。集合就是存储对象最常用的一种方式.(2)数组和集合都是容器，两者有何不同？数组长度固定，而集合长度是可变的数组值可以存储对象，还可以存储基本数据类型;而集合只能存储对象数组存储数据类型是固定的，而集合存储的数据类型不固定(3)集合类的特点：集合只能存储对象集合的长度是可变的集合可以存储不同类型的对象(4)集合类框架(重要！！！要分清几种容器间的区别)：Collection:顶层接口 |—&gt;List:列表，元素是有序的(元素带角标索引)，可以有重复元素,可以有null元素。 |—&gt;ArrayList(JDK1.2):底层的数据结构是数组数据结构，特点是查询速度快(因为带角标)， 但是增删速度稍慢,因为当元素多时，增删一个元素则所有元素的角标都得改变 线程不同步。默认长度是10，当超过长度时，按50%延长集合长度。 |—&gt;LinkedList(JDK1.2):底层数据结构式链表数据结构(即后面一个元素记录前一个)， 特点：查询速度慢，因为每个元素只知道前面一个元素，但增删速度快 因为元素再多，增删一个，只要让其前后的元素重新相连即可 线程是不同步的。 |—&gt;Vector(JDK1.0):底层数据结构是数组数据结构.特点是查询和增删速度都很慢。默认长度是10，当超过长度时,按100%延长集合长度。线程同步。(Vector功能跟ArrayList功能一模一样，已被ArrayList替代) List使用注意！|—&gt;ArrayList:(1)当往ArrayList里面存入元素没什么要求时，即只要求有序就行时； (2)当往ArrayList里面存入元素要求不重复时，比如存入学生对象，当同名同姓时 视为同一个人，则不往里面存储。则定义学生对象时，需复写equals方法1234567 public boolean equals(Object obj) &#123;if(!(obj instanceof Student))return false;Student stu = (Student)obj;return this.name.equals(stu.name)&amp;&amp;this.age==stu.age; &#125; 则往ArrayList集合通过add存入学生对象时，集合底层自己会调用学生类的equals方法， 判断重复学生则不存入。注：对于List集合，无论是add、contains、还是remove方法，判断元素是否相同， 都是通过复写equals方法来判断！ |—&gt;LinkedList(1)LinkLedist的特有方法：boolean offerFirst(E e) 在此列表的开头插入指定的元素。boolean offerLast(E e) 在此列表末尾插入指定的元素。E peekFirst() 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。E peekLast() 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null。E pollFirst() 获取并移除此列表的第一个元素；如果此列表为空，则返回 null。E pollLast() 获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。(2)通过LinkLedist的特有方法，可以实现某些数据特殊方式的存取，比如堆栈和队列。 一般情况下，使用哪种List接口下的实现类呢？如果要求增删快，考虑使用LinkedList如果要求查询快，考虑使用ArrayList如果要求线程安全，考虑使用Vector。 |—&gt;Set:集合，元素是无序的(因为没有索引)，元素不可以重复。可以有null元素。 |—&gt;HashSet(JDK1.2):底层数据结构是哈希表、存取速度快、元素唯一、线程不同步。保证性元素唯一的原理:先判断元素的hashCode值是否相同，再判断两元素的equals方法是否为true(往HashSet里面存的自定义元素要复写hashCode和equals方法，以保证元素的唯一性！)|—&gt;TreeSet:底层数据结构式二叉树。可以对Set集合中的元素进行排序。元素有序、线程不同步。保证元素唯一性的依据：compareTo方法return 0TreeSet排序的第一种方式:让元素自身具备比较性，比如八种基本数据类型或则字符串，实现Compareble接口,覆盖compareTo方法，此方式是元素的自然顺序TreeSet排序的第一种方式:当元素自身不具备比较性(比如存储学生对象时)或者具备的比较性不是我们所需要的比较性时(比如想字符串的长度排序),此时就需要让集合自身具备自定义的比较性。那如何让集合自身具备比较性呢？可在集合初始化时，就让集合具备比较方式。即定义一个类，实现Comparator接口，覆盖compare方法。 Set集合使用注意事项：(1)HashSet: 通过new的方式往HashSet里面存的元素的hashCode都不同，但通常我们定义对象， 比如学生对象时，虽然是new的两个学生对象，但是当他们name和age一样时，我们认为是 同一个对象，所以为了保证元素的唯一性，我们通常在往HashSet集合里面存储元素时， 在定义对象的类中通常复写hashCode和equals方法。1234567891011 public int hashCode() &#123;return name.hashCode()+age*39; &#125; public boolean equals(Object obj) &#123;if(!(obj instanceof Student))return false;Student stu = (Student)obj;return this.name.equals(stu.name)&amp;&amp;this.age==stu.age; &#125; HashSet是如何保证元素唯一性的呢？ 如果两元素的hashCode值不同，则不会调用equals方法 如果两元素的hashCode值相同，则继续判断equals是否返回true； hashCode和equals方法虽然定义在自定义对象类里面，但不是我们手动调用 而是往HashSet集合里面存储元素的时候，集合底层自己调用hashCode和equals 它自己拿对象去判断，自己判断两元素是否是同一个元素。 (2)TreeSet: TreeSet要求往里面存的元素具备比较性，否则会报错。 TreeSet排序的第一种方式:让元素自身具备比较性 定义对象类，实现Compareble接口,复写compareTo方法，此方式是元素的自然顺序12345678910111213141516171819202122232425262728 class Student implements Comparable &#123;private String name;private int age;public Student(String name,int age)&#123;this.name=name;this.age=age;&#125;public String getName()&#123;return name;&#125;public int getAge()&#123;return age;&#125;public int compareTo(Object obj)&#123;if(!(obj instanceof Student))throw new RuntimeException(&quot;不是学生对象！&quot;);Student stu = (Student)obj;int num = this.age-stu.age;if(num==0)return this.name.compareTo(stu.name);return num;&#125;&#125; TreeSet排序的第一种方式:让集合具备比较性当元素自身不具备比较性(比如存储学生对象时)或者具备的比较性不是我们所需要的比较性时(比如想字符串的长度排序),此时就需要让集合自身具备自定义的比较性。那如何让集合自身具备比较性呢？可在集合初始化时，就让集合具备比较方式。即定义一个类，实现Comparator接口，覆盖compare方法。123456789101112131415161718192021222324class StringLengthComparator implements Comparator&#123;public int compare(Object obj1,Object obj2)&#123;String s1 = (String)obj1;String s2 = (String)obj2;int num = new Integer(s1.length()).compareTo(new Integer(s2.length()));if(num==0)return s1.compareTo(s2);return num;&#125;&#125;class TreeSetTest&#123;public static void main(String[] args)&#123;TreeSet ts = new TreeSet(new StringLengthComparator());ts.add(&quot;addfg&quot;);ts.add(&quot;dfg&quot;);ts.add(&quot;agtuug&quot;);ts.add(&quot;vgjkg&quot;);sop(ts);&#125;&#125; 基本数据类型或字符串对象均实现了Comparable接口，故同种类型基本数据间具备比较性，即自然顺序。 Map:顶层接口,该集合存储的是键值对,而且键是唯一的,Map和Set很像,Set集合底层就是使用了Map集合。Map集合没有迭代器，要取出元素必须先将Map集合转换成Set集合才能遍历元素 |—&gt;HashTable(JDK1.0):底层是哈希表数据结构；不可以使用null键和null值；用作键的对象必须实现hashCode和equals方法来保证键的唯一性线程同步，效率低 |—&gt;HashMap(JDK1.2):底层是哈希表数据结构；允许使用null键和null值；线程不同步，效率高；保证元素唯一性的:原理：先判断元素的hashCode值是否相同，再判断两元素的equals方法是否为true(往HashSet里面存的自定义元素要复写hashCode和equals方法，以保证元素的唯一性！)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Student &#123;private String name;private int age;public Student(String name, int age) &#123;super();this.name = name;this.age = age;&#125;public int getAge() &#123;return age;&#125;public void setAge(int age) &#123;this.age = age;&#125;public String getName() &#123;return name;&#125;public void setName(String name) &#123;this.name = name;&#125;@Overridepublic int hashCode()&#123;return name.hashCode()+age*34;&#125;@Overridepublic boolean equals(Object obj)&#123;if(!(obj instanceof Student))return false;Student stu = (Student)obj;return this.name.equals(stu.name)&amp;&amp;this.age==stu.age;&#125;public class HashMapDemo1 &#123;public static void main(String[] args) &#123;Map&lt;Student , String&gt; hmap = new HashMap&lt;Student , String&gt;();hmap.put(new Student(&quot;001&quot;,20), &quot;beijing&quot;);hmap.put(new Student(&quot;002&quot;,25), &quot;hebei&quot;);hmap.put(new Student(&quot;003&quot;,50), &quot;hainan&quot;);hmap.put(new Student(&quot;001&quot;,20), &quot;beijing&quot;);System.out.println(hmap.size());Set&lt;Student&gt; keySet = hmap.keySet();Iterator&lt;Student&gt; it = keySet.iterator();while(it.hasNext())&#123;Student stu = it.next();String addr = hmap.get(stu);System.out.println(stu.getName()+&quot;..&quot;+stu.getAge()+&quot;::&quot;+addr);&#125; &#125;&#125; |—&gt;TreeMap(JDK1.0):底层是二叉树结构；允许使用null键和null值；线程不同步；可以给Map集合中的键进行排序.TreeMap排序的第一种方式:让元素自身具备比较性，比如八种基本数据类型或则字符串，实现Compareble接口,覆盖compareTo方法，此方式是元素的自然顺序TreeMap排序的第一种方式:当元素自身不具备比较性(比如存储学生对象时)或者具备的比较性不是我们所需要的比较性时(比如想字符串的长度排序),此时就需要让集合自身具备自定义的比较性。那如何让集合自身具备比较性呢？可在集合初始化时，就让集合具备比较方式。即定义一个类，实现Comparator接口，覆盖compare方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Student implements Comparable&lt;Student&gt;&#123;private String name;private int age;public Student(String name, int age) &#123;super();this.name = name;this.age = age;&#125;public int getAge() &#123;return age;&#125;public void setAge(int age) &#123;this.age = age;&#125;public String getName() &#123;return name;&#125;public void setName(String name) &#123;this.name = name;&#125;@Overridepublic int compareTo(Student stu) &#123;int num = newInteger(this.age).compareTo(new Integer(stu.age));if(num==0)return this.name.compareTo(stu.name);return num;&#125;&#125;public class HashMapDemo1 &#123;public static void main(String[] args) &#123;Map&lt;Student , String&gt; tmap = new TreeMap&lt;Student , String&gt;();tmap.put(new Student(&quot;001&quot;,20), &quot;beijing&quot;);tmap.put(new Student(&quot;002&quot;,25), &quot;hebei&quot;);tmap.put(new Student(&quot;003&quot;,50), &quot;hainan&quot;);tmap.put(new Student(&quot;001&quot;,20), &quot;beijing&quot;);System.out.println(tmap.size());Set&lt;Student&gt; keySet1 = tmap.keySet();Iterator&lt;Student&gt; it1 = keySet1.iterator();while(it1.hasNext())&#123;Student stu = it1.next();String addr = tmap.get(stu);System.out.println(stu.getName()+&quot;..&quot;+stu.getAge()+&quot;::&quot;+addr);&#125; &#125;&#125; Iterator：对collection进行迭代的迭代器.迭代器取代了Enumeration。迭代器和枚举的区别：迭代器允许调用者利用定义良好的语义在迭代期间从迭代器所指向的collection移除元素方法名称得到了改进，简化书写LisIterator：系列表迭代器，允许程序员按任一方向遍历列表、迭代期间修改列表Comparable：此接口强行对实现它的每个类的对象进行整体自然排序。使元素具备比较性Comparator：强行对某个对象collection进行整体排序的比较函数，使集合具备比较性Collections：此类完全由在 collection 上进行操作或返回 collection 的静态方法组成。Arrays：此类包含用来操作数组(比如排序和搜索)的各种静态方法","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"集合框架","slug":"集合框架","permalink":"http://yoursite.com/tags/集合框架/"}]},{"title":"java 基础知识(四)","slug":"java的内存回收","date":"2018-07-20T04:10:37.813Z","updated":"2018-07-20T04:10:37.813Z","comments":true,"path":"2018/07/20/java的内存回收/","link":"","permalink":"http://yoursite.com/2018/07/20/java的内存回收/","excerpt":"","text":"java的内存回收Java 引用的种类 JVM 垃圾回收机制，是否回收一个对象的标准在于：是否还有引用变量引用该对象？只要有引用变量引用该对象，垃圾回收机制就不会回收它。Java 语言对对象的引用有： 强引用 软引用 弱引用 虚引用 强引用：程序创建一个对象，并把这个对象赋给一个引用变量，这个引用变量就是强引用。当一个对象被一个或者一个以上的强引用变量所引用时，它处于可达状态，它是不会被系统的垃圾回收机制回收。软引用 软引用：需要通过 SoftReference 类来实现，当一个对象只具有软引用时，它有可能会被垃圾回收机制回收。对于只有软引用的对象而言，当系统内存空间足够时，它不会被系统回收，程序也可使用该对象；当系统内存空间不足时，系统将会回收它。 弱引用：和软引用有点相似，区别在于弱引用所引用对象的生存期更短。 虚引用：主要用于跟踪对象被垃圾回收的状态，虚引用不能单独使用，虚引用必须和引用队列联合使用。 Java 的内存泄漏ArrayList.java 中的 remove 方法1234567891011public E remove(int index) &#123;rangeCheck(index);modCount++;E oldValue = elementData(index);int numMoved = size - index - 1;if (numMoved &gt; 0)System.arraycopy(elementData, index+1, elementData, index,numMoved);elementData[--size] = null; // clear to let GC do its workreturn oldValue;&#125; 1234567891011其中 elementData[–size] = null; // clear to let GC do its work 语句是清除数组元素的引用，避免内存的泄漏，如果没有这句的话，那么就是只有两个作用：修饰 Stack 的属性，也就是将值减 1；返回索引为 size -1 的值。 垃圾回收机制 跟踪并监控每个 Java 对象，当某个对象处于不可达状态时，回收该对象所占用的内存。 清理内存分配，回收过程中产生的内存碎片。垃圾回收机制的基本算法对于一个垃圾回收器的设计算法来说，大概有如下几个设计： 串行回收 和 并行回收 12串行回收：不管系统有多少个 CPU，始终使用一个 CPU 来执行垃圾回收操作并行回收：把整个回收工作拆分成多部分，每个部分由一个 CPU 负责，从而让多个 CPU 并行回收 并发执行 和 应用程序停止 压缩 和 不压缩 和 复制123 复制：将堆内分成两个相同的空间，从根开始访问每一个关联的可达对象，将空间A的可达对象全部复制到空间B，然后一次性回收整个空间A。标记清除：也就是 不压缩 的回收方式。垃圾回收器先从根开始访问所有可达对象，将它们标记为可达状态，然后再遍历一次整个内存区域，把所有没有标记为可达的对象进行回收处理。 标记压缩：这是压缩方式，这种方式充分利用上述两种算法的优点，垃圾回收器先从根开始访问所有可达对象，将他们标记为可达状态，接下来垃圾回收器会将这些活动对象搬迁在一起，这个过程叫做内存压缩，然后垃圾回收机制再次回收那些不可达对象所占用的内存空间，这样就避免了回收产生的内存碎片。 堆内存的分代回收 Young 代 Old 代 Permanent 代内存管理小技巧 尽量使用直接量 使用 StringBuilder 和 StringBuffer 进行字符串拼接 尽早释放无用对象的引用 尽量少用静态变量 避免在经常调用的方法、循环中创建 Java 对象 缓存经常使用的对象 尽量不要使用 finalize 方法 考虑使用 SoftReference","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java的内存回收","slug":"java的内存回收","permalink":"http://yoursite.com/tags/java的内存回收/"}]},{"title":"Intellij IDEA 快捷键整理","slug":"Intellij IDEA 快捷键整理","date":"2018-07-20T04:10:37.813Z","updated":"2018-07-20T04:10:37.813Z","comments":true,"path":"2018/07/20/Intellij IDEA 快捷键整理/","link":"","permalink":"http://yoursite.com/2018/07/20/Intellij IDEA 快捷键整理/","excerpt":"","text":"Intellij IDEA 快捷键整理####【常规】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980Ctrl+Shift + Enter，语句完成“！”，否定完成，输入表达式时按 “！”键Ctrl+E，最近的文件Ctrl+Shift+E，最近更改的文件Shift+Click，可以关闭文件Ctrl+[ OR ]，可以跑到大括号的开头与结尾Ctrl+F12，可以显示当前文件的结构Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择Ctrl+N，可以快速打开类Ctrl+Shift+N，可以快速打开文件Alt+Q，可以看到当前方法的声明Ctrl+P，可以显示参数信息Ctrl+Shift+Insert，可以选择剪贴板内容并插入Alt+Insert，可以生成构造器/Getter/Setter等Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catchCtrl+Enter，导入包，自动修正Ctrl+Alt+L，格式化代码Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作Ctrl+Alt+O，优化导入的类和包Ctrl+R，替换文本Ctrl+F，查找文本Ctrl+Shift+Space，自动补全代码Ctrl+空格，代码提示（与系统输入法快捷键冲突）Ctrl+Shift+Alt+N，查找类中的方法或变量Alt+Shift+C，最近的更改Alt+Shift+Up/Down，上/下移一行Shift+F6，重构 - 重命名Ctrl+X，删除行Ctrl+D，复制行Ctrl+/或Ctrl+Shift+/，注释（//或者/**/）Ctrl+J，自动代码（例如：serr）Ctrl+Alt+J，用动态模板环绕Ctrl+H，显示类结构图（类的继承层次）Ctrl+Q，显示注释文档Alt+F1，查找代码所在位置Alt+1，快速打开或隐藏工程面板Ctrl+Alt+left/right，返回至上次浏览的位置Alt+left/right，切换代码视图Alt+Up/Down，在方法间快速移动定位Ctrl+Shift+Up/Down，向上/下移动语句F2 或 Shift+F2，高亮错误或警告快速定位Tab，代码标签输入完成后，按 Tab，生成代码Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失Alt+F3，逐个往下查找相同文本，并高亮显示Ctrl+Up/Down，光标中转到第一行或最后一行下Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）Ctrl+Alt+B，跳转到方法实现处Ctrl+Shift+Backspace，跳转到上次编辑的地方Ctrl+O，重写方法Ctrl+Alt+Space，类名自动完成Ctrl+Alt+Up/Down，快速跳转搜索结果Ctrl+Shift+J，整合两行Alt+F8，计算变量值Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本Ctrl+Alt+Shift+V，简单粘贴Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口F12，把焦点从编辑器移到最近使用的工具窗口Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器Ctrl+W，可以选择单词继而语句继而行继而函数Ctrl+Shift+W，取消选择光标所在词Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置Ctrl+I，实现方法Ctrl+Shift+U，大小写转化Ctrl+Y，删除当前行Shift+Enter，向下插入新行psvm/sout，main/System.out.println(); Ctrl+J，查看更多Ctrl+Shift+F，全局查找Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找Ctrl+Shift+S，高级搜索Ctrl+U，转到父类Ctrl+Alt+S，打开设置对话框Alt+Shift+Inert，开启/关闭列选择模式Ctrl+Alt+Shift+S，打开当前项目/模块属性Ctrl+G，定位行Alt+Home，跳转到导航栏Ctrl+Enter，上插一行Ctrl+Backspace，按单词删除Ctrl+&quot;+/-&quot;，当前方法展开、折叠Ctrl+Shift+&quot;+/-&quot;，全部展开、折叠 【调试部分、编译】1234567891011121314151617181920212223242526272829303132Ctrl+F2，停止Alt+Shift+F9，选择 DebugAlt+Shift+F10，选择 RunCtrl+Shift+F9，编译Ctrl+Shift+F10，运行Ctrl+Shift+F8，查看断点F8，步过F7，步入Shift+F7，智能步入Shift+F8，步出Alt+Shift+F8，强制步过Alt+Shift+F7，强制步入Alt+F9，运行至光标处Ctrl+Alt+F9，强制运行至光标处F9，恢复程序Alt+F10，定位到断点Ctrl+F8，切换行断点Ctrl+F9，生成项目Alt+1，项目Alt+2，收藏Alt+6，TODOAlt+7，结构Ctrl+Shift+C，复制路径Ctrl+Alt+Shift+C，复制引用，必须选择类名Ctrl+Alt+Y，同步Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）Shift+F12，还原默认布局Ctrl+Shift+F12，隐藏/恢复所有窗口Ctrl+F4，关闭Ctrl+Shift+F4，关闭活动选项卡Ctrl+Tab，转到下一个拆分器Ctrl+Shift+Tab，转到上一个拆分器 【重构】123456Ctrl+Alt+Shift+T，弹出重构菜单Shift+F6，重命名F6，移动F5，复制Alt+Delete，安全删除Ctrl+Alt+N，内联 ####【查找】123456789101112Ctrl+F，查找Ctrl+R，替换F3，查找下一个Shift+F3，查找上一个Ctrl+Shift+F，在路径中查找Ctrl+Shift+R，在路径中替换Ctrl+Shift+S，搜索结构Ctrl+Shift+M，替换结构Alt+F7，查找用法Ctrl+Alt+F7，显示用法Ctrl+F7，在文件中查找用法Ctrl+Shift+F7，在文件中高亮显示用法","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"http://yoursite.com/categories/杂七杂八/"}],"tags":[{"name":"Intellij IDEA 快捷键整理","slug":"Intellij-IDEA-快捷键整理","permalink":"http://yoursite.com/tags/Intellij-IDEA-快捷键整理/"}]},{"title":"桥接模式","slug":"桥接模式","date":"2018-07-20T04:10:37.813Z","updated":"2018-07-20T04:10:37.813Z","comments":true,"path":"2018/07/20/桥接模式/","link":"","permalink":"http://yoursite.com/2018/07/20/桥接模式/","excerpt":"","text":"桥接模式定义 桥接模式即将抽象部分与它的实现部分分离开来，使他们都可以独立变化。 桥接模式将继承关系转化成关联关系，它降低了类与类之间的耦合度，减少了系统中类的数量，也减少了代码量。 将抽象部分与他的实现部分分离这句话不是很好理解，其实这并不是将抽象类与他的派生类分离，而是抽象类和它的派生类用来实现自己的对象。这样还是不能理解的话。我们就先来认清什么是抽象化，什么是实现化，什么是脱耦。 抽象化：其概念是将复杂物体的一个或几个特性抽出去而只注意其他特性的行动或过程。在面向对象就是将对象共同的性质抽取出去而形成类的过程。 实现化：针对抽象化给出的具体实现。它和抽象化是一个互逆的过程，实现化是对抽象化事物的进一步具体化。 脱耦：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。 对于那句话：将抽象部分与他的实现部分分离套用《大话设计模式》里面的就是实现系统可能有多个角度分类，每一种角度都可能变化，那么把这种多角度分类给分离出来让他们独立变化，减少他们之间耦合。 桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。 结构桥接模式主要包含如下几个角色： Abstraction：抽象类。 RefinedAbstraction：扩充抽象类。 Implementor：实现类接口。 ConcreteImplementor：具体实现类 。 代码实现Implementor : 定义实现接口。1234interface Implementor &#123; // 实现抽象部分需要的某些具体功能 public void operationImpl();&#125; Abstraction : 定义抽象接口。12345678910111213abstract class Abstraction &#123; // 持有一个 Implementor 对象，形成聚合关系 protected Implementor implementor; public Abstraction(Implementor implementor) &#123; this.implementor = implementor; &#125; // 可能需要转调实现部分的具体实现 public void operation() &#123; implementor.operationImpl(); &#125;&#125; ConcreteImplementor : 实现 Implementor 中定义的接口。123456789101112131415class ConcreteImplementorA implements Implementor &#123; @Override public void operationImpl() &#123; // 真正的实现 System.out.println(&quot;具体实现A&quot;); &#125; &#125;class ConcreteImplementorB implements Implementor &#123; @Override public void operationImpl() &#123; // 真正的实现 System.out.println(&quot;具体实现B&quot;); &#125; &#125; RefinedAbstraction : 扩展 Abstraction 类。123456789101112class RefinedAbstraction extends Abstraction &#123; public RefinedAbstraction(Implementor implementor) &#123; super(implementor); &#125; public void otherOperation() &#123; // 实现一定的功能，可能会使用具体实现部分的实现方法, // 但是本方法更大的可能是使用 Abstraction 中定义的方法， // 通过组合使用 Abstraction 中定义的方法来完成更多的功能。 &#125;&#125; 测试代码12345678public class BridgePattern &#123; public static void main(String[] args) &#123; Implementor implementor = new ConcreteImplementorA(); RefinedAbstraction abstraction = new RefinedAbstraction(implementor); abstraction.operation(); abstraction.otherOperation(); &#125;&#125; 运行结果12具体实现A其他操作 应用场景123456789101、如果你不希望在抽象和实现部分采用固定的绑定关系，可以采用桥接模式，来把抽象和实现部分分开，然后在程序运行期间来动态的设置抽象部分需要用到的具体的实现，还可以动态切换具体的实现。2、如果出现抽象部分和实现部分都应该可以扩展的情况，可以采用桥接模式，让抽象部分和实现部分可以独立的变化，从而可以灵活的进行单独扩展，而不是搅在一起，扩展一边会影响到另一边。3、如果希望实现部分的修改，不会对客户产生影响，可以采用桥接模式，客户是面向抽象的接口在运行，实现部分的修改，可以独立于抽象部分，也就不会对客户产生影响了，也可以说对客户是透明的。4、如果采用继承的实现方案，会导致产生很多子类，对于这种情况，可以考虑采用桥接模式，分析功能变化的原因，看看是否能分离成不同的纬度，然后通过桥接模式来分离它们，从而减少子类的数目。 要点 如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的联系。 抽象化角色和具体化角色都应该可以被子类扩展。在这种情况下，桥接模式可以灵活地组合不同的抽象化角色和具体化角色，并独立化地扩展。 设计要求实现化角色的任何改变不应当影响客户端，或者说实现化角色的改变对客户端是完全透明的。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"java基础知识(二)","slug":"数组和内存控制","date":"2018-07-20T04:10:37.813Z","updated":"2018-07-20T04:10:37.813Z","comments":true,"path":"2018/07/20/数组和内存控制/","link":"","permalink":"http://yoursite.com/2018/07/20/数组和内存控制/","excerpt":"","text":"数组和内存控制Java的数组是静态的 初始化方式：-1：静态初始化 a：String[] S = new String[]{} b：String[] S = { } - 2：动态初始化 String[] S = new String[5];&apos; 动态初始化由系统分配初始值类型 初始化值 整型（int short byte long) 0 浮点（float double) 0.0 字符(char) &apos;\\u0000&apos; 布尔（boolean) false 引用类型（类 接口 数组） null Java 的数组变量是引用类型的变量，它并不是数组对象本身，只要让数组变量指向有效的数组对象，程序中即可使用该数组变量。 对数组的初始化并不是对数组变量实行初始化，而是要对数组对象初始化—–也就是为该数组对象分配一块连续的内存空间。 所有局部变量都是放在栈内存里保存的，不管是基本类型的变量，还是引用类型的变量，都是存储各自的方法栈里，但引用类型变量所引用的对象【包括数组、普通Java对象】则都是存储在堆内存里面。 对于Java语言来说，堆内存中的对象【不管是数组对象还是普通的Java对象】通常不允许直接访问，为了访问堆内存中的对象，通常智能通过引用变量。 引用变量本质上就是一个指针，只要程序通过引用变量访问属性，或者通过引用变量来调用方法，该引用变量将会被它所引用的对象代替。Runtime异常 NullPointerException（空指针异常） 当通过引用变量来访问实例属性或者调用静态方法时，如果该引用变量还未引用一个有效的对象，程序就会引发空指针异常$ 引用数组类型的数组元素依然是引用类型，因此数组元素里存储的还是引用，它指向另一块内存，这块内存存储了该引用变量所引用的对象。 Java语言避免直接访问堆内存里面的数据可以保证程序的健壮性，如果程序直接访问并修改堆内存中的数据，可能破坏内存中数据的完整性，导致程序Crash数组元素就是变量没有多维数组","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"数组和内存控制","slug":"数组和内存控制","permalink":"http://yoursite.com/tags/数组和内存控制/"}]},{"title":"javaweb (三 )","slug":"ServletConfig讲解","date":"2018-07-20T04:10:37.809Z","updated":"2018-07-20T04:10:37.809Z","comments":true,"path":"2018/07/20/ServletConfig讲解/","link":"","permalink":"http://yoursite.com/2018/07/20/ServletConfig讲解/","excerpt":"","text":"ServletConfig讲解配置Servlet初始化参数在Servlet的配置文件web.xml中，可以使用一个或多个标签为servlet配置一些初始化参数。 123456789101112131415161718192021&lt;servlet&gt; &lt;servlet-name&gt;ServletConfigDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;ServletConfigDemo1&lt;/servlet-class&gt; &lt;!--配置ServletConfigDemo1的初始化参数 --&gt; &lt;init-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;qgx&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;123&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;charset&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletConfigDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/ServletConfigDemo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 通过ServletConfig获取Servlet的初始化参数当servlet配置了初始化参数后，web容器在创建servlet实例对象时，会自动将这些初始化参数封装到ServletConfig对象中，并在调用servlet的init方法时，将ServletConfig对象传递给servlet。进而，我们通过ServletConfig对象就可以得到当前servlet的初始化参数信息。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Enumeration;@WebServlet(name = &quot;ServletConfigDemo1&quot;)public class ServletConfigDemo1 extends HttpServlet &#123; /* * * 定义ServletConfig对象来接收配置的初始化参数 */ private ServletConfig config; /** * 当servlet配置了初始化参数后，web容器在创建servlet实例对象时， * 会自动将这些初始化参数封装到ServletConfig对象中，并在调用servlet的init方法时， * 将ServletConfig对象传递给servlet。进而，程序员通过ServletConfig对象就可以 * 得到当前servlet的初始化参数信息。 */ @Override public void init(ServletConfig config) throws ServletException &#123; super.init(config); this.config = config; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;doGet(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取在web.xml中配置的初始化参数 response.setContentType(&quot;text/html&quot;); String paramVal = this.config.getInitParameter(&quot;name&quot;); //获取指定的初始化参数 response.getWriter().print(paramVal); response.getWriter().print(&quot;&lt;hr/&gt;&quot;); //获取所有的初始化参数 Enumeration&lt;String&gt; e = config.getInitParameterNames(); while(e.hasMoreElements())&#123; String name = e.nextElement(); String value = config.getInitParameter(name); response.getWriter().print(name + &quot;=&quot; + value + &quot;&lt;br/&gt;&quot;); &#125; &#125;&#125; 运行结果如下： ServletContext对象WEB容器在启动时，它会为每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用。 ServletConfig对象中维护了ServletContext对象的引用，开发人员在编写servlet时，可以通过ServletConfig.getServletContext方法获得ServletContext对象。 由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为context域对象。 ServletContext的应用多个Servlet通过ServletContext对象实现数据共享范例：ServletContextDemo2和ServletContextDemo3通过ServletContext对象实现数据共享ServletContextDemo2123456789101112131415161718192021222324import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = &quot;ServletContextDemo2&quot;)public class ServletContextDemo2 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String data = &quot;qgx&quot;; /** *ServletConfig对象中维护了ServletContext对象的引用，开发人员在编写servlet时， *可以通过ServletConfig.getServletContext方法获得ServletContext对象。 */ ServletContext context = this.getServletConfig().getServletContext(); //获得ServletContext对象 context.setAttribute(&quot;data&quot;, data); //将data存储到ServletContext对象中 &#125;&#125; ServletContextDemo31234567891011121314151617181920import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = &quot;ServletContextDemo3&quot;)public class ServletContextDemo3 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; ServletContext context = this.getServletContext(); String data = (String) context.getAttribute(&quot;data&quot;);//从ServletContext对象中取出数据 response.getWriter().print(&quot;data=&quot;+data); &#125;&#125; 先运行ServletContextDemo2，将数据data存储到ServletContext对象中，然后运行ServletContextDemo3就可以从ServletContext对象中取出数据了，这样就实现了数据共享，如下图所示： 获取WEB应用的初始化参数在web.xml文件中使用标签配置WEB应用的初始化参数，如下所示：12345678910&lt;display-name&gt;&lt;/display-name&gt; &lt;!-- 配置WEB应用的初始化参数 --&gt; &lt;context-param&gt; &lt;param-name&gt;url&lt;/param-name&gt; &lt;param-value&gt;jdbc:mysql://localhost:3306/test&lt;/param-value&gt; &lt;/context-param&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; 运行结果： 用servletContext实现请求转发ServletContextDemo51234567891011121314151617181920212223import javax.servlet.RequestDispatcher;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = &quot;ServletContextDemo5&quot;)public class ServletContextDemo5 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String data = &quot;&lt;h1&gt;&lt;font color=&apos;red&apos;&gt;qgx@ljm&lt;/font&gt;&lt;/h1&gt;&quot;; response.getOutputStream().write(data.getBytes()); ServletContext context = this.getServletContext();//获取ServletContext对象 RequestDispatcher rd = context.getRequestDispatcher(&quot;/ServletContextDemo6&quot;);//获取请求转发对象(RequestDispatcher) rd.forward(request, response);//调用forward方法实现请求转发 &#125;&#125; ServletContextDemo61234567891011121314151617import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = &quot;ServletContextDemo6&quot;)public class ServletContextDemo6 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;doGet(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.getOutputStream().write(&quot;servletDemo6&quot;.getBytes()); &#125;&#125; 运行结果： 访问的是ServletContextDemo5，浏览器显示的却是ServletContextDemo6的内容，这就是使用ServletContext实现了请求转发","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://yoursite.com/categories/javaEE/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"}]},{"title":"生成器模式","slug":"生成器模式","date":"2018-07-20T04:10:37.809Z","updated":"2018-07-20T04:10:37.809Z","comments":true,"path":"2018/07/20/生成器模式/","link":"","permalink":"http://yoursite.com/2018/07/20/生成器模式/","excerpt":"","text":"生成器模式定义 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。生成器模式利用一个导演者对象和具体建造者对象一个一个地建造出所有的零件，从而建造出完整的对象。 四个要素： Builder：生成器接口，定义创建一个Product对象所需要的各个部件的操作。 ConcreteBuilder：具体的生成器实现，实现各个部件的创建，并负责组装Product对象的各个部件，同时还提供一个让用户获取组装完成后的产品对象的方法。 Director：指导者，也被称导向者，主要用来使用Builder接口，以一个统一的过程来构建所需要的Product对象 Product：产品，表示被生成器构建的复杂对象，包含多个部件。 示例 网上有用KFC的例子来描述生成器模式，比较通俗易懂。 假设KFC推出两种套餐：奥尔良鸡腿堡套餐和香辣鸡腿堡套餐。 奥尔良套餐包括：一个奥尔良鸡腿堡、一个炸鸡翅、一杯雪碧。 鸡腿堡套餐包括：一个香辣鸡腿堡、一份薯条、一杯可乐。 每份套餐都是：主食、副食、饮料。 KFC服务员要根据顾客的要求来提供套餐，那这个需求里面什么是固定的，什么是变化的呢？很明显顾客都是要的套餐，顾客的目的是一样的。 套餐里面都是主食、副食、饮料，这也是固定的。至于主食是什么、副食是什么、饮料是什么，这个是变化的。 在实际的软件开发过程中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象采用一定的组合构成，由于需求的变化，这个复杂对象的各个部分或者其子对象经常要变化（例如，鸡腿堡套餐的顾客不喜欢可乐，要换奶茶），但是他们的结构却相对稳定（套餐都得是一份主食，副食及饮料）。当遇到这种场景时，使用生成器模式比较合适。 定义一个产品类：123456789101112131415161718192021222324252627282930313233343536373839404142434445package SheJiMoShi.生产器模式;public class Entity1 &#123; private String name ;//主食 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;public class Entity2 &#123; private String name ;//副食 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;public class Entity3 &#123; private String name ;//饮料 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;public class Product &#123; Entity1 entity1; Entity2 entity2; Entity3 entity3; public void getProduct()&#123; System.out.println(entity1.getName()+entity2.getName()+entity3.getName()); &#125;&#125; 产品类中的各个小模块是不一样的，由他们建造组成产品。 根据具体场景要求，定义n个生成器类：1234567891011121314151617181920212223242526272829303132333435363738394041424344package SheJiMoShi.生产器模式;public interface IBuild &#123; public void createEntity1(Entity1 entity1); public void createEntity2( Entity2 entity2); public void createEntity3(Entity3 entity3); public Product composite(Entity1 entity1,Entity2 entity2,Entity3 entity3);//合成 public Product create(Entity1 entity1,Entity2 entity2,Entity3 entity3);&#125;package SheJiMoShi.生产器模式;public class BuildProduct implements IBuild &#123; Product p = new Product(); @Override public void createEntity1(Entity1 entity1) &#123; p.entity1=entity1; &#125; @Override public void createEntity2(Entity2 entity2) &#123; p.entity2= entity2; &#125; @Override public void createEntity3(Entity3 entity3) &#123; p.entity3=entity3; &#125; @Override public Product composite(Entity1 entity1 ,Entity2 entity2,Entity3 entity3) &#123; createEntity1(entity1); createEntity2(entity2); createEntity3(entity3); return p; &#125; @Override public Product create(Entity1 entity1 ,Entity2 entity2,Entity3 entity3) &#123; return composite(entity1,entity2,entity3); &#125;&#125; 定义一个指挥者类，统一调度project：123456789101112package SheJiMoShi.生产器模式;public class Director &#123; private IBuild iBuild; public Director(IBuild iBuild)&#123; this.iBuild= iBuild; &#125; public Product build(Entity1 entity1,Entity2 entity2,Entity3 entity3)&#123; return iBuild.create(entity1,entity2,entity3); &#125;&#125; 总结建造者模式可以让一个产品的内部表象和产品的生产过程分离开，从而可以生成具有不同内部表象的产品。 主要角色介绍抽象建造者(Builder)角色：定义一个抽象接口，规范产品各个组成成分的建造（即规范具体建造者的方法实现）。其中所规范的方法中必须包括建造方法和结果返回方法。 具体建造者(ConcreteBuilder)角色:实现抽象建造者角色定义的方法。具体建造者与业务逻辑关联性比较大，应用程序最终会通过，调用此角色中的建造方法按照业务逻辑创建产品，在建造完成后通过结果返回产品实例。 导演者(Diretor)角色:此角色的作用是调用具体的创建者角色创造产品。导演者与产品类没直接关系。 产品(product)角色:在导演者指导下由具体建造者所创建的那个复杂的对象。 导演者角色与客户端直接打交道，它理解客户端的业务逻辑，将客户端创建产品的请求拆分成部分请求，然后调用具体产品角色执行建造操作。它分离了客户端与具体建造者。 优点：1、建造者模式可以很好的将一个对象的实现与相关的“业务”逻辑分离开来，从而可以在不改变事件逻辑的前提下，是添加(或改变)实现变得非常容易。 2、允许对象通过多个步骤来创建，并且可以改变过程（这和只有一个步骤的工厂模式不同）。 3、向客户隐藏产品内部的表现。 4、产品的实现可以被替换，因为客户只能看到一个抽象接口。 缺点：建造者接口的修改会导致所有执行类的修改。 适用性1、需要生产的产品对象有复杂的内部结构。比如，汽车、电脑。 2、需要生成的产品对象的属性互相依赖，建造者模式可以强迫生产顺序。 和其他模式的区别123451、抽象工厂模式：Builder模式返回完成的一个产品，而abstractFactory返回一系列有关系的产品。在抽象工厂模式中，客户采用abstractFactory生成自己要的 对象，而在Builder模式中，客户端指导（diretor）builder类如何去生成对象。获知如何合成一些类来构成建造类，侧重于一步一步构造一个复杂对象，然后返回结果。 2、原型模式：克隆，对象已经存在。 3、工厂方法：强调的是对象的变化，类实例推迟到子类。 4、单例：对象的唯一性。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"java 基础题(二)","slug":"Untitled1","date":"2018-07-20T04:10:37.809Z","updated":"2018-07-20T04:10:37.809Z","comments":true,"path":"2018/07/20/Untitled1/","link":"","permalink":"http://yoursite.com/2018/07/20/Untitled1/","excerpt":"","text":"11、是否可以从一个static方法内部发出对非static方法的调用？ 不可以。因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个static方法内部发出对非static方法的调用。 12、Integer与int的区别 int是java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况。 例如：要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。 在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。 另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。 13、Math.round(11.5)等於多少?Math.round(-11.5)等於多少? Math类中提供了三个与取整有关的方法：ceil、floor、round，这些方法的作用与它们的英文名称的含义相对应。 例如，ceil的英文意义是天花板，该方法就表示向上取整，Math.ceil(11.3)的结果为12,Math.ceil(-11.3)的结果是-11；floor的英文意义是地板，该方法就表示向下取整，Math.ceil(11.6)的结果为11,Math.ceil(-11.6)的结果是-12；最难掌握的是round方法，它表示“四舍五入”，算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。这里有一些笔误，floor的英文意义是地板，该方法就表示向下取整，Math.floor(11.6)的结果为11,Math.floor(-11.6)的结果是-12； 14、Overload和Override的区别？Overloaded的方法是否可以改变返回值的类型? Overload是重载的意思，Override是覆盖的意思，也就是重写。 重载Overload表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。 重写Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。 至于Overloaded的方法是否可以改变返回值的类型这个问题，要看你倒底想问什么呢？这个题目很模糊。如果几个Overloaded的方法的参数列表不一样，它们的返回者类型当然也可以不一样。但我估计你想问的问题是：如果两个方法的参数列表完全一样，是否可以让它们的返回值不同来实现重载Overload。这是不行的，我们可以用反证法来说明这个问题，因为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，我们调用map.remove(key)方法时，虽然remove方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，java就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。 override可以翻译为覆盖，从字面就可以知道，它是覆盖了一个方法并且对其重写，以求达到不同的作用。对我们来说最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。除了这个典型的用法以外，我们在继承中也可能会在子类覆盖父类中的方法。在覆盖要注意以下的几点：1、覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果； 2、覆盖的方法的返回值必须和被覆盖的方法的返回一致； 3、覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类； 4、被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。 Overload对我们来说可能比较熟悉，可以翻译为重载，它是指我们可以定义一些名称相同的方法，通过定义不同的输入参数来区分这些方法，然后再调用时，VM就会根据不同的参数样式，来选择合适的方法执行。在使用重载要注意以下的几点： 1、在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int,float)，但是不能为fun(int,int)）； 2、不能通过访问权限、返回类型、抛出的异常进行重载； 3、方法的异常类型和数目不会对重载造成影响； 4、对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。 15、接口是否可继承接口?抽象类是否可实现(implements)接口?抽象类是否可继承具体类(concreteclass)?抽象类中是否可以有静态的main方法？ 接口可以继承接口。抽象类可以实现(implements)接口，抽象类可以继承具体类。抽象类中可以有静态的main方法。 备注：只要明白了接口和抽象类的本质和作用，这些问题都很好回答，你想想，如果你是java语言的设计者，你是否会提供这样的支持，如果不提供的话，有什么理由吗？如果你没有道理不提供，那答案就是肯定的了。 只要记住抽象类与普通类的唯一区别就是不能创建实例对象和允许有abstract方法。 16、Java中实现多态的机制是什么？ 靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。 17、abstractclass和interface语法上有什么区别? 1.抽象类可以有构造方法，接口中不能有构造方法。2.抽象类中可以有普通成员变量，接口中没有普通成员变量3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。 抽象类中可以包含静态方法，接口中不能包含静态方法 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是publicstatic final类型，并且默认即为publicstatic final类型。 一个类可以实现多个接口，但只能继承一个抽象类。 18、abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized? abstract的method不可以是static的，因为抽象的方法是要被子类实现的，而static与子类扯不上关系！ native方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问题，所以，它也不能是抽象的，不能与abstract混用。例如，FileOutputSteam类要硬件打交道，底层的实现用的是操作系统相关的api实现；例如，在windows用c语言实现的，所以，查看jdk的源代码，可以发现FileOutputStream的open方法的定义如下：private native void open(Stringname) throwsFileNotFoundException; 如果我们要用java调用别人写的c语言函数，我们是无法直接调用的，我们需要按照java的要求写一个c语言的函数，又我们的这个c语言函数去调用别人的c语言函数。由于我们的c语言函数是按java的要求来写的，我们这个c语言函数就可以与java对接上，java那边的对接方式就是定义出与我们这个c函数相对应的方法，java中对应的方法不需要写具体的代码，但需要在前面声明native。 关于synchronized与abstract合用的问题，我觉得也不行，因为在我几年的学习和开发中，从来没见到过这种情况，并且我觉得synchronized应该是作用在一个具体的方法上才有意义。而且，方法上的synchronized同步所使用的同步锁对象是this，而抽象方法上无法确定this是什么。 19、内部类可以引用它的包含类的成员吗？有没有什么限制？ 完全可以。如果不是静态内部类，那没有什么限制！ 如果你把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员变量，而只能访问外部类中的静态成员，例如，下面的代码：1234567891011class Outer&#123;static int x;static class Inner &#123; voidtest() &#123; syso(x); &#125; &#125;&#125; 20、String s = “Hello”;s = s + “world!”;这两行代码执行后，原始的String对象中的内容到底变了没有？ 没有。因为String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。在这段代码中，s原先指向一个String对象，内容是 “Hello”，然后我们对s进行了+操作，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为”Hello world!”，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。 通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，或者说，不可预见的修改，那么使用String来代表字符串的话会引起很大的内存开销。因为String对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个String对象来表示。这时，应该考虑使用StringBuffer类，它允许修改，而不是每个不同的字符串都要生成一个新的对象。并且，这两种类的对象转换十分容易。 同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都new一个String。例如我们要在构造器中对一个名叫s的String引用变量进行初始化，把它设置为初始值，应当这样做：12345678public class Demo &#123;private String s;...public Demo &#123;s = &quot;Initial Value&quot;;&#125;...&#125; 而非s = new String(“Initial Value”);后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为String对象不可改变，所以对于内容相同的字符串，只要一个String对象来表示就可以了。也就说，多次调用上面的构造器创建多个对象，他们的 String类型属性s都指向同一个对象。 上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java认为它们代表同一个String对象。而用关键字new调用构造器，总是会创建一个新的对象，无论内容是否相同。 至于为什么要把String类设计成不可变类，是它的用途决定的。其实不只String，很多Java标准类库中的类都是不可变的。在开发一个系统的时候，我们有时候也需要设计不可变类，来传递一组相关的值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它的对象是只读的，所以多线程并发访问也不会有任何问题。当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能会造成性能上的问题。所以Java标准类库还提供了一个可变版本，即StringBuffer。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java题","slug":"java题","permalink":"http://yoursite.com/tags/java题/"}]},{"title":"Android ListView联动","slug":"LIstView 联动(一)","date":"2018-07-20T04:10:37.809Z","updated":"2018-07-20T04:10:37.809Z","comments":true,"path":"2018/07/20/LIstView 联动(一)/","link":"","permalink":"http://yoursite.com/2018/07/20/LIstView 联动(一)/","excerpt":"","text":"LIstView 联动(一)大体思路两个listView的联动效果，类似于美团点菜和城市选择效果，在布局的左侧使用了平常的listview，在右侧用到了stickyheaderlistview，这是实现该效果的一个关键组件。activity 布局123456789101112131415161718192021222324&lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot; &gt; &lt;ListView android:id=&quot;@+id/lv_left&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;match_parent&quot; android:cacheColorHint=&quot;#00000000&quot; &gt; &lt;/ListView&gt; &lt;se.emilsjolander.stickylistheaders.StickyListHeadersListView android:id=&quot;@+id/list&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:cacheColorHint=&quot;#00000000&quot; android:clipToPadding=&quot;false&quot; android:footerDividersEnabled=&quot;false&quot; android:drawSelectorOnTop=&quot;true&quot; android:fastScrollEnabled=&quot;true&quot; android:padding=&quot;16dp&quot; android:scrollbarStyle=&quot;outsideOverlay&quot; /&gt; &lt;/LinearLayout&gt; 模拟数据模拟两边的数据，需要注意的是左边listview数据中的id要和右边listview数据中的id产生一对多的关系，否则无法实现联动效果123456789101112131415161718/** * 模拟右边adapter的数据 * * @return */ private List&lt;DishBean&gt; initDishData() &#123; List&lt;DishBean&gt; dishBeanList = new ArrayList&lt;DishBean&gt;(); for (int i = 0; i &lt; 100; i++) &#123; DishBean dishBean = new DishBean(); long id = i / 10; dishBean.id = id; dishBean.content = &quot;content&quot; + i; dishBeanList.add(dishBean); &#125; return dishBeanList; &#125; 123456789101112131415161718192021/** * 模拟左边adapter数据 * * @return */ private List&lt;CategoryBean&gt; initCateData() &#123; List&lt;CategoryBean&gt; categoryBeanList = new ArrayList&lt;CategoryBean&gt;(); for (int i = 0; i &lt; 10; i++) &#123; CategoryBean categoryBean = new CategoryBean(); if (i == 0) &#123; categoryBean.isSelected = true; &#125; else &#123; categoryBean.isSelected = false; &#125; categoryBean.id = i; categoryBean.name = &quot;cate&quot; + i; categoryBeanList.add(categoryBean); &#125; return categoryBeanList; &#125; 左边对右边的联动设置左边listview的点击事件让右边的listview滚动到相应的位置，这算是完成了一半的任务。（根据CategoryBean 中的id值查找右边lsitview相对应的item，然后记录下位置进行setSelection操作）12345678910111213@Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; // 点击类别item，右侧菜品跳转到相应的位置 CategoryBean categoryBean = cateList.get(position); for (int i = 0; i &lt; dishList.size(); i++) &#123; DishBean dishBean = dishList.get(i); if (categoryBean.id == dishBean.id) &#123; lv_right.setSelection(i); break; &#125; &#125; &#125; 右侧对左侧的联动下面是右侧对左侧的联动效果实现。首先在activity中实现StickyListHeadersListView.OnStickyHeaderChangedListener接口（该接口来源于StickyListHeadersListView类），相对应的会实现onStickyHeaderChanged方法。 该方法会在header改变时调用（header的改变意味着一组新的类别数据出现在屏幕上），这时相对应的也需要改变左侧listview的选中状态 1234567891011@Override public void onStickyHeaderChanged(StickyListHeadersListView l, View header, int itemPosition, long headerId) &#123; DishBean dishBean = dishList.get(itemPosition); long id = dishBean.id; int position = getCateId(id); if (position != -1) &#123; lv_left.setSelection(position); //更新左侧listview选中状态 notifyLeftAdapter(position); &#125; &#125; 123456789101112131415161718/** * 获取dishbean id对应的类别所在position * * @param id * dishbean id * @return */ private int getCateId(long id) &#123; int position = 0; for (int i = 0; i &lt; cateList.size(); i++) &#123; position = i; if (id == cateList.get(i).id) &#123; return position; &#125; &#125; return -1; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"ListView联动","slug":"ListView联动","permalink":"http://yoursite.com/tags/ListView联动/"}]},{"title":"适配器模式","slug":"适配器模式","date":"2018-07-20T04:10:37.809Z","updated":"2018-07-20T04:10:37.809Z","comments":true,"path":"2018/07/20/适配器模式/","link":"","permalink":"http://yoursite.com/2018/07/20/适配器模式/","excerpt":"","text":"适配器模式定义：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 角色：目标(Target)角色：这就是所期待得到的接口，也就是这类的接口是符合我们要求的。 源(Adapee)角色：我们要使用的接口，但是这个接口不符合我们的要求，也就是现在需要适配的接口。 适配器(Adaper)角色：适配器类是适配器模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。 分类：1、 类适配器模式12345678910class Adaptee &#123; publicvoid specificRequest() &#123; System.out.println(&quot;特殊请求，这个是源角色&quot;); &#125;&#125;/*这个是目标角色，所期待的接口*/interface Target &#123; publicvoid request();&#125; 现在想要实现这个Target接口，但是不想重构，想要用上已有的Adaptee类，这时可以定义一个适配器类，继承想要使用的类，并且实现期待的接口。1234class Adapter extends Adaptee implementsTarget&#123; publicvoid request() &#123; super.specificRequest(); &#125;&#125; 这样，使用适配器类和实现目标接口就完成了计划，测试：1234567public class Test&#123; publicstatic void main(String[] args) &#123; //使用特殊功能类，即适配类 Targetadapter = new Adapter(); adapter.request(); &#125;&#125; 2、 对象适配器模式适配器类关联已有的Adaptee类，并且实现标准接口，这样做的好处是不再需要继承。1234567891011class Adapter implements Target&#123; privateAdaptee adaptee; publicAdapter (Adaptee adaptee) &#123; this.adaptee= adaptee; &#125; publicvoid request() &#123; this.adaptee.specificRequest(); &#125;&#125; 我们可以想到，此时输出结果和类适配器模式是相同的，测试：123456public class Test&#123; publicstatic void main(String[] args) &#123; Targetadapter = new Adapter(new Adaptee()); adapter.request(); &#125;&#125; 区别： 类适配器：对象继承的方式，静态的定义。 对象适配器：依赖于对象的组合，都是采用对象组合的方式，也就是对象适配器实现的方式。 对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。 优点：复用性系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。 扩展性在实现适配器功能的时候，可以自由调用自己开发的功能，从而自然地扩展系统的功能。 缺点： 过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现。所以适配器模式不适合在详细设计阶段使用它，它是一种补偿模式，专用来在系统后期扩展、修改时所用。 适用场景：1、已经存在的类的接口不符合我们的需求； 2、创建一个可以复用的类，使得该类可以与其他不相关的类或不可预见的类协同工作； 3、使用一些已经存在的子类而不需要对其进行子类化来匹配接口。 4、旧的系统开发的类已经实现了一些功能，但是客户端却只能以另外接口的形式访问，但我们不希望手动更改原有类的时候。 小结：适配器模式不适合在详细设计阶段使用它，它是一种补偿模式，专用来在系统后期扩展、修改时所用，适配器模式更像是一种补救措施。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"文件的上传和下载二","slug":"实现文件下载","date":"2018-07-20T04:10:37.809Z","updated":"2018-07-20T04:10:37.809Z","comments":true,"path":"2018/07/20/实现文件下载/","link":"","permalink":"http://yoursite.com/2018/07/20/实现文件下载/","excerpt":"","text":"实现文件下载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package FileUploadAndDownLoad;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.OutputStream;import java.net.URLEncoder;@WebServlet(name = &quot;DownLoadServlet&quot;)public class DownLoadServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;//得到要下载的文件名 String fileName = request.getParameter(&quot;filename&quot;);//上传的文件都是保存在/WEB-INF/upload目录下的子目录当中 String fileSaveRootPath = this.getServletContext().getRealPath(&quot;/WEB-INF/upload&quot;);//通过文件名找出文件的所在目录 String path = findFileSavePathByFileName(fileName, fileSaveRootPath); System.out.println(path);//得到要下载的文件 File file = new File(path + &quot;\\\\&quot; + fileName);//如果文件不存在 if (!file.exists()) &#123; request.setAttribute(&quot;message&quot;, &quot;您要下载的资源已被删除！！&quot;); request.getRequestDispatcher(&quot;/message.jsp&quot;).forward(request, response); return; &#125;//处理文件名 String realname = fileName.substring(fileName.indexOf(&quot;_&quot;) + 1);//设置响应头，控制浏览器下载该文件 response.setHeader(&quot;content-disposition&quot;, &quot;attachment;filename=&quot; + URLEncoder.encode(realname, &quot;UTF-8&quot;));//读取要下载的文件，保存到文件输入流 FileInputStream in = new FileInputStream(path + &quot;\\\\&quot; + fileName);//创建输出流 OutputStream out = response.getOutputStream();//创建缓冲区 byte buffer[] = new byte[1024]; int len = 0;//循环将输入流中的内容读取到缓冲区当中 while ((len = in.read(buffer)) &gt; 0) &#123;//输出缓冲区的内容到浏览器，实现文件下载 out.write(buffer, 0, len); &#125;//关闭文件输入流 in.close();//关闭输出流 out.close(); &#125; private String findFileSavePathByFileName(String filename,String saveRootPath) &#123; int hashcode = filename.hashCode(); int dir1 = hashcode&amp;0xf; //0--15 int dir2 = (hashcode&amp;0xf0)&gt;&gt;4; //0-15 String dir = saveRootPath + &quot;\\\\&quot; + dir1 + &quot;\\\\&quot; + dir2; //upload\\2\\3 upload\\3\\5 File file = new File(dir); if(!file.exists())&#123; //创建目录 file.mkdirs(); &#125; return dir; &#125;&#125; 说明：0xf 是十六进制的15，转换成二进制是1111，和任何4位二进制进行&amp;运算后，最大值也还是1111，最小值是0，所以最多只能创建16个目录。","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://yoursite.com/categories/javaEE/"}],"tags":[{"name":"上传和下载","slug":"上传和下载","permalink":"http://yoursite.com/tags/上传和下载/"}]},{"title":"java基础知识(一)","slug":"对象和内存控制","date":"2018-07-20T04:10:37.809Z","updated":"2018-07-20T04:10:37.809Z","comments":true,"path":"2018/07/20/对象和内存控制/","link":"","permalink":"http://yoursite.com/2018/07/20/对象和内存控制/","excerpt":"","text":"对象和内存控制java的内存管理 内存分配 内存回收java的内存管理 成员变量 局部变量 形参 方法内的局部变量 代码块内的局部变量static的作用 Static 的作用就是将实例成员变量变成类变量，Static只能修饰类里定义的成员部分【包括成员变量、方法、内部类、初始化块、内部枚举类】，如果没有Static修饰，这些类里面的成员，这里成员属于该类的实例，被Static修饰，则这些成员就属于类本身。 Static只能修饰类里面的成员，不能修饰外部类，不能修饰局部变量，局部内部类。在同一个JVM中，每个类只对应一个class对象，但每个类可以创建多个Java对象。 父类构造器：在创建任何Java对象时，程序总会依次调用每个父类非静态初始化块，父类构造器（从Object开始）执行初始化，最后才调用本类的非静态初始化块、构造器执行初始化。 隐式调用：调用父类的静态初始化块 调用父类构造器，既可以用Super显示调用，也可以隐式调用。 当this在构造器中时，this代表正在初始化的Java对象 当变量在编译时的类型和运行时类型不同时，通过该变量访问它引用对象的实例变量时，该实例变量的值由声明该变量的类型决定。但通过该变量调用它引用的对象的实例方法时，该方法行为将由所引用的对象来决定。 如果父类构造器调用了被子类重写的方法且通过子类构造器来创建对象，调用（隐式或者显式）了这个父类构造器，就会导致子类重写的方法在子类构造器的所有代码之前被执行，从而导致子类的访问不到子类的实例变量值的情形。 当通过引用变量来访问它所引用对象的实例对象时，该实例变量的值取决于声明该变量时所用的类型。final修饰符 final修饰符的一个重要作用就是定义“宏变量“，final变量在定义时就指定了初始值，而且该初始值可以在编译时就确定下来，那这个final变量本质上就是一个”宏变量“，编译器会把程序所有用到该变量的地方直接替换成该变量的值。 final变量的值调用了方法没办法在编译中确定下来。 final方法不能被重写。 执行”宏变量“的变量——final修饰的变量","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"对象和内存控制","slug":"对象和内存控制","permalink":"http://yoursite.com/tags/对象和内存控制/"}]},{"title":"java 基础知识","slug":"FastJSON 简单使用","date":"2018-07-20T04:10:37.805Z","updated":"2018-07-20T04:10:37.805Z","comments":true,"path":"2018/07/20/FastJSON 简单使用/","link":"","permalink":"http://yoursite.com/2018/07/20/FastJSON 简单使用/","excerpt":"","text":"FastJSON 简单使用FastJSON 个Java语言编写的高性能，功能完善，完全支持http://json.org的标准的JSON库。如果使用Maven,在pom.xml文件加入以下依赖。12&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.23&lt;/version&gt;&lt;/dependency&gt; 序列化序列化就是指 把JavaBean对象转成JSON格式的字符串。com.alibaba.fastjson.JSON提供了许多方法（多态）实现序列化。 1.基本的序列化String objJson = JSON.toJSONString(Object object); 传入一个对象，将对象转成JSON字符串。 例1：将Map转成JSON1Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();2 map.put(&quot;key1&quot;, &quot;One&quot;);3 map.put(&quot;key2&quot;, &quot;Two&quot;);45 String mapJson = JSON.toJSONString(map); 输出结果： {&quot;key1&quot;:&quot;One&quot;,&quot;key2&quot;:&quot;Two&quot;} 例2：将List转成JSON。12345678List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); Map&lt;String, Object&gt; map1 = new HashMap&lt;String, Object&gt;(); map1.put(&quot;key1&quot;, &quot;One&quot;);map1.put(&quot;key2&quot;, &quot;Two&quot;);Map&lt;String, Object&gt; map2 = new HashMap&lt;String, Object&gt;();map2.put(&quot;key1&quot;, &quot;Three&quot;);map2.put(&quot;key2&quot;, &quot;Four&quot;);list.add(map1);list.add(map2);String listJson = JSON.toJSONString(list); 输出结果： [{&quot;key1&quot;:&quot;One&quot;,&quot;key2&quot;:&quot;Two&quot;},{&quot;key3&quot;:&quot;Three&quot;,&quot;key4&quot;:&quot;Four&quot;}] 例3：自定义JavaBean User转成JSON。12345User user = new User();user.setUserName(&quot;李四&quot;);user.setAge(24);String userJson = JSON.toJSONString(user); 输出结果： {&quot;age&quot;:24,&quot;userName&quot;:&quot;李四&quot;} 可以输出格式化后的 JSON 字符串。 String objJson = JSON.toJSONString(Object object, boolean prettyFormat); 传入一个对象和一个布尔类型（是否格式化），将对象转成格式化后的JSON字符串。 例4：以例2代码为例。String listJson = JSON.toJSONString(list, true); 输出结果为：12345678910[ &#123; &quot;key1&quot;:&quot;One&quot;, &quot;key2&quot;:&quot;Two&quot; &#125;, &#123; &quot;key3&quot;:&quot;Three&quot;, &quot;key4&quot;:&quot;Four&quot; &#125;] FastJSON提供了许多特性支持。 String objJson = JSON.toJSONString(Object object, SerializerFeature... features) 传入一个对象和SerializerFeature类型的可变变量。SerializerFeature是一个枚举。com.alibaba.fastjson.serializer.SerializerFeature简单说下几个常用的特性：1.日期格式化：FastJSON可以直接对日期类型格式化，在缺省的情况下，FastJSON会将Date转成long。 例5：FastJSON将java.util.Date转成long。12String dateJson = JSON.toJSONString(new Date());System.out.println(dateJson); 输出结果：11401370199040 例6：使用SerializerFeature特性格式化日期。12 String dateJson = JSON.toJSONString(new Date(), SerializerFeature.WriteDateUseDateFormat);System.out.println(dateJson); 输出结果：1&quot;2014-05-29 21:36:24&quot; 也可以指定输出日期格式。 例7：指定输出日期格式。12String dateJson = JSON.toJSONStringWithDateFormat(new Date(), &quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);System.out.println(dateJson); 输出结果：1&quot;2014-05-29 21:47:00.154&quot; 2.使用单引号。 例8：以例2为例。1String listJson = JSON.toJSONString(list, SerializerFeature.UseSingleQuotes); 输出结果：1[&#123;&apos;key1&apos;:&apos;One&apos;,&apos;key2&apos;:&apos;Two&apos;&#125;,&#123;&apos;key3&apos;:&apos;Three&apos;,&apos;key4&apos;:&apos;Four&apos;&#125;] JSON格式化。例9：1String listJson = JSON.toJSONString(list, SerializerFeature.PrettyFormat); 输出结果：与例4结果一致。4.输出Null字段。 缺省情况下FastJSON不输入为值Null的字段，可以使用SerializerFeature.WriteMapNullValue使其输出。 例10：123456Map&lt;String, Object&gt; map = new HashMap&lt;String,Object&gt;();String b = null; Integer i = 1; map.put(&quot;a&quot;, b); map.put(&quot;b&quot;, i); String listJson = JSON.toJSONString(map, SerializerFeature.WriteMapNullValue); 输出结果：1&#123;&quot;a&quot;:null,&quot;b&quot;:1&#125; 5.序列化是写入类型信息。 例11：123User user = new User(); user.setAge(18);user.setUserName(&quot;李四&quot;);String listJson = JSON.toJSONString(user, SerializerFeature.WriteClassName); 输出结果：1&#123;&quot;@type&quot;:&quot;User&quot;,&quot;age&quot;:18,&quot;userName&quot;:&quot;李四&quot;&#125; 由于序列化带了类型信息，使得反序列化时能够自动进行类型识别。 例12：将例11反序列化。12User user1 = (User) JSON.parse(listJson);System.out.println(user1.getAge()); 输出结果：118 如果User序列化是没有加入类型信息（SerializerFeature.WriteClassName），按照例12的做法就会报错（java.lang.ClassCastException）。 反序列化反序列化就是把JSON格式的字符串转化为Java Bean对象。com.alibaba.fastjson.JSON提供了许多方法（多态）实现反序列化。 简单举几个例子。指定Class信息反序列化。 例13：将例3反序列化。12User user1 = JSON.parseObject(userJson, User.class);System.out.println(user1.getUserName()); 输出结果：1李四 集合反序列化。 例14：将例2反序列化。12345List&lt;Map&gt; list1 = JSON.parseArray(listJson, Map.class);for(Map&lt;String, Object&gt; map : list1)&#123;System.out.println(map.get(&quot;key1&quot;));System.out.println(map.get(&quot;key2&quot;));&#125; 输出结果：1234OneTwoThreeFour 泛型的反序列化（使用TypeReference传入类型信息）。 例15：将例1反序列化。123Map&lt;String, Object&gt; map1 = JSON.parseObject(mapJson, new TypeReference&lt;Map&lt;String, Object&gt;&gt;()&#123;&#125;);System.out.println(map1.get(&quot;key1&quot;));System.out.println(map1.get(&quot;key2&quot;)); 输出结果：12OneTwo JSONObject，JSONArray是JSON的两个子类。JSONObject相当于Map&lt;String, Object&gt;，JSONArray相当于List。简单方法示例： 例16：将Map转成JSONObject，然后添加元素，输出。123456789 Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;key1&quot;, &quot;One&quot;); map.put(&quot;key2&quot;, &quot;Two&quot;); JSONObject j = new JSONObject(map);j.put(&quot;key3&quot;, &quot;Three&quot;); System.out.println(j.get(&quot;key1&quot;)); System.out.println(j.get(&quot;key2&quot;)); System.out.println(j.get(&quot;key3&quot;)); 输出结果：123OneTwoThree 例17：将List对象转成JSONArray，然后输出。12345678910111213List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();map.put(&quot;key1&quot;, &quot;One&quot;);map.put(&quot;key2&quot;, &quot;Two&quot;);Map&lt;String, Object&gt; map2 = new HashMap&lt;String, Object&gt;();map2.put(&quot;key1&quot;, &quot;Three&quot;);map2.put(&quot;key2&quot;, &quot;Four&quot;);list.add(map);list.add(map2);JSONArray j = JSONArray.parseArray(JSON.toJSONString(list));for(int i=0; i&lt;j.size(); i++)&#123;System.out.println(j.get(i));&#125; 输出结果：12&#123;&quot;key1&quot;:&quot;One&quot;,&quot;key2&quot;:&quot;Two&quot;&#125;&#123;&quot;key1&quot;:&quot;Three&quot;,&quot;key2&quot;:&quot;Four&quot;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"json数据解析","slug":"json数据解析","permalink":"http://yoursite.com/tags/json数据解析/"}]},{"title":"我的第一个Android设计第二天（二）","slug":"OkHttp中 response.body().string()只能调用一次分析","date":"2018-07-20T04:10:37.805Z","updated":"2018-07-20T04:10:37.805Z","comments":true,"path":"2018/07/20/OkHttp中 response.body().string()只能调用一次分析/","link":"","permalink":"http://yoursite.com/2018/07/20/OkHttp中 response.body().string()只能调用一次分析/","excerpt":"","text":"OkHttp中 response.body().string()只能调用一次分析我们第一次调用response.body().string(); 的时候可以正确拿到数据，第二次就返回了null日志可以打出来，在程序里面不能运行。 123public void onResponse(Response response) throws IOException &#123; String result = response.body().string();// response.body().string();只能调用一次 因为response.body()也是挺大的，OkHttp不把它存储在内存中，就是你需要的时候就去读一次 只给你了内容，没有给引用，所以一次请求读一次 源码string()123public final String string() throws IOException &#123; return new String(bytes(), charset().name()); &#125; bytes()123456789101112131415161718public final byte[] bytes() throws IOException &#123; long contentLength = contentLength(); if (contentLength &gt; Integer.MAX_VALUE) &#123; throw new IOException(&quot;Cannot buffer entire body for content length: &quot; + contentLength); &#125; BufferedSource source = source(); byte[] bytes; try &#123; bytes = source.readByteArray(); &#125; finally &#123; Util.closeQuietly(source); &#125; if (contentLength != -1 &amp;&amp; contentLength != bytes.length) &#123; throw new IOException(&quot;Content-Length and stream length disagree&quot;); &#125; return bytes; &#125; finally中的代码肯定会调用这里执行 Util.closeQuietly(source)closeQuietly方法可以运用到各类可关闭的对象中就是因为在拿过之后就把资源关闭了所以就获取不到了，所以只能拿一次。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android 课设","slug":"Android-课设","permalink":"http://yoursite.com/tags/Android-课设/"}]},{"title":"javaweb (五 )","slug":"HttpServletResponse对象介绍","date":"2018-07-20T04:10:37.805Z","updated":"2018-07-20T04:10:37.805Z","comments":true,"path":"2018/07/20/HttpServletResponse对象介绍/","link":"","permalink":"http://yoursite.com/2018/07/20/HttpServletResponse对象介绍/","excerpt":"","text":"Web服务器收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象、和代表响应的response对象。 request和response对象即然代表请求和响应，那我们要获取客户机提交过来的数据，只需要找request对象就行了。要向客户机输出数据，只需要找response对象就行了。 HttpServletResponse对象介绍HttpServletResponse对象代表服务器的响应。这个对象中封装了向客户端发送数据、发送响应头，发送响应状态码的方法。查看HttpServletResponse的API，可以看到这些相关的方法。 负责向客户端(浏览器)发送数据的相关方法 负责向客户端(浏览器)发送响应头的相关方法 负责向客户端(浏览器)发送响应状态码的相关方法 响应状态码的常量 HttpServletResponse定义了很多状态码的常量(具体可以查看Servlet的API)，当需要向客户端发送响应状态码时，可以使用这些常量，避免了直接写数字，常见的状态码对应的常量：状态码404对应的常量状态码200对应的常量状态码500对应的常量 HttpServletResponse对象常见应用使用OutputStream流向客户端浏览器输出中文数据使用OutputStream流输出中文注意问题：在服务器端，数据是以哪个码表输出的，那么就要控制客户端浏览器以相应的码表打开，比如：outputStream.write(“刘俭梅”.getBytes(“UTF-8”));使用OutputStream流向客户端浏览器输出中文，以UTF-8的编码进行输出，此时就要控制客户端浏览器以UTF-8的编码打开，否则显示的时候就会出现中文乱码，那么在服务器端如何控制客户端浏览器以以UTF-8的编码显示数据呢？可以通过设置响应头控制浏览器的行为，例如：response.setHeader(“content-type”, “text/html;charset=UTF-8”);通过设置响应头控制浏览器以UTF-8的编码显示数据。范例：使用OutputStream流向客户端浏览器输出”刘俭梅”这三个汉字123456789101112131415161718192021222324252627package qgx.response.study;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.OutputStream;@WebServlet(name = &quot;ResponseDemo1&quot;)public class ResponseDemo1 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;doGet(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String data = &quot;刘俭梅&quot;; //获取OutputStream输出流 OutputStream outputStream = response.getOutputStream(); //通过设置响应头控制浏览器以UTF-8的编码显示数据，如果不加这句话，那么浏览器显示的将是乱码 response.setHeader(&quot;content-type&quot;, &quot;text/html;charset=UTF-8&quot;); //将字符转换成字节数组，指定以UTF-8编码进行转换 byte[] dataByteArr = data.getBytes(&quot;UTF-8&quot;); outputStream.write(dataByteArr);//使用OutputStream流向客户端输出字节数组 &#125;&#125; 运行结果： 使用PrintWriter流向客户端浏览器输出中文数据2.2、使用PrintWriter流向客户端浏览器输出中文数据使用PrintWriter流输出中文注意问题： 在获取PrintWriter输出流之前首先使用”response.setCharacterEncoding(charset)”设置字符以什么样的编码输出到浏览器，如：response.setCharacterEncoding(“UTF-8”);设置将字符以”UTF-8”编码输出到客户端浏览器，然后再使用response.getWriter();获取PrintWriter输出流，这两个步骤不能颠倒，如下：1234response.setCharacterEncoding(&quot;UTF-8&quot;);//设置将字符以&quot;UTF-8&quot;编码输出到客户端浏览器PrintWriter out = response.getWriter();//获取PrintWriter输出流/**PrintWriter out = response.getWriter();这句代码必须放在*response.setCharacterEncoding(&quot;UTF-8&quot;);之后*否则response.setCharacterEncoding(&quot;UTF-8&quot;)这行代码的设置将无效，浏览器显示的时候还是乱码*/ 然后再使用response.setHeader(“content-type”, “text/html;charset=字符编码”);设置响应头，控制浏览器以指定的字符编码编码进行显示，例如：12//通过设置响应头控制浏览器以UTF-8的编码显示数据，如果不加这句话，那么浏览器显示的将是乱码response.setHeader(&quot;content-type&quot;, &quot;text/html;charset=UTF-8&quot;); 复制代码范例：使用PrintWriter流向客户端浏览器输出”刘俭梅”1234567891011121314151617181920212223242526package qgx.response.study;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.OutputStream;import java.io.PrintWriter;@WebServlet(name = &quot;ResponseDemo1&quot;)public class ResponseDemo1 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;doGet(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String data = &quot;刘俭梅&quot;; //通过设置响应头控制浏览器以UTF-8的编码显示数据，如果不加这句话，那么浏览器显示的将是乱码 response.setHeader(&quot;content-type&quot;, &quot;text/html;charset=UTF-8&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;);//设置将字符以&quot;UTF-8&quot;编码输出到客户端浏览器 PrintWriter out = response.getWriter();//获取PrintWriter输出流 out.write(data);//使用PrintWriter流向客户端输出字符 &#125;&#125; 当需要向浏览器输出字符数据时，使用PrintWriter比较方便，省去了将字符转换成字节数组那一步。 使用OutputStream或者PrintWriter向客户端浏览器输出数字1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package qgx.response.study;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.OutputStream;import java.io.PrintWriter;@WebServlet(name = &quot;ResponseDemo1&quot;)public class ResponseDemo1 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; outputOneByOutputStream(response);//使用OutputStream输出1到客户端浏览器 outputOneByPrintWriter(response);//使用PrintWriter输出1到客户端浏览器 String data = &quot;刘俭梅&quot;; //通过设置响应头控制浏览器以UTF-8的编码显示数据，如果不加这句话，那么浏览器显示的将是乱码 response.setHeader(&quot;content-type&quot;, &quot;text/html;charset=UTF-8&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;);//设置将字符以&quot;UTF-8&quot;编码输出到客户端浏览器 PrintWriter out = response.getWriter();//获取PrintWriter输出流 out.write(data);//使用PrintWriter流向客户端输出字符 //获取OutputStream输出流 OutputStream outputStream = response.getOutputStream(); //通过设置响应头控制浏览器以UTF-8的编码显示数据，如果不加这句话，那么浏览器显示的将是乱码 response.setHeader(&quot;content-type&quot;, &quot;text/html;charset=UTF-8&quot;); //将字符转换成字节数组，指定以UTF-8编码进行转换 byte[] dataByteArr = data.getBytes(&quot;UTF-8&quot;); outputStream.write(dataByteArr);//使用OutputStream流向客户端输出字节数组 &#125; /** * 使用PrintWriter流输出数字1 * @param response * @throws IOException */ private void outputOneByPrintWriter(HttpServletResponse response) throws IOException &#123; response.setHeader(&quot;content-type&quot;, &quot;text/html;charset=UTF-8&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;); PrintWriter out = response.getWriter();//获取PrintWriter输出流 out.write(&quot;使用PrintWriter流输出数字1：&quot;); out.write(1 + &quot;&quot;); &#125; /** * 使用OutputStream流输出数字1 * * @param response * @throws IOException */ private void outputOneByOutputStream(HttpServletResponse response) throws IOException &#123; response.setHeader(&quot;content-type&quot;, &quot;text/html;charset=UTF-8&quot;); OutputStream outputStream = response.getOutputStream(); outputStream.write(&quot;使用OutputStream流输出数字1：&quot;.getBytes(&quot;UTF-8&quot;)); outputStream.write((1 + &quot;&quot;).getBytes()); &#125;&#125; 1+””这一步是将数字1和一个空字符串相加，这样处理之后，数字1就变成了字符串1了，然后再将字符串1转换成字节数组使用OutputStream进行输出 在开发过程中，如果希望服务器输出什么浏览器就能看到什么，那么在服务器端都要以字符串的形式进行输出。如果使用PrintWriter流输出数字，那么也要先将数字转换成字符串后再输出","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://yoursite.com/categories/javaEE/"}],"tags":[{"name":"HttpServletResponse","slug":"HttpServletResponse","permalink":"http://yoursite.com/tags/HttpServletResponse/"}]},{"title":"Handler","slug":"Handler","date":"2018-07-20T04:10:37.805Z","updated":"2018-07-20T04:10:37.805Z","comments":true,"path":"2018/07/20/Handler/","link":"","permalink":"http://yoursite.com/2018/07/20/Handler/","excerpt":"","text":"Handler作者博客：https://blog.csdn.net/ClAndEllen/article/details/79343538 1.什么是Handler？ Handler是可以通过发送和处理Message和Runnable对象来关联相应线程的MessageQueue。通常我们认为它是一种异步机制。 a.可以让对应的Message和Runnable在未来的某个时间点进行相应的处理。 b.让自己想要的耗时操作在子线程中完成，让更新UI的操作在主线程中完成，而子线程与主线程之间的通信就是靠Handler来完成。 2.Handler的使用方法 a.post(Runnable) b.sendMessage(Message) 3.Handler内部的实现机制 Handler机制也可叫异步消息机制，它主要由4个部分组成：Message,Handler,MessageQueue,Looper,在上面我们已经接触到了Message和Handler,接下来我们对4个成员进行着重的了解： 1.Message Message是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间交换数据。使用Message的arg1和arg2便可携带int数据，使用obj便可携带Object类型数据。 2.Handler Handler顾名思义就是处理者的意思，它只要用于在子线程发送消息对象Message,在UI线程处理消息对象Message，在子线程调用sendMessage方法发送消息对象Message，而发送的消息经过一系列地辗转之后最终会被传递到Handler的handleMessage方法中,最终在handleMessage方法中消息对象Message被处理。 3.MessageQueue MessageQueue就是消息队列的意思,它只要用于存放所有通过Handler发送过来的消息。这部分消息会一直存放于消息队列当中，等待被处理。每个线程中只会有一个MessageQueue对象，请牢记这句话。其实从字面上就可以看出，MessageQueue底层数据结构是队列，而且这个队列只存放Message对象。 4.Looper Looper是每个线程中的MessageQueue的管家，调用Looper的loop()方法后，就会进入到一个无限循环当中，然后每当MesssageQueue中存在一条消息，Looper就会将这条消息取出，并将它传递到Handler的handleMessage()方法中。每个线程只有一个Looper对象。 了解了上述Handler机制的4个成员后，我们再来把思路理一遍：首先在UI线程我们创建了一个Handler实例对象，无论是匿名内部类还是自定义类生成的Handler实例对象，我们都需要对handleMessage方法进行重写，在handleMessage方法中我们可以通过参数msg来写接受消息过后UIi线程的逻辑处理，接着我们创建子线程，在子线程中需要更新UI的时候，新建一个Message对象，并且将消息的数据记录在这个消息对象Message的内部，比如arg1,arg2,obj等，然后通过前面的Handler实例对象调用sendMessge方法把这个Message实例对象发送出去，之后这个消息会被存放于MessageQueue中等待被处理，此时MessageQueue的管家Looper正在不停的把MessageQueue存在的消息取出来，通过回调dispatchMessage方法将消息传递给Handler的handleMessage方法，最终前面提到的消息会被Looper从MessageQueue中取出来传递给handleMessage方法，最终得到处理。这就是Handler机制整个的工作流程，怎么样？你懂了吗？看看下面的图你就更懂了： 4.Handler引起的内存泄漏以及解决方法原因：非静态内部类持有外部类的匿名引用，导致外部activity无法得到释放。 解决方法：handler内部持有外部的弱引用，并把handler改为静态内部类，在activity的onDestory()中调用handler的removeCallback()方法。 Handler的产生背景 开启子线程进行耗时操作，多次创建和销毁子线程是很耗费资源的，但是木有关系，谷歌考虑了这点为我们专门开发出了HandlerThread机制，那么它有什么特点呢？请看下面： HandlerThread是什么？ 本质：Handler + Thread + Looper，是一个Thread内部有Looper。当你被面试官问道HandlerThread是什么，有何特点，那么你应该这么回答： a.HandlerThread本质上是一个线程类，它继承了Thread。 b.HandlerThread有自己内部的Looper对象，可以进行Looper循环。 c.通过获取HandlerThread的Looper对象传递给Handler对象，可以在handlerMessage方法中执行异步任务。 d.优点是不会有堵塞，减少对性能的消耗，缺点是不能进行多任务的处理，需要等待进行处理，处理效率较低。 e.与线程池注重并发不同，HandlerThread是一个串行队列，HandlerThread背后只有一个线程。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Handler","slug":"Handler","permalink":"http://yoursite.com/tags/Handler/"}]},{"title":"Broadcast","slug":"广播","date":"2018-07-20T04:10:37.805Z","updated":"2018-07-20T04:10:37.805Z","comments":true,"path":"2018/07/20/广播/","link":"","permalink":"http://yoursite.com/2018/07/20/广播/","excerpt":"","text":"广播1.1 定义 在Android中，它是一种广泛运用在应用程序之间传输信息的机制，Android中我们发送广播内容是一个Intent,这个Intent中可以携带我们要发送的数据。 1.2 广播的使用场景 a.同一app内有多个进程的不同组件之间的消息通信。 b.不同app之间的组件之间消息的通信。 1.3 广播的种类 标准广播：context.sendBroadcast(Intent)方法发送的广播，不可被拦截 有序广播：context.sendOrderBroadcast(Intent)方法发送的广播，可被拦截 本地广播：localBroadcastManager.sendBroadcast(Intent)，只在app内传播 广播接收器 广播接收器是专门用来接收广播信息的，它可分为静态注册和动态注册： 静态注册：注册完成一直在运行。 首先你要创建一个广播接收器类，实例代码如下：123456public class BootCompleteReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, &quot;Boot Complete&quot;, Toast.LENGTH_LONG).show(); &#125;&#125; 代码非常简单，我们只是在onReceive()方法中使用Toast弹出一段信息提示信息。另外，静态的广播接收器一定要在AndroidManifest.xml文件中注册才可以使用，AndroidManifest.xml文件中注册静态广播代码如下：1234567891011121314151617181920212223&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.broadcasttest&quot; android:versionCode=&quot;1&quot; android:versionName=&quot;1.0&quot; &gt; …… &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@drawable/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:theme=&quot;@style/AppTheme&quot; &gt; …… &lt;receiver android:name=&quot;.BootCompleteReceiver&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;/application&gt;&lt;/manifest&gt; 可以看到，标签内出现了一个新的标签，所有静态的广播接收器都是在这里进行注册的。它的用法其实和标签非常相似，也是通过android:name来指定具体注册哪一个广播接收器，而enabled和exported属性则是根据我们刚才勾选的状态自动生成的，也可以自己添加，没有就自己添加嘛！ 动态注册：跟随Activity的生命周期。 如何创建一个广播接收器呢？其实就需要新建一个类，让它继承自BroadcastReceiver,并重写父类的onReceive()方法就行了。这样有广播到来时，onReceive()方法就会得到执行，具体的逻辑就可以在这个方法中处理。来个简单的例子来理解以下，如何监听网络变化呢？其实就是新建一个广播接收器去接收来自系统网络变化的广播即可，代码如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MainActivity extends AppCompatActivity&#123; private IntentFilter intentFilter; private NetWorkChangeReceiver netWorkChangeReceiver; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.Oncreata(savedInstanceState); setContentView(R.layout.activity_main); intentFilter = new IntentFilter(); intentFilter.addAction(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;); networkChangeReceiver = new NetWorkChangeReceiver(); registerReceiver(networkChangeReceiver, intentFilter);//注册广播接收器 &#125; @Overrid protected void onDestroy()&#123; unregisterReceiver(networkChangeReceiver);//一定要记得取消广播接收器的注册 super.onDestroy(); &#125; class NetworkChangeReceiver extends BroadcastReceiver&#123;//广播接收器类 @Override public void onReceiver(Context context,Intent intent)&#123; //这里需要权限，需要在AndroidManifest.xml中进行网络访问权限申请: //&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt; ConnectivityManager connectionManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo networkInfo = connectionManager.getActiveNetworkInfo(); if (networkInfo != null &amp;&amp; networkInfo.isAvailable()) &#123; //有网 Toast.makeText(context, &quot;network is available&quot;,Toast.LENGTH_SHORT).show(); &#125; else &#123; //无网 Toast.makeText(context, &quot;network is unavailable&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;&#125; 动态注册广播接收器的优点以及缺点：动态注册的广播接收器可以自由地控制注册与注销，在灵活性方面有很大优势，但是它也存在着一个缺点，即必须要在程序启动之后才能接收到广播，因为注册的逻辑是写在onCreate()方法中的。那么有没有广播能在程序未启动的情况下就能接收到广播呢？静态注册的广播接收器就可以做到。 广播内部实现机制 a.自定义广播接收者BroadcastReceiver,并且重写onReceiver()方法。 b.通过Binder机制向AMS(Activity Manager Service)进行注册。 c.广播发送者通过Binder机制向AMS发送广播。 d.AMS查找符合条件(IntentFilter/Permission等)的BroadcastReceiver，将广播发送到相应的BroadcastReceiver(一般情况下是Activity)的消息队列中。 e.消息循环执行拿到此广播，回调BroadcastReceiver中的onReceiver()方法。 本地广播 本地广播的发送和注册广播接收器都需要使用到LocalBroadcastManager类，如下所示为本地广播的发送和本地广播接收器注册的代码： 本地广播的发送：123456public static void sendLocalBroadcast(Context context,String action)&#123; Intent intent = new Intent(action); LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(context); localBroadcastManager.sendBroadcast(intent);&#125; 本地广播的接收器的注册：123456IntentFilter intentFilter = new IntentFilter();LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(context);intentFilter.addAction(new BroadcastUtil().action_next);nasbr = new NextAndStartBroadcastReceiver();localBroadcastManager.registerReceiver(nasbr, intentFilter);//注册本地广播接收器 相比于系统广播而言，本地广播更加安全，更加高效，以下是本地广播的特点以及内部的实现机制： 特点： a.使用它发送的广播将只在自身app内传播，因此你不必担心泄漏隐私的数据。 b.其他app无法对你的app发送该广播，因此你的app根本不可能收到非自身app发送的该广播，因此你不必担心有安全漏洞可以利用。 c.比系统广播更加高效。 内部实现机制： a.LocalBroadcast高效的原因：因为它内部是通过Handler实现的，它的sendBroadcast()方法含义并非和系统的sendBroadcast()一样，它的sendBroadcast()方法其实就是通过Handler发送了一个Message而已。 b.LocalBroadcast安全的原因：既然它是通过Handler实现广播发送的，那么相比系统广播通过Binder机制实现那肯定更加高效，同时使用Handler来实现，别的app无法向我们应用发送该广播，而我们app内部发送的广播也不会离开我们的app。 LocalBroadcast内部协作主要是靠两个Map集合：mReceivers和mActions,当然还有一个List集合mPendingBroadcasts,这个主要存储待接收的广播对象。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Broadcast","slug":"Broadcast","permalink":"http://yoursite.com/tags/Broadcast/"}]},{"title":"java 基础知识(五)","slug":"异常机制","date":"2018-07-20T04:10:37.805Z","updated":"2018-07-20T04:10:37.805Z","comments":true,"path":"2018/07/20/异常机制/","link":"","permalink":"http://yoursite.com/2018/07/20/异常机制/","excerpt":"","text":"异常机制Java异常机制 异常是程序运行过程中出现的错误。本文主要讲授的是Java语言的异常处理。Java语言的异常处理框架，是Java语言健壮性的一个重要体现。 Java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类。在Java API中已经定义了许多异常类，这些异常类分为两大类，错误Error和异常Exception。Java异常体系结构呈树状，其层次结构图如图所示：Thorwable类Thorwable类所有异常和错误的超类，有两个子类Error和Exception，分别表示错误和异常。其中异常类Exception又分为运行时异常(RuntimeException)和非运行时异常，这两种异常有很大的区别，也称之为不检查异常（Unchecked Exception）和检查异常（Checked Exception）。Error（错误）：一般是指java虚拟机相关的问题，如系统崩溃、虚拟机出错误、动态链接失败等，这种错误无法恢复或不可能捕获，将导致应用程序中断，通常应用程序无法处理这些错误，因此应用程序不应该捕获Error对象，也无须在其throws子句中声明该方法抛出任何Error或其子类。Exception：Exception类及其子类是Throwable的一种形式，它指出了合理的应用程序想要捕获的条件 （1）SQLException：该异常提供关于数据库访问错误或其他错误的信息。 （2）RuntimeException 是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类 （3）IOException：此类为异常的通用类，它是由失败的或中断的 I/O 操作生成的。 运行时异常和非运行时异常（1）运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。（2）非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。 异常的捕获和处理Java异常的捕获和处理是一个不容易把握的事情，如果处理不当，不但会让程序代码的可读性大大降低，而且导致系统性能低下，甚至引发一些难以发现的错。Java异常处理涉及到五个关键字，分别是：try、catch、finally、throw、throws。下面将骤一介绍，通过认识这五个关键字，掌握基本异常处理知识。 （1）、try：它里面放置可能引发异常的代码 （2）、catch：后面对应异常类型和一个代码块，用于表明该catch块用于处理这种类型的代码块，可以有多个catch块。 （3）、finally：主要用于回收在try块里打开的物力资源（如数据库连接、网络连接和磁盘文件），异常机制总是保证finally块总是被执行。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。 finally执行过程：（4）、throw：用于抛出一个实际的异常，可以单独作为语句使用，抛出一个具体的异常对象。（5）、throws：用在方法签名中，用于声明该方法可能抛出的异常。常见的RuntimeExceptionNullPointerException- 空指针引用异常ClassCastException - 类型强制转换异常。IllegalArgumentException - 传递非法参数异常。ArithmeticException - 算术运算异常ArrayStoreException - 向数组中存放与声明类型不兼容对象异常IndexOutOfBoundsException - 下标越界异常NegativeArraySizeException - 创建一个大小为负数的数组错误异常NumberFormatException - 数字格式异常SecurityException - 安全异常UnsupportedOperationException - 不支持的操作异常异常捕捉的陷阱 使用 finally 块来保证回收，保证关闭操作总会被执行。 关闭每个资源之前首先保证引用该资源的引用变量不为null。 为每个物理资源单独使用try….catch块关闭资源，保证关闭资源时引发的异常不会影响到其他资源的关闭。finally 块陷阱finally 执行顺序catch 块用法在 try 块后使用 catch 块来捕获多个异常时，程序应该小心多个 catch 块之间的顺序：捕获父类异常的 catch 块都应该排在捕获子类异常的 catch 块之后（先处理小异常，再处理大异常），否则出现编译错误。继承得到的异常子类重写父类方法时，不能声明抛出比父类方法类型更多、范围更大的异常。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"异常","slug":"异常","permalink":"http://yoursite.com/tags/异常/"}]},{"title":"Spring Boot(六)","slug":"Spring Boot中使用JdbcTemplate访问数据库","date":"2018-07-20T04:10:37.805Z","updated":"2018-07-20T04:10:37.805Z","comments":true,"path":"2018/07/20/Spring Boot中使用JdbcTemplate访问数据库/","link":"","permalink":"http://yoursite.com/2018/07/20/Spring Boot中使用JdbcTemplate访问数据库/","excerpt":"","text":"Spring Boot中使用JdbcTemplate访问数据库数据源配置在我们访问数据库的时候，需要先配置一个数据源，下面分别介绍一下几种不同的数据库配置方式。 首先，为了连接数据库需要引入jdbc支持，在pom.xml中引入如下配置：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 嵌入式数据库支持嵌入式数据库通常用于开发和测试环境，不推荐用于生产环境。Spring Boot提供自动配置的嵌入式数据库有H2、HSQL、Derby，你不需要提供任何连接配置就能使用。 比如，我们可以在pom.xml中引入如下配置使用HSQL12345&lt;dependency&gt; &lt;groupId&gt;org.hsqldb&lt;/groupId&gt; &lt;artifactId&gt;hsqldb&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 连接生产数据源以MySQL数据库为例，先引入MySQL连接的依赖包，在pom.xml中加入：12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.21&lt;/version&gt;&lt;/dependency&gt; 在src/main/resources/application.properties中配置数据源信息1234spring.datasource.url=jdbc:mysql://localhost:3306/testspring.datasource.username=rootspring.datasource.password=spring.datasource.driver-class-name=com.mysql.jdbc.Driver 连接JNDI数据源当你将应用部署于应用服务器上的时候想让数据源由应用服务器管理，那么可以使用如下配置方式引入JNDI数据源。1spring.datasource.jndi-name=java:jboss/datasources/customers 使用JdbcTemplate操作数据库Spring的JdbcTemplate是自动配置的，你可以直接使用@Autowired来注入到你自己的bean中来使用。 举例：我们在创建User表，包含属性name、age，下面来编写数据访问对象和单元测试用例。 定义包含有插入、删除、查询的抽象接口UserService1234567891011121314151617181920212223242526public interface UserService &#123; /** * 新增一个用户 * @param name * @param age */ void create(String name, Integer age); /** * 根据name删除一个用户高 * @param name */ void deleteByName(String name); /** * 获取用户总量 */ Integer getAllUsers(); /** * 删除所有用户 */ void deleteAllUsers();&#125; 通过JdbcTemplate实现UserService中定义的数据访问操作1234567891011121314151617181920212223242526@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public void create(String name, Integer age) &#123; jdbcTemplate.update(&quot;insert into USER(NAME, AGE) values(?, ?)&quot;, name, age); &#125; @Override public void deleteByName(String name) &#123; jdbcTemplate.update(&quot;delete from USER where NAME = ?&quot;, name); &#125; @Override public Integer getAllUsers() &#123; return jdbcTemplate.queryForObject(&quot;select count(1) from USER&quot;, Integer.class); &#125; @Override public void deleteAllUsers() &#123; jdbcTemplate.update(&quot;delete from USER&quot;); &#125;&#125; 创建对UserService的单元测试用例，通过创建、删除和查询来验证数据库操作的正确性。123456789101112131415161718192021222324252627282930313233@RunWith(SpringJUnit4ClassRunner.class)@SpringApplicationConfiguration(Application.class)public class ApplicationTests &#123; @Autowired private UserService userSerivce; @Before public void setUp() &#123; // 准备，清空user表 userSerivce.deleteAllUsers(); &#125; @Test public void test() throws Exception &#123; // 插入5个用户 userSerivce.create(&quot;a&quot;, 1); userSerivce.create(&quot;b&quot;, 2); userSerivce.create(&quot;c&quot;, 3); userSerivce.create(&quot;d&quot;, 4); userSerivce.create(&quot;e&quot;, 5); // 查数据库，应该有5个用户 Assert.assertEquals(5, userSerivce.getAllUsers().intValue()); // 删除两个用户 userSerivce.deleteByName(&quot;a&quot;); userSerivce.deleteByName(&quot;e&quot;); // 查数据库，应该有5个用户 Assert.assertEquals(3, userSerivce.getAllUsers().intValue()); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"Spring Boot中使用JdbcTemplate访问数据库","slug":"Spring-Boot中使用JdbcTemplate访问数据库","permalink":"http://yoursite.com/tags/Spring-Boot中使用JdbcTemplate访问数据库/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-07-20T04:10:37.805Z","updated":"2018-07-20T04:10:37.805Z","comments":true,"path":"2018/07/20/hello-world/","link":"","permalink":"http://yoursite.com/2018/07/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"1","slug":"1","permalink":"http://yoursite.com/tags/1/"}]},{"title":"Spring Boot(三)","slug":"引入web模块","date":"2018-07-20T04:10:37.801Z","updated":"2018-07-20T04:10:37.801Z","comments":true,"path":"2018/07/20/引入web模块/","link":"","permalink":"http://yoursite.com/2018/07/20/引入web模块/","excerpt":"","text":"引入web模块1.pom.xml中添加支持web的模块（测试模块）：123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--测试依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;/dependency&gt; pom.xml文件中默认有两个模块：spring-boot-starter：核心模块，包括自动配置支持、日志和YAML；spring-boot-starter-test：测试模块，包括JUnit、Hamcrest、Mockito。 详细pom.xml文件内容，具体如下（注意parent配置，因为1.5.6.RELEASE配置了版本信息，所以所有子项目中的相对应包不需要再次配置版本号）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;Spring-Boot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;SpringBootDemo1 project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2. 编写controller 1234567891011import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloWorldController &#123; @RequestMapping(&quot;/hello&quot;) public String index() &#123; return &quot;Hello World&quot;; &#125;&#125;@RestController的含义是controller里面的方法都以json格式输出 3. 启动主程序打开浏览器访问http://localhost:8080/hello，就可以看到效果了，是不是感觉很简单！ 如何做单元测试？打开的src/test/下的测试入口，编写简单的http请求来测试；使用mockmvc进行，利用MockMvcResultHandlers.print()打印出执行结果。12345678910111213141516171819@RunWith(SpringJUnit4ClassRunner.class)@SpringApplicationConfiguration(classes = MockServletContext.class)@WebAppConfigurationpublic class HelloWorldControlerTests &#123; private MockMvc mvc; @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.standaloneSetup( new HelloWorldController()).build(); &#125; @Test public void getHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get(&quot;/hello&quot;) .accept(MediaType.APPLICATION_JSON)) .andExpect(MockMvcResultMatchers.status().isOk()) .andDo(MockMvcResultHandlers.print()) .andReturn(); &#125;&#125; 开发环境的调试热启动在正常开发项目中已经很常见了吧，虽然平时开发web项目过程中，改动项目启重启总是报错；但springBoot对调试支持很好，修改之后可以实时生效，需要添加以下的配置：123456789101112131415161718&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 注意：该模块在完整的打包环境下运行的时候会被禁用。如果你使用java -jar启动应用或者用一个特定的classloader启动，它会认为这是一个“生产环境”。 Spring Boot Maven插件Spring Boot Maven插件提供了使用Spring Boot应用程序步骤如下: 重新打包：创建一个可自动执行的jar或war文件。它可以替换常规工件，或者可以使用单独的分类器附加到构建生命周期。运行：运行您的Spring引导应用程序与几个选项传递参数。启动和停止：将Spring Boot应用程序集成到集成测试阶段，以便应用程序在其之前启动。构建信息：生成可由致动器使用的构建信息。 重新打包一个应用程序为了重新打包应用程序，只需要在pom.xml中添加对插件的引用，具体配置如下：1234567891011121314151617181920&lt;build&gt; ... &lt;plugins&gt; ... &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.5.6.RELEASE&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; ... &lt;/plugins&gt; ...&lt;/build&gt; 重新打包在Maven生命周期的包阶段中构建的jar或war，包括在项目中定义的任何提供的依赖关系。 默认情况下会自动排除Devtools（您可以使用excludeDevtools属性来控制）。为了使这些工作与war包装相匹配，“spring-boot-devtools”依赖关系必须设置为可选的或提供的范围。原始（即非可执行）文件默认情况下重命名为.original，但也可以使用自定义分类器保留原始工件。 Spring Boot Maven插件会重写配置，特别是它管理Main-Class和Start-Class条目，因此如果默认值不起作用，则必须配置它们（不在jar插件中）。主类实际上是由引导插件的布局属性控制的，实例：123456789101112131415161718192021222324&lt;build&gt; ... &lt;plugins&gt; ... &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.5.6.RELEASE&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;$&#123;start-class&#125;&lt;/mainClass&gt; &lt;layout&gt;ZIP&lt;/layout&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; ... &lt;/plugins&gt; ...&lt;/build&gt; 该布局属性基归档类型（(jar或者war）。可以在以下布局中使用：JAR：常规可执行JAR布局。WAR：可执行WAR布局。提供的依赖关系放置在WEB-INF/lib中，以避免战争部署在servlet容器中时发生冲突。ZIP（DIR的别名）：类似于使用PropertiesLauncher的JAR布局。MODULE：捆绑依赖（不包括提供的范围）和项目资源，不捆绑引导加载程序。NONE：捆绑所有依赖项和资源，不捆绑引导加载程序。运行应用程序Spring Boot Maven插件可以用于从命令行启动应用程序，具体执行命令如下：1mvn spring-boot:run 默认情况下，该应用程序直接从Maven JVM执行。如果需要在分叉进程中运行，可以使用’fork’选项。如果指定了’jvmArguments’或’agent’选项，或者如果存在devtools，则也会发生分岔。 如果需要指定一些JVM参数（即用于调试目的），可以使用jvmArguments参数。为方便起见，要启用的配置文件由特定属性（配置文件）处理。 使用集成测试为了确保Spring Boot应用程序的生命周期在集成测试中得到妥善管理，可以使用如下所述的启动和终止：123456789101112131415161718192021222324252627&lt;build&gt; ... &lt;plugins&gt; ... &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.5.6.RELEASE&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;pre-integration-test&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;start&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;post-integration-test&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;stop&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; ... &lt;/plugins&gt; ...&lt;/build&gt; 还可以配置更高级的设置，以便在设置特定属性时跳过集成测试：123456789101112131415161718192021222324252627282930313233343536373839&lt;properties&gt; &lt;it.skip&gt;false&lt;/it.skip&gt;&lt;/properties&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skip&gt;$&#123;it.skip&#125;&lt;/skip&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.5.6.RELEASE&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;pre-integration-test&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;start&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;skip&gt;$&#123;it.skip&#125;&lt;/skip&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;post-integration-test&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;stop&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;skip&gt;$&#123;it.skip&#125;&lt;/skip&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 注意：如果运行mvn verify -Dit.skip=true，那么集成测试将被完全跳过。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"Spring Boot 构建框架","slug":"Spring-Boot-构建框架","permalink":"http://yoursite.com/tags/Spring-Boot-构建框架/"}]},{"title":"单例模式","slug":"单例模式","date":"2018-07-20T04:10:37.801Z","updated":"2018-07-20T04:10:37.801Z","comments":true,"path":"2018/07/20/单例模式/","link":"","permalink":"http://yoursite.com/2018/07/20/单例模式/","excerpt":"","text":"单例模式定义：单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例。即一个类只有一个对象实例。 特点： 1、单例类只能有一个实例。 2、单例类必须自己自己创建自己的唯一实例。 3、单例类必须给所有其他对象提供这一实例 单例模式的要点： 1、私有的构造方法 2、指向自己实例的私有静态引用 3、以自己实例为返回值的静态的公有的方法 单例模式根据实例化对象时机的不同分为两种： 一种是饿汉式单例，一种是懒汉式单例。 饿汉式单例在单例类被加载时候，就实例化一个对象交给自己的引用；而懒汉式在调用取得实例方法的时候才会实例化对象。代码如下：饿汉式单例：123456789package SheJiMoShi;//饿汉式单例public class Singleton &#123; private static Singleton singleton = new Singleton(); private Singleton()&#123;&#125; public static Singleton getSingletonInstance()&#123; return singleton; &#125;&#125; 懒汉式单例12345678910111213package SheJiMoShi;//懒汉式单例public class Singleton2 &#123; private static Singleton2 singleton2; private Singleton2()&#123;&#125; public static synchronized Singleton2 getSingleton2()&#123; if (singleton2 == null)&#123; singleton2 = new Singleton2(); &#125; return singleton2; &#125;&#125; 单例模式还有一种比较常见的形式：双重锁的形式12345678910111213141516package SheJiMoShi;//双重锁的形式单例public class Singleton3 &#123; private static volatile Singleton3 singleton3 =null; private Singleton3()&#123;&#125; public static Singleton3 getSingleton3()&#123; if (singleton3 == null)&#123; synchronized (Singleton3.class)&#123; if (singleton3 == null)&#123; singleton3 = new Singleton3(); &#125; &#125; &#125; return singleton3; &#125;&#125; 这个模式将同步内容下方到if内部，提高了执行的效率，不必每次获取对象时都进行同步，只有第一次才同步，创建了以后就没必要了。 这种模式中双重判断加同步的方式，比第一个例子中的效率大大提升，因为如果单层if判断，在服务器允许的情况下，假设有一百个线程，耗费的时间为100*（同步判断时间+if判断时间），而如果双重if判断，100的线程可以同时if判断，理论消耗的时间只有一个if判断的时间。 所以如果面对高并发的情况，而且采用的是懒汉模式，最好的选择就是双重判断加同步的方式。 单例模式的优点： 1、在内存中只有一个对象，节省内存空间。 2、避免频繁的创建销毁对象，可以提高性能。 3、避免对共享资源的多重占用。 4、可以全局访问。 单例模式的缺点： 1、扩展困难，由于getInstance静态函数没有办法生成子类的实例。如果要拓展，只有重写那个类。 2、隐式使用引起类结构不清晰。 3、导致程序内存泄露的问题。 适用场景： 由于单例模式的以上优点，所以是编程中用的比较多的一种设计模式。以下为使用单例模式的场景： 1、需要频繁实例化然后销毁的对象。 2、创建对象时耗时过多或者耗资源过多，但又经常用到的对象。 3、资源共享的情况下，避免由于资源操作时导致的性能或损耗等 4、控制资源的情况下，方便资源之间的互相通信。 单例模式注意事项：只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。 不要做断开单例类对象与类中静态引用的危险操作。 多线程使用单例使用共享资源时，注意线程安全问题。 关于Java中单例模式的一些常见问题：单例模式的对象长时间不用会被jvm垃圾收集器收集吗？ 除非人为地断开单例中静态引用到单例对象的联接，否则jvm垃圾收集器是不会回收单例对象的。jvm卸载类的判定条件如下： 1、该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。 2、加载该类的ClassLoader已经被回收。 3、该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。 只有三个条件都满足，jvm才会在垃圾收集的时候卸载类。显然，单例的类不满足条件一，因此单例类也不会被回收。 在一个jvm中会出现多个单例吗在分布式系统、多个类加载器、以及序列化的的情况下，会产生多个单例，这一点是无庸置疑的。那么在同一个jvm中，会不会产生单例呢？使用单例提供的getInstance()方法只能得到同一个单例，除非是使用反射方式，将会得到新的单例。代码如下：1234Class c = Class.forName(Singleton.class.getName()); Constructor ct = c.getDeclaredConstructor(); ct.setAccessible(true); Singleton singleton = (Singleton)ct.newInstance(); 这样，每次运行都会产生新的单例对象。所以运用单例模式时，一定注意不要使用反射产生新的单例对象。 在getInstance()方法上同步有优势还是仅同步必要的块更优优势？ 因为锁定仅仅在创建实例时才有意义，然后其他时候实例仅仅是只读访问的，因此只同步必要的块的性能更优，并且是更好的选择。 缺点：只有在第一次调用的时候，才会出现生成2个对象，才必须要求同步。而一旦singleton 不为null，系统依旧花费同步锁开销，有点得不偿失。 单例类可以被继承吗 根据单例实例构造的时机和方式不同，单例模式还可以分成几种。但对于这种通过私有化构造函数，静态方法提供实例的单例类而言，是不支持继承的。 这种模式的单例实现要求每个具体的单例类自身来维护单例实例和限制多个实例的生成。但可以采用另外一种实现单例的思路：登记式单例，来使得单例对继承开放。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"工厂模式","slug":"工厂模式","date":"2018-07-20T04:10:37.801Z","updated":"2018-07-20T04:10:37.801Z","comments":true,"path":"2018/07/20/工厂模式/","link":"","permalink":"http://yoursite.com/2018/07/20/工厂模式/","excerpt":"","text":"工厂模式定义： 工厂模式是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。 工厂模式根据抽象程度的不同分为三种： 简单工厂模式（也叫静态工厂模式） 工厂方法模式（也叫多形性工厂） 抽象工厂模式（也叫工具箱） 简单工厂模式 实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。 工厂方法模式 工厂方法是粒度很小的设计模式，因为模式的表现只是一个抽象的方法。 提前定义用于创建对象的接口，让子类决定实例化具体的某一个类，即在工厂和产品中间增加接口，工厂不再负责产品的创建，由接口针对不同条件返回具体的类实例，由具体类实例去实现。 抽象工厂模式 当有多个抽象角色时使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品对象。它有多个抽象产品类，每个抽象产品类可以派生出多个具体产品类，一个抽象工厂类，可以派生出多个具体工厂类，每个具体工厂类可以创建多个具体产品类的实例。 工厂方法模式应该在实际中用的较多，我们以工厂方法模式举例（例子来源百度，帮助理解） 抽象的产品类：定义car 交通工具类123public interface Car &#123; void gotowork();&#125; 定义实际的产品类，总共定义两个，bike 和bus 分别表示不同的交通工具类123456public class Bike implements Car &#123; @Override public void gotowork() &#123; System.out.println(&quot;骑自行车去上班！&quot;); &#125;&#125; 123456public class Bus implements Car &#123; @Override public void gotowork() &#123; System.out.println(&quot;坐公交车去上班！&quot;); &#125;&#125; 定义抽象的工厂接口123public interface ICarFactory &#123; Car getCar();&#125; 具体的工厂子类，分别为每个具体的产品类创建不同的工厂子类123456public class BikeFactory implements ICarFactory &#123; @Override public Car getCar() &#123; return new Bike(); &#125;&#125; 123456public class BusFactory implements ICarFactory &#123; @Override public Car getCar() &#123; return new Bus(); &#125;&#125; 简单的测试类，来验证不同的工厂能够产生不同的产品对象123456789101112131415public class TestFactory &#123; @Test public void test() &#123; ICarFactory factory = null; // bike factory = new BikeFactory(); Car bike = factory.getCar(); bike.gotowork(); // bus factory = new BusFactory(); Car bus = factory.getCar(); bus.gotowork(); &#125;&#125; 工厂模式的优点：1、一个调用者想创建一个对象，只要知道其名称就可以了，降低了耦合度。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。使得代码结构更加清晰。 3、屏蔽产品的具体实现，调用者只关心产品的接口。 工厂模式的缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂（这里可以使用反射机制来避免），使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。所以对于简单对象来说，使用工厂模式反而增加了复杂度。 工厂模式的适用场景：1、 一个对象拥有很多子类。 2、 创建某个对象时需要进行许多额外的操作。 3、 系统后期需要经常扩展，它把对象实例化的任务交由实现类完成，扩展性好。 关于Java中的工厂模式的一些常见问题： 利用父类的向下转型（使用父类类型的引用指向子类的对象）是可以达到类似于工厂模式的效果的，那为什么还要用工厂模式呢？ 把指向子类对象的父类引用赋给子类引用叫做向下转型，如： Class Student extends Person Person s = new Student(); s = (Student)person ; 使用向下转型在客户端实例化子类的时候，严重依赖具体的子类的名字。当我们需要更改子类的构造方法的时候，比如增加一个参数，或者更改了子类的类名，所有的new出来的子类都需要跟着更改。 但如果我们使用工厂模式，我们仅仅需要在工厂中修改一下new的代码，其余项目中用到此实例的都会跟着改，而不需要我们手动去操作。 总结：无论是简单工厂模式、工厂模式还是抽象工厂模式，它们本质上都是将不变的部分提取出来，将可变的部分留作接口，以达到最大程度上的复用。究竟用哪种设计模式更适合，这要根据具体的业务需求来决定。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"原型模式","slug":"原型模式","date":"2018-07-20T04:10:37.801Z","updated":"2018-07-20T04:10:37.801Z","comments":true,"path":"2018/07/20/原型模式/","link":"","permalink":"http://yoursite.com/2018/07/20/原型模式/","excerpt":"","text":"原型模式定义：通过复制现有的对象实例来创建新的对象实例。 实现：实现Cloneable接口：Cloneable接口的作用是在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法。在java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出CloneNotSupportedException异常。 重写Object类中的clone方法：Java中，所有类的父类都是Object类，Object类中有一个clone方法，作用是返回对象的一个拷贝，但是其作用域protected类型的，一般的类无法调用，因此，原型类需要将clone方法的作用域修改为public类型。 示例：例如，对于拿邮件发邀请函，邮件类大部分内容都是一样的：邀请原由、相邀地点，相聚时间等等，但对于被邀请者的名称和发送的邮件地址是不同的。 定义Mail类：1234567891011121314151617181920212223242526272829303132333435363738public class Mail implements Cloneable &#123; private String receiver; private String subject; private String content; private String tail; public Mail(EventTemplate et) &#123; this.tail = et.geteventContent(); this.subject = et.geteventSubject(); &#125; @Override public Mail clone() &#123; Mail mail = null; try &#123; mail = (Mail) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return mail; &#125;//get、set.....&#125;测试方法：public static void main(String[] args) &#123; int i = 0; int MAX_COUNT = 10; EventTemplate et = new EventTemplate(&quot;邀请函（不变）&quot;, &quot;婚嫁生日啥的....（不变部分）&quot;); Mail mail = new Mail(et); while (i &lt; MAX_COUNT) &#123; Mail cloneMail = mail.clone(); cloneMail.setContent(&quot;XXX先生（女士）（变化部分）&quot; + mail.getTail()); cloneMail.setReceiver(&quot;每个人的邮箱地址...com（变化部分）&quot;); sendMail(cloneMail); i++; &#125;&#125; 优点：1、使用原型模型创建一个对象比直接new一个对象更有效率，因为它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。 2、隐藏了制造新实例的复杂性，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。 缺点：1、由于使用原型模式复制对象时不会调用类的构造方法，所以原型模式无法和单例模式组合使用，因为原型类需要将clone方法的作用域修改为public类型，那么单例模式的条件就无法满足了。 2、使用原型模式时不能有final对象。 3、Object类的clone方法只会拷贝对象中的基本数据类型，对于数组，引用对象等只能另行拷贝。这里涉及到深拷贝和浅拷贝的概念。 深拷贝与浅拷贝：浅拷贝：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的（这样不安全）。 深拷贝：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。 那么深拷贝如何具体实现呢？继续上面的例子，增加了一个ArrayList属性。123456789101112private String receiver;private String subject;private String content;private String tail;private ArrayList&lt;String&gt; ars;此时，单mail = (Mail) super.clone();无法将ars指向的地址区域改变，必须另行拷贝：try &#123; mail = (Mail) super.clone(); mail.ars = (ArrayList&lt;String&gt;)this.ars.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125; 适用场景：1、复制对象的结构和数据。 2、希望对目标对象的修改不影响既有的原型对象。 3、创建一个对象的成本比较大。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"单一职责原则","slug":"单一职责原则","date":"2018-07-20T04:10:37.801Z","updated":"2018-07-20T04:10:37.801Z","comments":true,"path":"2018/07/20/单一职责原则/","link":"","permalink":"http://yoursite.com/2018/07/20/单一职责原则/","excerpt":"","text":"单一职责原则定义：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。 问题由来：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。 解决方案：遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。举例说明，用一个类描述动物呼吸这个场景：123456789101112131415161718class Animal&#123; public void breathe(String animal)&#123; System.out.println(animal+&quot;呼吸空气&quot;); &#125; &#125; public class Client&#123; public static void main(String[] args)&#123; Animal animal = new Animal(); animal.breathe(&quot;牛&quot;); animal.breathe(&quot;羊&quot;); animal.breathe(&quot;猪&quot;); &#125; &#125;运行结果：牛呼吸空气羊呼吸空气猪呼吸空气 程序上线后，发现问题了，并不是所有的动物都呼吸空气的，比如鱼就是呼吸水的。修改时如果遵循单一职责原则，需要将Animal类细分为陆生动物类Terrestrial，水生动物Aquatic，代码如下：12345678910111213141516171819202122232425262728class Terrestrial&#123; public void breathe(String animal)&#123; System.out.println(animal+&quot;呼吸空气&quot;); &#125; &#125; class Aquatic&#123; public void breathe(String animal)&#123; System.out.println(animal+&quot;呼吸水&quot;); &#125; &#125; public class Client&#123; public static void main(String[] args)&#123; Terrestrial terrestrial = new Terrestrial(); terrestrial.breathe(&quot;牛&quot;); terrestrial.breathe(&quot;羊&quot;); terrestrial.breathe(&quot;猪&quot;); Aquatic aquatic = new Aquatic(); aquatic.breathe(&quot;鱼&quot;); &#125; &#125;运行结果：牛呼吸空气羊呼吸空气猪呼吸空气鱼呼吸水 我们会发现如果这样修改花销是很大的，除了将原来的类分解之外，还需要修改客户端。而直接修改类Animal来达成目的虽然违背了单一职责原则，但花销却小的多，代码如下：12345678910111213141516171819class Animal&#123; public void breathe(String animal)&#123; if(&quot;鱼&quot;.equals(animal))&#123; System.out.println(animal+&quot;呼吸水&quot;); &#125;else&#123; System.out.println(animal+&quot;呼吸空气&quot;); &#125; &#125; &#125; public class Client&#123; public static void main(String[] args)&#123; Animal animal = new Animal(); animal.breathe(&quot;牛&quot;); animal.breathe(&quot;羊&quot;); animal.breathe(&quot;猪&quot;); animal.breathe(&quot;鱼&quot;); &#125; &#125; 可以看到，这种修改方式要简单的多。但是却存在着隐患：有一天需要将鱼分为呼吸淡水的鱼和呼吸海水的鱼，则又需要修改Animal类的breathe方法，而对原有代码的修改会对调用“猪”“牛”“羊”等相关功能带来风险，也许某一天你会发现程序运行的结果变为“牛呼吸水”了。这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式：12345678910111213141516171819class Animal&#123; public void breathe(String animal)&#123; System.out.println(animal+&quot;呼吸空气&quot;); &#125; public void breathe2(String animal)&#123; System.out.println(animal+&quot;呼吸水&quot;); &#125; &#125; public class Client&#123; public static void main(String[] args)&#123; Animal animal = new Animal(); animal.breathe(&quot;牛&quot;); animal.breathe(&quot;羊&quot;); animal.breathe(&quot;猪&quot;); animal.breathe2(&quot;鱼&quot;); &#125; &#125; 可以看到，这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然也违背了单一职责原则，但在方法级别上却是符合单一职责原则的，因为它并没有动原来方法的代码。这三种方式各有优缺点，那么在实际编程中，采用哪一中呢？其实这真的比较难说，需要根据实际情况来确定。我的原则是：只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则； 例如本文所举的这个例子，它太简单了，它只有一个方法，所以，无论是在代码级别上违反单一职责原则，还是在方法级别上违反，都不会造成太大的影响。实际应用中的类都要复杂的多，一旦发生职责扩散而需要修改类时，除非这个类本身非常简单，否则还是遵循单一职责原则的好。 遵循单一职责原的优点有：1、可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；2、提高类的可读性，提高系统的可维护性；3、变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。 需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"策略模式","slug":"策略模式","date":"2018-07-20T04:10:37.801Z","updated":"2018-07-20T04:10:37.801Z","comments":true,"path":"2018/07/20/策略模式/","link":"","permalink":"http://yoursite.com/2018/07/20/策略模式/","excerpt":"","text":"策略模式定义：定义一组算法，将每个算法都封装起来，并且使他们之间可以互换。 类型：行为类模式 需求1，父类实现问题由来现在要设计一只鸭子类，所有的鸭子都可以游泳，不同的鸭子样外貌可能不一样。 刚拿到这个需求，很简答的想法设计一个Duck类，拥有共有的方法swim，并且包含一个抽象方法display展示形态。 Duck.java12345678abstract class Duck&#123; public void swim()&#123; System.out.println(&quot;I am swimming&quot;); &#125; public abstract void display();&#125; GreenDuck.java12345678public class GreenDuck extends Duck&#123; @Override public void display() &#123; System.out.println(&quot;my color is green&quot;); &#125;&#125; RedDuck.java12345678public class RedDuck extends Duck&#123; @Override public void display() &#123; System.out.println(&quot;my color is red&quot;); &#125;&#125; 为什么swim()方法是普通方法，display() 方法是抽象方法呢？这里是为了体现，所有的都会游泳，并且都一样。所有鸭子都有外貌，但是是由各自决定，所以必须子类来重写。 需求2，接口实现这时候需求变更，有些鸭子可以飞。 注意，这里的关键词是可以。如果这个时候我们把 fly() 方法写在子类 Duck 中，那就表示所有的鸭子都会飞。所以这个时候我们想到了接口，定义 Flyable 接口，让会飞的鸭子实现接口，并重写方法。 Flyable.java12345public interface Flyable &#123; void fly();&#125; GreenDuck.java1234567891011public class GreenDuck extends Duck implements Flyable&#123; public void fly() &#123; System.out.println(&quot;I am flying with wing&quot;); &#125; @Override public void display() &#123; System.out.println(&quot;my color is green&quot;); &#125;&#125; 假设GreenDuck会飞，那么它需要实现flyable接口，然后写自己会飞。RedDuck不会飞，所以不实现flyable接口。看似问题解决了，但是如果这个时候我们系统中有几十种鸭子，而且会飞只分用翅膀飞，不能飞，用喷气式火箭飞3种，如果采用接口来实现，几十种鸭子都需要自己去实现方法，无法代码重用，这种设计是不是很不好呢，代码重用率太低。而且，如果后面我们还要添加其他的属性，比如说话Speakable，那我们需要添加一个新接口，并且以前的鸭子都要从新实现一遍，完全违反了开闭原则。而且，如果后面我们还要添加其他的属性，比如说话Speakable，那我们需要添加一个新接口，并且以前的鸭子都要从新实现一遍，完全违反了开闭原则。 需求3，策略模式实现策略模式说，我们需要把最公有的相同的方法放在父类中，将可以变化的方法抽取成接口，并通过组合的方式放到父类中，子类通过插入不同的接口实现，完成类的配置。Duck类中，swim() 方法属于共有并且都相同的方法，display() 属于都有，但是需要自己去实现的方法。fly和speak是有些子类有的方法，并且实现有相同有不同，我们应该抽取成接口放在父类中。来看看代码：修改Duck类：123456789101112131415161718192021abstract class Duck&#123; protected Flyable flyable; public void swim()&#123; System.out.println(&quot;I am swimming&quot;); &#125; public abstract void display(); public void performFly()&#123; // 通过多态机制，动态决定到底怎么飞 flyable.fly(); &#125; // 设置飞的具体实现，并随时可以改变 public void setFlayable(Flyable flyable)&#123; //TODO:添加非空判断 this.flyable = flyable; &#125;&#125; 实现3中飞的行为： Flyable.java123public interface Flyable &#123; void fly();&#125; FlyNoWay.java 不能飞123456public class FlyNoWay implements Flyable&#123; public void fly() &#123; System.out.println(&quot;can not fly&quot;); &#125;&#125; FlyWithWing.java 用翅膀飞123456public class FlyWithWing implements Flyable&#123; public void fly() &#123; System.out.println(&quot;fly with wing&quot;); &#125;&#125; FlyWithRocket 用火箭飞123456public class FlyWithRocket implements Flyable&#123; public void fly() &#123; System.out.println(&quot;fly with rocket&quot;); &#125;&#125; 如果现在要让 GreenDuck 有飞的属性，应该这样做： GreenDuck.java1234567891011public class GreenDuck extends Duck&#123; public GreenDuck()&#123; this.flyable = new FlyNoWay(); &#125; @Override public void display() &#123; System.out.println(&quot;my color is green&quot;); &#125;&#125; Main.java12345678910public class Main &#123; public static void main(String[] args) &#123; GreenDuck gDuck = new GreenDuck(); gDuck.performFly(); gDuck.setFlayable(new FlyWithWing()); gDuck.performFly(); &#125;&#125; 默认GreenDuck是不会飞的，然后可以通过动态的设置飞属性给鸭子，让他具有各种飞的属性。将飞与类解耦，并且也达到了飞实现重用的目的。 策略模式大概就是这样，如果这个时候我们要添加 Speak 属性，怎么做么？ 添加新功能step1: 添加 Speakable接口，和两种实现Speakable.java123public interface Speakable &#123; void speak();&#125; SpeakDuckLaguage .java1234567public class SpeakDuckLaguage implements Speakable &#123; public void speak() &#123; System.out.println(&quot;I can speak duck language&quot;); &#125;&#125; SpeakHumanLaguage.java12345public class SpeakHumanLaguage implements Speakable &#123; public void speak() &#123; System.out.println(&quot;I can speak human language&quot;); &#125;&#125; step2: Duck类中添加Speakable属性，并且提供set方法，然后提供一个执行speak的方法12345678910111213141516abstract class Duck&#123; protected Flyable flyable; protected Speakable speakable; //... public void performSpeak()&#123; speakable.speak(); &#125; public void setSpeakable(Speakable speakable)&#123; //TODO: 非空判断 this.speakable = speakable; &#125;&#125; step3: 给红鸭子添加会说话属性RedDuck.java 默认说鸭子语言123456789101112public class RedDuck extends Duck&#123; // 默认说鸭子语言 public RedDuck()&#123; this.speakable = new SpeakDuckLaguage(); &#125; @Override public void display() &#123; System.out.println(&quot;my color is red&quot;); &#125;&#125; Main.java 客户端调用1234567891011121314public class Main &#123; public static void main(String[] args) &#123; GreenDuck gDuck = new GreenDuck(); gDuck.performFly(); gDuck.setFlayable(new FlyWithWing()); gDuck.performFly(); RedDuck rDuck = new RedDuck(); rDuck.performSpeak(); rDuck.setSpeakable(new SpeakHumanLaguage()); rDuck.performSpeak(); &#125;&#125; 策略模式的优缺点策略模式的主要优点有： 策略类之间可以自由切换，由于策略类实现自同一个抽象，所以他们之间可以自由切换。 易于扩展，增加一个新的策略对策略模式来说非常容易，基本上可以在不改变原有代码的基础上进行扩展。 避免使用多重条件，如果不使用策略模式，对于所有的算法，必须使用条件语句进行连接，通过条件判断来决定使用哪一种算法，在上一篇文章中我们已经提到，使用多重条件判断是非常不容易维护的。 策略模式的缺点主要有两个： 维护各个策略类会给开发带来额外开销，可能大家在这方面都有经验：一般来说，策略类的数量超过5个，就比较令人头疼了。 必须对客户端（调用者）暴露所有的策略类，因为使用哪种策略是由客户端来决定的，因此，客户端应该知道有什么策略，并且了解各种策略之间的区别，否则，后果很严重。例如，有一个排序算法的策略模式，提供了快速排序、冒泡排序、选择排序这三种算法，客户端在使用这些算法之前，是不是先要明白这三种算法的适用情况？再比如，客户端要使用一个容器，有链表实现的，也有数组实现的，客户端是不是也要明白链表和数组有什么区别？就这一点来说是有悖于迪米特法则的。 适用场景 做面向对象设计的，对策略模式一定很熟悉，因为它实质上就是面向对象中的继承和多态，在看完策略模式的通用代码后，我想，即使之前从来没有听说过策略模式，在开发过程中也一定使用过它吧？至少在在以下两种情况下，大家可以考虑使用策略模式： 几个类的主要逻辑相同，只在部分逻辑的算法和行为上稍有区别的情况。 有几种相似的行为，或者说算法，客户端需要动态地决定使用哪一种，那么可以使用策略模式，将这些算法封装起来供客户端调用。 策略模式是一种简单常用的模式，我们在进行开发的时候，会经常有意无意地使用它，一般来说，策略模式不会单独使用，跟模版方法模式、工厂模式等混合使用的情况比较多。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"依赖倒置原则","slug":"依赖倒置原则","date":"2018-07-20T04:10:37.801Z","updated":"2018-07-20T04:10:37.797Z","comments":true,"path":"2018/07/20/依赖倒置原则/","link":"","permalink":"http://yoursite.com/2018/07/20/依赖倒置原则/","excerpt":"","text":"依赖倒置原则定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。 问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。 解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。 依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。 依赖倒置原则的核心思想是面向接口编程，我们依旧用一个例子来说明面向接口编程比相对于面向实现编程好在什么地方。场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。代码如下： 123456789101112131415161718192021222324252627282930class Book&#123; public String getContent()&#123; return &quot;很久很久以前有一个阿拉伯的故事……&quot;; &#125; &#125; class Mother&#123; public void narrate(Book book)&#123; System.out.println(&quot;妈妈开始讲故事&quot;); System.out.println(book.getContent()); &#125; &#125; public class Client&#123; public static void main(String[] args)&#123; Mother mother = new Mother(); mother.narrate(new Book()); &#125; &#125; 运行结果：妈妈开始讲故事很久很久以前有一个阿拉伯的故事…… 运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸，让这位母亲讲一下报纸上的故事，报纸的代码如下：class Newspaper&#123; public String getContent()&#123; return &quot;林书豪38+7领导尼克斯击败湖人……&quot;; &#125; &#125; 这位母亲却办不到，因为她居然不会读报纸上的故事，这太荒唐了，只是将书换成报纸，居然必须要修改Mother才能读。假如以后需求换成杂志呢？换成网页呢？还要不断地修改Mother，这显然不是好的设计。原因就是Mother与Book之间的耦合性太高了，必须降低他们之间的耦合度才行。 我们引入一个抽象的接口IReader。读物，只要是带字的都属于读物：123interface IReader&#123; public String getContent(); &#125; Mother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，他们各自都去实现IReader接口，这样就符合依赖倒置原则了，代码修改为：123456789101112131415161718192021222324252627282930class Newspaper implements IReader &#123; public String getContent()&#123; return &quot;林书豪17+9助尼克斯击败老鹰……&quot;; &#125; &#125; class Book implements IReader&#123; public String getContent()&#123; return &quot;很久很久以前有一个阿拉伯的故事……&quot;; &#125; &#125; class Mother&#123; public void narrate(IReader reader)&#123; System.out.println(&quot;妈妈开始讲故事&quot;); System.out.println(reader.getContent()); &#125; &#125; public class Client&#123; public static void main(String[] args)&#123; Mother mother = new Mother(); mother.narrate(new Book()); mother.narrate(new Newspaper()); &#125; &#125;运行结果：妈妈开始讲故事很久很久以前有一个阿拉伯的故事……妈妈开始讲故事林书豪17+9助尼克斯击败老鹰…… 这样修改后，无论以后怎样扩展Client类，都不需要再修改Mother类了。这只是一个简单的例子，实际情况中，代表高层模块的Mother类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。 采用依赖倒置原则给多人并行开发带来了极大的便利，比如上例中，原本Mother类与Book类直接耦合时，Mother类必须等Book类编码完成后才可以进行编码，因为Mother类依赖于Book类。修改后的程序则可以同时开工，互不影响，因为Mother与Book类一点关系也没有。参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。 传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递，相信用过Spring框架的，对依赖的传递方式一定不会陌生。 在实际编程中，我们一般需要做到如下3点： 低层模块尽量都要有抽象类或接口，或者两者都有。 变量的声明类型尽量是抽象类或接口。 使用继承时遵循里氏替换原则。依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"我的第一个Android设计——登录和注册","slug":"Toast为什么不可以在子线程里面运行","date":"2018-07-20T04:10:37.801Z","updated":"2018-07-20T04:10:37.801Z","comments":true,"path":"2018/07/20/Toast为什么不可以在子线程里面运行/","link":"","permalink":"http://yoursite.com/2018/07/20/Toast为什么不可以在子线程里面运行/","excerpt":"","text":"Toast为什么不可以在子线程里面运行Handler不能再子线程里运行的 因为子线程没有创建Looper.prepare(); 所以就报错了。主线程不需要调用，是因为主线程已经默认帮你调用了。 可以看到一个Toast的创建需要依赖Handler。那么 我不要 我不要 我一定要在子线程使用Toast那怎么办。其实很简单，它却什么就给它什么。 第一种方法12345678910111213new Thread()&#123; @Override public void run() &#123; super.run(); Looper.prepare(); try &#123; Toast.makeText(LoginActivity.this,&quot;keshe&quot;,Toast.LENGTH_SHORT).show(); &#125;catch (Exception e) &#123; Logger.e(&quot;error&quot;,e.toString()); &#125; Looper.loop(); &#125; &#125;.start(); 因为除了Activity ui线程默认创建之外，其他线程不会自动创建调用 Looper.prepare()来给线程创建消息循环，然后再通过，Looper.loop()来使消息循环起作用。 第二种方法123456789runOnUiThread(new Runnable() &#123; @Override public void run() &#123; Toast.makeText(MainActivity.this,&quot;keshe23333&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125;); new Thread()&#123; &#125;.start(); Toast的代码创建在Runnable中，然后在需要Toast时，把这个Runnable对象传给runOnUiThread(Runnable)。 这样Runnable对像就能在ui程序中被调用。如果当前线程是UI线程,那么行动是立即执行 第三种方法123456789101112131415Handler mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); //这里写你的Toast代码Toast.makeText(MainActivity.this,&quot;keshe23333&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125;; new Thread()&#123; @Override public void run() &#123; super.run(); mHandler.sendEmptyMessage(0); &#125; &#125;.start();","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android 课设","slug":"Android-课设","permalink":"http://yoursite.com/tags/Android-课设/"}]},{"title":"javaweb (十 )","slug":"一、会话的概念","date":"2018-07-20T04:10:37.801Z","updated":"2018-07-20T04:10:37.801Z","comments":true,"path":"2018/07/20/一、会话的概念/","link":"","permalink":"http://yoursite.com/2018/07/20/一、会话的概念/","excerpt":"","text":"###一、会话的概念 会话可简单理解为：用户开一个浏览器，点击多个超链接，访问服务器多个web资源，然后关闭浏览器，整个过程称之为一个会话。 有状态会话：一个同学来过教室，下次再来教室，我们会知道这个同学曾经来过，这称之为有状态会话。二、会话过程中要解决的一些问题？每个用户在使用浏览器与服务器进行会话的过程中，不可避免各自会产生一些数据，程序要想办法为每个用户保存这些数据。三、保存会话数据的两种技术####3.1、Cookie Cookie是客户端技术，程序把每个用户的数据以cookie的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务器中的web资源时，就会带着各自的数据去。这样，web资源处理的就是用户各自的数据了。3.2、Session Session是服务器端技术，利用这个技术，服务器在运行时可以为每一个用户的浏览器创建一个其独享的session对象，由于session为用户浏览器独享，所以用户在访问服务器的web资源时，可以把各自的数据放在各自的session中，当用户再去访问服务器中的其它web资源时，其它web资源再从用户各自的session中取出数据为用户服务。####四、Java提供的操作Cookie的APIJava中的javax.servlet.http.Cookie类用于创建一个Cookie 方法 类型 描述 Cookie(String name, String value) 构造方法 实例化Cookie对象，传入cooke名称和cookie的值 public String getName() 普通方法 取得Cookie的名字 public String getValue() 普通方法 取得Cookie的值 public void setValue(String newValue) 普通方法 设置Cookie的值 ppublic void setMaxAge(int expiry) 普通方法 取设置Cookie的最大保存时间，即cookie的有效期 public int getMaxAge() 普通方法 获取Cookies的有效期 public void setPath(String uri) 普通方法 设置cookie的有效路径，比如把cookie的有效路径设置为”/xdp”，那么浏览器访问”xdp”目录下的web资源时，都会带上cookie，再比如把cookie的有效路径设置为”/xdp/qgx”，那么浏览器只有在访问”xdp”目录下的”qgx”这个目录里面的web资源时才会带上cookie一起访问，而当访问”xdp”目录下的web资源时，浏览器是不带cookie的 public String getPath() 普通方法 获取cookie的有效路径 public void setDomain(String pattern) 普通方法 获 设置cookie的有效域 public String getDomain() 普通方法 获取cookie的有效域 response接口也中定义了一个addCookie方法，它用于在其响应头中增加一个相应的Set-Cookie头字段。 同样，request接口中也定义了一个getCookies方法，它用于获取客户端提交的Cookie。 五、Cookie使用范例5.1、使用cookie记录用户上一次访问的时间123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package qgx.cookie;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.Date;/** * cookie实例 ：获取用户上一次访问的时间 */@WebServlet(name = &quot;CookieDemo1&quot;)public class CookieDemo1 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;doGet(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //设置服务器端以UTF-8编码进行输出 response.setCharacterEncoding(&quot;utf-8&quot;); //设置浏览器以UTF-8编码进行接收,解决中文乱码问题 response.setContentType(&quot;text/html;charset=UTF-8&quot;); PrintWriter out = response.getWriter(); Cookie[] cookies = request.getCookies(); //如果用户是第一次访问，那么得到的cookies将是null if (cookies!=null)&#123; out.write(&quot;您上次访问的时间是：&quot;); for (int i = 0; i &lt; cookies.length; i++) &#123; Cookie cookie = cookies[i]; if (cookie.getName().equals(&quot;lastAccessTime&quot;)) &#123; Long lastAccessTime =Long.parseLong(cookie.getValue()); Date date = new Date(lastAccessTime); out.write(date.toString()); &#125; &#125; &#125;else &#123; out.write(&quot;首次来访！&quot;); &#125; //用户访问过之后重新设置用户的访问时间，存储到cookie中，然后发送到客户端浏览器 Cookie cookie = new Cookie(&quot;lastAccessTime&quot;, System.currentTimeMillis()+&quot;&quot;);//创建一个cookie，cookie的名字是lastAccessTime //将cookie对象添加到response对象中，这样服务器在输出response对象中的内容时就会把cookie也输出到客户端浏览器 response.addCookie(cookie); &#125;&#125; 在上面的例子中，在程序代码中并没有使用setMaxAge方法设置cookie的有效期，所以当关闭浏览器之后，cookie就失效了，要想在关闭了浏览器之后，cookie依然有效，那么在创建cookie时，就要为cookie设置一个有效期。如下所示：123456//用户访问过之后重新设置用户的访问时间，存储到cookie中，然后发送到客户端浏览器 Cookie cookie = new Cookie(&quot;lastAccessTime&quot;, System.currentTimeMillis()+&quot;&quot;);//创建一个cookie，cookie的名字是lastAccessTime //设置Cookie的有效期为1天cookie.setMaxAge(24*60*60); //将cookie对象添加到response对象中，这样服务器在输出response对象中的内容时就会把cookie也输出到客户端浏览器 response.addCookie(cookie); 六、Cookie注意细节1234一个Cookie只能标识一种信息，它至少含有一个标识该信息的名称（NAME）和设置值（VALUE）。一个WEB站点可以给一个WEB浏览器发送多个Cookie，一个WEB浏览器也可以存储多个WEB站点提供的Cookie。浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为4KB。如果创建了一个cookie，并将他发送到浏览器，默认情况下它是一个会话级别的cookie（即存储在浏览器的内存中），用户退出浏览器之后即被删除。若希望浏览器将该cookie存储在磁盘上，则需要使用maxAge，并给出一个以秒为单位的时间。将最大时效设为0则是命令浏览器删除该cookie。 6.1、删除Cookie注意：删除cookie时，path必须一致，否则不会删除123456789101112131415161718192021222324package qgx.cookie;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = &quot;CookieDemo2&quot;)public class CookieDemo2 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //创建一个名字为lastAccessTime的cookie Cookie cookie = new Cookie(&quot;lastAccessTime&quot;, System.currentTimeMillis() + &quot;&quot;); //将cookie的有效期设置为0，命令浏览器删除该cookie cookie.setMaxAge(0); response.addCookie(cookie); &#125;&#125; 6.2、cookie中存取中文 要想在cookie中存储中文，那么必须使用URLEncoder类里面的encode(String s, String enc)方法进行中文转码，例如： 12Cookie cookie = new Cookie(&quot;userName&quot;, URLEncoder.encode(&quot;刘俭梅&quot;, &quot;UTF-8&quot;));response.addCookie(cookie); 在获取cookie中的中文数据时，再使用URLDecoder类里面的decode(String s, String enc)进行解码，例如： 1URLDecoder.decode(cookies[i].getValue(), &quot;UTF-8&quot;)","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://yoursite.com/categories/javaEE/"}],"tags":[{"name":"Cookie","slug":"Cookie","permalink":"http://yoursite.com/tags/Cookie/"}]},{"title":"java基础知识(三)","slug":"常见集合的实现细节","date":"2018-07-20T04:10:37.797Z","updated":"2018-07-20T04:10:37.797Z","comments":true,"path":"2018/07/20/常见集合的实现细节/","link":"","permalink":"http://yoursite.com/2018/07/20/常见集合的实现细节/","excerpt":"","text":"常见集合的实现细节java集合框架类图Set 和 Map Set 代表一种集合元素无序、集合元素不可重复的集合，Map 则代表一种由多个 key-value 对组合的集合，Map 集合类似于传统的关联数组。 Map 集合中的 key 不能重复且没有顺序。将这些 key 组合起来就是一个 Set 集合。所以有一个 Set keySet() 方法来返回所有 key 组成的 Set 集合。 Set 也可以转换成 Map。（在 Set 中将 每一对 key 和 value 存放在一起）HashMap 和 HashSet HashSet：系统采用 Hash 算法决定集合元素的存储位置。（基于 HashMap 实现的） HashMap：系统将 value 当成 key 的附属，系统根据 Hash 算法决定 key 的存储位置。 HashSet 的绝大部分方法都是通过调用 HashMap 的方法实现的，因此 HashSet 和 HashMap 两个集合在实现本质上是相同的。TreeMap 和 TreeSet TreeSet 底层使用 TreeMap 来包含 Set 集合中的所有元素。 TreeMap 采用的是一种“红黑树”的排序二叉树来保存 Map 中每个 Entry —— 每个 Entry 都被当成 “红黑树” 的一个节点对待。Map 和 List 1 Map的values()方法 不管是 HashMap 还是 TreeMap ，它们的 values() 方法都可以返回其所有 value 组成的 Collection 集合，其实是一个不存储元素的 Collection 集合，当程序遍历 Collection 集合时，实际上就是遍历 Map 对象的 value。 HashMap 和 TreeMap 的 values() 方法并未把 Map 中的 values 重新组合成一个包含元素的集合对象，这样就可以降低系统内存开销。 2 Map 和 List的关系 Map 接口提供 get(K key) 方法允许 Map 对象根据 key 来取得 value； List 接口提供了 get(int index) 方法允许 List 对象根据元素索引来取得 value； ArrayList 和 LinkedListList的实现类，主要有ArrayList、Vector和LinkedList ArrayList 是一个可改变大小的数组.当更多的元素加入到 ArrayList 中时, 其大小将会动态地增长. 内部的元素可以直接通过 get 与 set 方法进行访问, 因为 ArrayList 本质上就是一个数组。 LinkedList 是一个双链表, 在添加和删除元素时具有比 ArrayList 更好的性能. 但在 get 与 set 方面弱于ArrayList. 当然, 这些对比都是指数据量很大或者操作很频繁的情况下的对比, 如果数据和运算量很小,那么对比将失去意义。 Vector 和 ArrayList 类似, 但属于强同步类。如果你的程序本身是线程安全的(thread-safe,没有在多个线程之间共享同一个集合/对象),那么使用 ArrayList 是更好的选择。 Vector 和 ArrayList 在更多元素添加进来时会请求更大的空间。Vector 每次请求其大小的双倍空间，而 ArrayList每次对 size 增长 50%。而 LinkedList 还实现了 Queue 接口, 该接口比 List 提供了更多的方法,包括 offer(), peek(), poll()等.注意: 默认情况下 ArrayList 的初始容量非常小, 所以如果可以预估数据量的话, 分配一个较大的初始值属于最佳实践, 这样可以减少调整大小的开销。 ArrayList与LinkedList性能对比时间复杂度对比如下: 函数 ArrayList LinkedList get() O(1) O(n) add() O(1) O(1) amortized remove() O(n) O(n) LinkedList 更适用于: 没有大规模的随机读取 大量的增加/删除操作 Iterator 迭代器是一个迭代器接口，专门用于迭代各种 Collection 集合，包括 Set 集合和 List 集合。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"常见集合的实现细节","slug":"常见集合的实现细节","permalink":"http://yoursite.com/tags/常见集合的实现细节/"}]},{"title":"javaweb (十二 )","slug":"一、表单重复提交的常见应用场景","date":"2018-07-20T04:10:37.797Z","updated":"2018-07-20T04:10:37.797Z","comments":true,"path":"2018/07/20/一、表单重复提交的常见应用场景/","link":"","permalink":"http://yoursite.com/2018/07/20/一、表单重复提交的常见应用场景/","excerpt":"","text":"在平时开发中，如果网速比较慢的情况下，用户提交表单后，发现服务器半天都没有响应，那么用户可能会以为是自己没有提交表单，就会再点击提交按钮重复提交表单，我们在开发中必须防止表单重复提交。 一、表单重复提交的常见应用场景form.jsp1234567891011121314151617181920&lt;%-- Created by IntelliJ IDEA. User: qgx Date: 2018/5/29 Time: 21:52 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Form表单&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/DoFormServlet&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; id=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; form表单提交到DoFormServlet进行处理123456789101112131415161718192021222324252627package qgx.session;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = &quot;DoFormServlet&quot;)public class DoFormServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(&quot;UTF-8&quot;); String userName = request.getParameter(&quot;username&quot;); try &#123; //让当前的线程睡眠3秒钟，模拟网络延迟而导致表单重复提交的现象 Thread.sleep(3 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;向数据库中插入数据：&quot; + userName); &#125;&#125; 如果没有进行form表单重复提交处理，那么在网络延迟的情况下下面的操作将会导致form表单重复提交多次 1.1、场景一：在网络延迟的情况下让用户有时间点击多次submit按钮导致表单重复提交1.2、场景二：表单提交后用户点击【刷新】按钮导致表单重复提交 点击浏览器的刷新按钮，就是把浏览器上次做的事情再做一次，因为这样也会导致表单重复提交。 1.3、场景三：用户提交表单后，点击浏览器的【后退】按钮回退到表单页面后进行再次提交二、利用JavaScript防止表单重复提交既然存在上述所说的表单重复提交问题，那么我们就要想办法解决，比较常用的方法是采用JavaScript来防止表单重复提交，具体做法如下： 修改form.jsp页面，添加如下的JavaScript代码来防止表单重复提交form.jsp12345678910111213141516171819202122232425262728293031&lt;%-- Created by IntelliJ IDEA. User: qgx Date: 2018/5/29 Time: 21:52 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Form表单&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var isCommitted = false;//表单是否已经提交标识，默认为false function dosubmit()&#123; if(isCommitted==false)&#123; isCommitted = true;//提交表单后，将表单是否已经提交标识设置为true return true;//返回true让表单正常提交 &#125;else&#123; return false;//返回false那么表单将不提交 &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/DoFormServlet&quot; onsubmit=&quot;return dosubmit()&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; id=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 可以看到，针对”在网络延迟的情况下让用户有时间点击多次submit按钮导致表单重复提交”这个应用场景，使用JavaScript是可以解决这个问题的，解决的做法就是”用JavaScript控制Form表单只能提交一次”。 除了用这种方式之外，经常见的另一种方式就是表单提交之后，将提交按钮设置为不可用，让用户没有机会点击第二次提交按钮，代码如下：12345678function dosubmit()&#123; //获取表单提交按钮 var btnSubmit = document.getElementById(&quot;submit&quot;); //将表单提交按钮设置为不可用，这样就可以避免用户再次点击提交按钮 btnSubmit.disabled= &quot;disabled&quot;; //返回true让表单可以正常提交 return true;&#125; 另外还有一种做法就是提交表单后，将提交按钮隐藏起来，这种做法和将提交按钮设置为不可用是差不多的，个人觉得将提交按钮隐藏影响到页面布局的美观，并且可能会让用户误以为是bug(怎么我一点击按钮，按钮就不见了呢？用户可能会有这样的疑问)，我个人在开发中用得比较多的是表单提交后，将提交按钮设置为不可用，反正使用JavaScript防止表单重复提交的做法都是差不多的，目的都是让表单只能提交一次，这样就可以做到表单不重复提交了。 使用JavaScript防止表单重复提交的做法只对上述提交到导致表单重复提交的三种场景中的【场景一】有效，而对于【场景二】和【场景三】是没有用，依然无法解决表单重复提交问题。 三、利用Session防止表单重复提交 对于【场景二】和【场景三】导致表单重复提交的问题，既然客户端无法解决，那么就在服务器端解决，在服务器端解决就需要用到session了。 具体的做法：在服务器端生成一个唯一的随机标识号，专业术语称为Token(令牌)，同时在当前用户的Session域中保存这个Token。然后将Token发送到客户端的Form表单中，在Form表单中使用隐藏域来存储这个Token，表单提交的时候连同这个Token一起提交到服务器端，然后在服务器端判断客户端提交上来的Token与服务器端生成的Token是否一致，如果不一致，那就是重复提交了，此时服务器端就可以不处理重复提交的表单。如果相同则处理表单提交，处理完后清除当前用户的Session域中存储的标识号。 在下列情况下，服务器程序将拒绝处理用户提交的表单请求：123存储Session域中的Token(令牌)与表单提交的Token(令牌)不同。当前用户的Session中不存在Token(令牌)。用户提交的表单数据中没有Token(令牌)。 1.创建FormServlet，用于生成Token(令牌)和跳转到form.jsp页面123456789101112131415161718public class FormServlet extends HttpServlet &#123; private static final long serialVersionUID = -884689940866074733L; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String token = TokenProccessor.getInstance().makeToken();//创建令牌 System.out.println(&quot;在FormServlet中生成的token：&quot;+token); request.getSession().setAttribute(&quot;token&quot;, token); //在服务器使用session保存token(令牌) request.getRequestDispatcher(&quot;/form.jsp&quot;).forward(request, response);//跳转到form.jsp页面 &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 2.在form.jsp中使用隐藏域来存储Token(令牌)1234567891011121314151617181920&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;form表单&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/DoFormServlet&quot; method=&quot;post&quot;&gt; &lt;%--使用隐藏域存储生成的token--%&gt; &lt;%-- &lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;&lt;%=session.getAttribute(&quot;token&quot;) %&gt;&quot;&gt; --%&gt; &lt;%--使用EL表达式取出存储在session中的token--%&gt; &lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;$&#123;token&#125;&quot;/&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 3.DoFormServlet处理表单提交1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class DoFormServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; boolean b = isRepeatSubmit(request);//判断用户是否是重复提交 if(b==true)&#123; System.out.println(&quot;请不要重复提交&quot;); return; &#125; request.getSession().removeAttribute(&quot;token&quot;);//移除session中的token System.out.println(&quot;处理用户提交请求！！&quot;); &#125; /** * 判断客户端提交上来的令牌和服务器端生成的令牌是否一致 * @param request * @return * true 用户重复提交了表单 * false 用户没有重复提交表单 */ private boolean isRepeatSubmit(HttpServletRequest request) &#123; String client_token = request.getParameter(&quot;token&quot;); //1、如果用户提交的表单数据中没有token，则用户是重复提交了表单 if(client_token==null)&#123; return true; &#125; //取出存储在Session中的token String server_token = (String) request.getSession().getAttribute(&quot;token&quot;); //2、如果当前用户的Session中不存在Token(令牌)，则用户是重复提交了表单 if(server_token==null)&#123; return true; &#125; //3、存储在Session中的Token(令牌)与表单提交的Token(令牌)不同，则用户是重复提交了表单 if(!client_token.equals(server_token))&#123; return true; &#125; return false; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 生成Token的工具类TokenProccessor12345678910111213141516171819202122232425262728293031323334353637383940public class TokenProccessor &#123; /* *单例设计模式（保证类的对象在内存中只有一个） *1、把类的构造函数私有 *2、自己创建一个类的对象 *3、对外提供一个公共的方法，返回类的对象 */ private TokenProccessor()&#123;&#125; private static final TokenProccessor instance = new TokenProccessor(); /** * 返回类的对象 * @return */ public static TokenProccessor getInstance()&#123; return instance; &#125; /** * 生成Token * Token：Nv6RRuGEVvmGjB+jimI/gw== * @return */ public String makeToken()&#123; //checkException // 7346734837483 834u938493493849384 43434384 String token = (System.currentTimeMillis() + new Random().nextInt(999999999)) + &quot;&quot;; //数据指纹 128位长 16个字节 md5 try &#123; MessageDigest md = MessageDigest.getInstance(&quot;md5&quot;); byte md5[] = md.digest(token.getBytes()); //base64编码--任意二进制编码明文字符 adfsdfsdfsf BASE64Encoder encoder = new BASE64Encoder(); return encoder.encode(md5); &#125; catch (NoSuchAlgorithmException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 首先访问FormServlet，在FormServlet中生成Token之后再重定向到form.jsp页面","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://yoursite.com/categories/javaEE/"}],"tags":[{"name":"Session 表单重复提交","slug":"Session-表单重复提交","permalink":"http://yoursite.com/tags/Session-表单重复提交/"}]},{"title":"文件的上传和下载","slug":"一、实现文件上传","date":"2018-07-20T04:10:37.797Z","updated":"2018-07-20T04:10:37.797Z","comments":true,"path":"2018/07/20/一、实现文件上传/","link":"","permalink":"http://yoursite.com/2018/07/20/一、实现文件上传/","excerpt":"","text":"在Web应用系统开发中，文件上传和下载功能是非常常用的功能，今天来讲一下JavaWeb中的文件上传和下载功能的实现。 对于文件上传，浏览器在上传的过程中是将文件以流的形式提交到服务器端的，如果直接使用Servlet获取上传文件的输入流然后再解析里面的请求参数是比较麻烦，所以一般选择采用apache的开源工具common-fileupload这个文件上传组件。这个common-fileupload上传组件的jar包可以去apache官网上面下载，也可以在struts的lib文件夹下面找到，struts上传的功能就是基于这个实现的。common-fileupload是依赖于common-io这个包的，所以还需要下载这个包。 一、实现文件上传1.1、文件上传页面和消息提示页面upload.jsp页面的代码如下：12345678910111213141516171819202122&lt;%-- Created by IntelliJ IDEA. User: qgx Date: 2018/6/5 Time: 10:21 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/UploadHandleServlet&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; 上传用户：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt; 上传文件1：&lt;input type=&quot;file&quot; name=&quot;file1&quot;&gt;&lt;br/&gt; 上传文件2：&lt;input type=&quot;file&quot; name=&quot;file2&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; message.jsp的代码如下：1234567891011121314151617&lt;%-- Created by IntelliJ IDEA. User: qgx Date: 2018/6/5 Time: 10:21 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;消息提示&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;message&#125;&lt;/body&gt;&lt;/html&gt; 1.2、处理文件上传的ServletUploadHandleServlet的代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240package FileUploadAndDownLoad;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.FileUploadBase;import org.apache.commons.fileupload.ProgressListener;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.util.List;import java.util.UUID;@WebServlet(name = &quot;UploadHandleServlet&quot;)public class UploadHandleServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;// String savePath = this.getServletContext().getRealPath(&quot;/WEB-INF/upload&quot;);// File file = new File(savePath);// //判断上传文件的保存目录是否存在// if (!file.exists() &amp;&amp; !file.isDirectory()) &#123;// System.out.println(savePath+&quot;目录不存在，需要创建&quot;);// //创建目录// file.mkdir();// &#125;// //消息提示// String message = &quot;&quot;;// try&#123;// //使用Apache文件上传组件处理文件上传步骤：// //1、创建一个DiskFileItemFactory工厂// DiskFileItemFactory factory = new DiskFileItemFactory();// //2、创建一个文件上传解析器// ServletFileUpload upload = new ServletFileUpload(factory);// //解决上传文件名的中文乱码// upload.setHeaderEncoding(&quot;UTF-8&quot;);// //3、判断提交上来的数据是否是上传表单的数据// if(!ServletFileUpload.isMultipartContent(request))&#123;// //按照传统方式获取数据// return;// &#125;// //4、使用ServletFileUpload解析器解析上传数据，解析结果返回的是一个List&lt;FileItem&gt;集合，每一个FileItem对应一个Form表单的输入项// List&lt;FileItem&gt; list = upload.parseRequest(request);// for(FileItem item : list)&#123;// //如果fileitem中封装的是普通输入项的数据// if(item.isFormField())&#123;// String name = item.getFieldName();// //解决普通输入项的数据的中文乱码问题// String value = item.getString(&quot;UTF-8&quot;);// //value = new String(value.getBytes(&quot;iso8859-1&quot;),&quot;UTF-8&quot;);// System.out.println(name + &quot;=&quot; + value);// &#125;else&#123;//如果fileitem中封装的是上传文件// //得到上传的文件名称，// String filename = item.getName();// System.out.println(filename);// if(filename==null || filename.trim().equals(&quot;&quot;))&#123;// continue;// &#125;// //注意：不同的浏览器提交的文件名是不一样的，有些浏览器提交上来的文件名是带有路径的，如： c:\\a\\b\\1.txt，而有些只是单纯的文件名，如：1.txt// //处理获取到的上传文件的文件名的路径部分，只保留文件名部分// filename = filename.substring(filename.lastIndexOf(&quot;\\\\&quot;)+1);// //获取item中的上传文件的输入流// InputStream in = item.getInputStream();// //创建一个文件输出流// FileOutputStream out = new FileOutputStream(savePath + &quot;\\\\&quot; + filename);// //创建一个缓冲区// byte buffer[] = new byte[1024];// //判断输入流中的数据是否已经读完的标识// int len = 0;// //循环将输入流读入到缓冲区当中，(len=in.read(buffer))&gt;0就表示in里面还有数据// while((len=in.read(buffer))&gt;0)&#123;// //使用FileOutputStream输出流将缓冲区的数据写入到指定的目录(savePath + &quot;\\\\&quot; + filename)当中// out.write(buffer, 0, len);// &#125;// //关闭输入流// in.close();// //关闭输出流// out.close();// //删除处理文件上传时生成的临时文件// item.delete();// message = &quot;文件上传成功！&quot;;// &#125;// &#125;// &#125;catch (Exception e) &#123;// message= &quot;文件上传失败！&quot;;// e.printStackTrace();//// &#125;// request.setAttribute(&quot;message&quot;,message);// request.getRequestDispatcher(&quot;/message.jsp&quot;).forward(request, response); //得到上传文件的保存目录，将上传的文件存放于WEB-INF目录下，不允许外界直接访问，保证上传文件的安全 String savePath = this.getServletContext().getRealPath(&quot;/WEB-INF/upload&quot;); System.out.println(savePath); //上传时生成的临时文件保存目录 String tempPath = this.getServletContext().getRealPath(&quot;/WEB-INF/temp&quot;); File tmpFile = new File(tempPath); if (!tmpFile.exists()) &#123; //创建临时目录 tmpFile.mkdir(); &#125; //消息提示 String message = &quot;&quot;; try &#123; //使用Apache文件上传组件处理文件上传步骤： //1、创建一个DiskFileItemFactory工厂 DiskFileItemFactory factory = new DiskFileItemFactory(); //设置工厂的缓冲区的大小，当上传的文件大小超过缓冲区的大小时，就会生成一个临时文件存放到指定的临时目录当中。 factory.setSizeThreshold(1024 * 100);//设置缓冲区的大小为100KB，如果不指定，那么缓冲区的大小默认是10KB //设置上传时生成的临时文件的保存目录 factory.setRepository(tmpFile); //2、创建一个文件上传解析器 ServletFileUpload upload = new ServletFileUpload(factory); //监听文件上传进度 upload.setProgressListener(new ProgressListener() &#123; public void update(long pBytesRead, long pContentLength, int arg2) &#123; System.out.println(&quot;文件大小为：&quot; + pContentLength + &quot;,当前已处理：&quot; + pBytesRead); /** * 文件大小为：14608,当前已处理：4096 文件大小为：14608,当前已处理：7367 文件大小为：14608,当前已处理：11419 文件大小为：14608,当前已处理：14608 */ &#125; &#125;); //解决上传文件名的中文乱码 upload.setHeaderEncoding(&quot;UTF-8&quot;); //3、判断提交上来的数据是否是上传表单的数据 if (!ServletFileUpload.isMultipartContent(request)) &#123; //按照传统方式获取数据 return; &#125; //设置上传单个文件的大小的最大值，目前是设置为1024*1024字节，也就是1MB upload.setFileSizeMax(1024 * 1024); //设置上传文件总量的最大值，最大值=同时上传的多个文件的大小的最大值的和，目前设置为10MB upload.setSizeMax(1024 * 1024 * 10); //4、使用ServletFileUpload解析器解析上传数据，解析结果返回的是一个List&lt;FileItem&gt;集合，每一个FileItem对应一个Form表单的输入项 List&lt;FileItem&gt; list = upload.parseRequest(request); for (FileItem item : list) &#123; //如果fileitem中封装的是普通输入项的数据 if (item.isFormField()) &#123; String name = item.getFieldName(); //解决普通输入项的数据的中文乱码问题 String value = item.getString(&quot;UTF-8&quot;); //value = new String(value.getBytes(&quot;iso8859-1&quot;),&quot;UTF-8&quot;); System.out.println(name + &quot;=&quot; + value); &#125; else &#123;//如果fileitem中封装的是上传文件 //得到上传的文件名称， String filename = item.getName(); System.out.println(filename); if (filename == null || filename.trim().equals(&quot;&quot;)) &#123; continue; &#125; //注意：不同的浏览器提交的文件名是不一样的，有些浏览器提交上来的文件名是带有路径的，如： c:\\a\\b\\1.txt，而有些只是单纯的文件名，如：1.txt //处理获取到的上传文件的文件名的路径部分，只保留文件名部分 filename = filename.substring(filename.lastIndexOf(&quot;\\\\&quot;) + 1); //得到上传文件的扩展名 String fileExtName = filename.substring(filename.lastIndexOf(&quot;.&quot;) + 1); //如果需要限制上传的文件类型，那么可以通过文件的扩展名来判断上传的文件类型是否合法 System.out.println(&quot;上传的文件的扩展名是：&quot; + fileExtName); //获取item中的上传文件的输入流 InputStream in = item.getInputStream(); //得到文件保存的名称 String saveFilename = makeFileName(filename); //得到文件的保存目录 String realSavePath = makePath(saveFilename, savePath); //创建一个文件输出流 FileOutputStream out = new FileOutputStream(realSavePath + &quot;\\\\&quot; + saveFilename); //创建一个缓冲区 byte buffer[] = new byte[1024]; //判断输入流中的数据是否已经读完的标识 int len = 0; //循环将输入流读入到缓冲区当中，(len=in.read(buffer))&gt;0就表示in里面还有数据 while ((len = in.read(buffer)) &gt; 0) &#123; //使用FileOutputStream输出流将缓冲区的数据写入到指定的目录(savePath + &quot;\\\\&quot; + filename)当中 out.write(buffer, 0, len); &#125; //关闭输入流 in.close(); //关闭输出流 out.close(); //删除处理文件上传时生成的临时文件 item.delete(); message = &quot;文件上传成功！&quot;; &#125; &#125; &#125; catch (FileUploadBase.FileSizeLimitExceededException e) &#123; e.printStackTrace(); request.setAttribute(&quot;message&quot;, &quot;单个文件超出最大值！！！&quot;); request.getRequestDispatcher(&quot;/message.jsp&quot;).forward(request, response); return; &#125; catch (FileUploadBase.SizeLimitExceededException e) &#123; e.printStackTrace(); request.setAttribute(&quot;message&quot;, &quot;上传文件的总的大小超出限制的最大值！！！&quot;); request.getRequestDispatcher(&quot;/message.jsp&quot;).forward(request, response); return; &#125; catch (Exception e) &#123; message = &quot;文件上传失败！&quot;; e.printStackTrace(); &#125; request.setAttribute(&quot;message&quot;, message); request.getRequestDispatcher(&quot;/message.jsp&quot;).forward(request, response); &#125; private String makeFileName(String filename)&#123; //2.jpg //为防止文件覆盖的现象发生，要为上传文件产生一个唯一的文件名 return UUID.randomUUID().toString() + &quot;_&quot; + filename; &#125; private String makePath(String filename,String savePath)&#123; //得到文件名的hashCode的值，得到的就是filename这个字符串对象在内存中的地址 int hashcode = filename.hashCode(); int dir1 = hashcode&amp;0xf; //0--15 int dir2 = (hashcode&amp;0xf0)&gt;&gt;4; //0-15 //构造新的保存目录 String dir = savePath + &quot;\\\\&quot; + dir1 + &quot;\\\\&quot; + dir2; //upload\\2\\3 upload\\3\\5 //File既可以代表文件也可以代表目录 File file = new File(dir); //如果目录不存在 if(!file.exists())&#123; //创建目录 file.mkdirs(); &#125; return dir; &#125;&#125; 1.3、文件上传的细节上述的注释代码虽然可以成功将文件上传到服务器上面的指定目录当中，但是文件上传功能有许多需要注意的小细节问题，以下列出的几点需要特别注意的 1、为保证服务器安全，上传文件应该放在外界无法直接访问的目录下，比如放于WEB-INF目录下。 2、为防止文件覆盖的现象发生，要为上传文件产生一个唯一的文件名。 3、为防止一个目录下面出现太多文件，要使用hash算法打散存储。 4、要限制上传文件的最大值。 5、要限制上传文件的类型，在收到上传文件名时，判断后缀名是否合法。 针对上述提出的5点细节问题，我们来改进一下UploadHandleServlet 二、文件下载2.1、列出提供下载的文件资源我们要将Web应用系统中的文件资源提供给用户进行下载，首先我们要有一个页面列出上传文件目录下的所有文件，当用户点击文件下载超链接时就进行下载操作，编写一个ListFileServlet，用于列出Web应用系统中所有下载文件。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package FileUploadAndDownLoad;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.IOException;import java.util.HashMap;import java.util.Map;@WebServlet(name = &quot;ListFileServlet&quot;)public class ListFileServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取上传文件的目录 String uploadFilePath = this.getServletContext().getRealPath(&quot;/WEB-INF/upload&quot;); //存储要下载的文件名 Map&lt;String,String&gt; fileNameMap = new HashMap&lt;String,String&gt;(); //递归遍历filepath目录下的所有文件和目录，将文件的文件名存储到map集合中 listfile(new File(uploadFilePath),fileNameMap);//File既可以代表一个文件也可以代表一个目录 //将Map集合发送到listfile.jsp页面进行显示 System.out.println(fileNameMap); request.setAttribute(&quot;fileNameMap&quot;,fileNameMap); request.getRequestDispatcher(&quot;/listfile.jsp&quot;).forward(request,response); &#125; /** * 递归遍历指定目录下的所有文件 * @param file 即代表一个文件，也代表一个文件目录 * @param map 存储文件名的Map集合 */ public void listfile(File file,Map&lt;String,String&gt; map)&#123; //如果file代表的不是一个文件，而是一个目录 if(!file.isFile())&#123; //列出该目录下的所有文件和目录 File files[] = file.listFiles(); //遍历files[]数组 for(File f : files)&#123; //递归 listfile(f,map); &#125; &#125;else&#123; /** * 处理文件名，上传后的文件是以uuid_文件名的形式去重新命名的，去除文件名的uuid_部分 file.getName().indexOf(&quot;_&quot;)检索字符串中第一次出现&quot;_&quot;字符的位置，如果文件名类似于：9349249849-88343-8344 那么file.getName().substring(file.getName().indexOf(&quot;_&quot;)+1)处理之后就可以得到文件名部分 */ String realName = file.getName().substring(file.getName().indexOf(&quot;_&quot;)+1); //file.getName()得到的是文件的原始名称，这个名称是唯一的，因此可以作为key，realName是处理过后的名称，有可能会重复 map.put(file.getName(), realName); &#125; &#125;&#125; 展示下载文件的listfile.jsp页面如下：1234567891011121314151617181920212223242526&lt;%-- Created by IntelliJ IDEA. User: qgx Date: 2018/6/5 Time: 22:36 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;下载文件显示页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 遍历Map集合 --&gt; &lt;c:forEach var=&quot;me&quot; items=&quot;$&#123;fileNameMap&#125;&quot;&gt; &lt;c:url value=&quot;/DownLoadServlet&quot; var=&quot;downurl&quot;&gt; &lt;c:param name=&quot;filename&quot; value=&quot;$&#123;me.key&#125;&quot;&gt;&lt;/c:param&gt; &lt;/c:url&gt; $&#123;me.value&#125;&lt;a href=&quot;$&#123;downurl&#125;&quot;&gt;下载&lt;/a&gt; &lt;br/&gt; &lt;/c:forEach&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://yoursite.com/categories/javaEE/"}],"tags":[{"name":"上传和下载","slug":"上传和下载","permalink":"http://yoursite.com/tags/上传和下载/"}]},{"title":"Apache的DBUtils框架学习","slug":"一、commons-dbutils简介","date":"2018-07-20T04:10:37.797Z","updated":"2018-07-20T04:10:37.797Z","comments":true,"path":"2018/07/20/一、commons-dbutils简介/","link":"","permalink":"http://yoursite.com/2018/07/20/一、commons-dbutils简介/","excerpt":"","text":"一、commons-dbutils简介commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。因此dbutils成为很多不喜欢hibernate的公司的首选。 commons-dbutilsAPI介绍： org.apache.commons.dbutils.QueryRunner org.apache.commons.dbutils.ResultSetHandler工具类 org.apache.commons.dbutils.DbUtils 二、QueryRunner类使用讲解该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。QueryRunner类提供了两个构造方法： 默认的构造方法 需要一个 javax.sql.DataSource 来作参数的构造方法。 2.1、QueryRunner类的主要方法12345public Object query(Connection conn, String sql, Object[] params, ResultSetHandler rsh) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。public Object query(String sql, Object[] params, ResultSetHandler rsh) throws SQLException: 几乎与第一种方法一样；唯一的不同在于它不将数据库连接提供给方法，并且它是从提供给构造方法的数据源(DataSource) 或使用的setDataSource 方法中重新获得 Connection。 public Object query(Connection conn, String sql, ResultSetHandler rsh) throws SQLException : 执行一个不需要置换参数的查询操作。 public int update(Connection conn, String sql, Object[] params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。 public int update(Connection conn, String sql) throws SQLException：用来执行一个不需要置换参数的更新操作。 2.2、使用QueryRunner类实现CRUD1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package DaoImpl;import Dao.AdminDao;import model.Admin;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.ResultSetHandler;import org.apache.commons.dbutils.handlers.BeanHandler;import util.DBHelper;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;public class AdminDaoImpl implements AdminDao &#123; private Connection connection; private QueryRunner queryRunner; private PreparedStatement preparedStatement; public AdminDaoImpl() &#123; queryRunner = new QueryRunner(); connection = DBHelper.getConnection(); if (connection != null) &#123; System.out.println(&quot;链接成功&quot;); &#125; &#125; @Override public Admin findByUserName(String username) &#123; String sql = &quot;select * from admin where username = ?&quot;; ResultSetHandler&lt;Admin&gt; rsHandle = new BeanHandler&lt;Admin&gt;(Admin.class); Admin admin = null; try &#123; admin = queryRunner.query(connection, sql, rsHandle, username); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return admin; &#125; @Override public boolean addAdmin(Admin admin) &#123; Connection conn = null; PreparedStatement stmt = null; if (admin != null) &#123; String sql = &quot;insert into admin(username,password)&quot; + &quot;values(?,?)&quot;; try &#123; conn = DBHelper.getConnection(); stmt = conn.prepareStatement(sql); stmt.execute(&quot;set Names utf8&quot;); stmt.setString(1, admin.getUsername()); stmt.setString(2, admin.getPassword()); stmt.executeUpdate(); return true; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return false; &#125; @Override public boolean modifyAdmin(Admin admin) &#123; String sql = &quot;update admin set username=?,password=? where Id =?&quot;; try &#123; preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1, admin.getUsername()); preparedStatement.setString(2, admin.getPassword()); preparedStatement.setString(3, admin.getId()); preparedStatement.executeUpdate(); return true; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return false; &#125;&#125; 三、ResultSetHandler接口使用讲解 该接口用于处理java.sql.ResultSet，将数据按要求转换为另一种形式。 ResultSetHandler接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs) 3.1、ResultSetHandler接口的实现类 ArrayHandler：把结果集中的第一行数据转成对象数组。 ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。 BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。 BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。 ColumnListHandler：将结果集中某一列的数据存放到List中。 KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。 MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。 MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162package javatest;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.*;import org.junit.Test;import util.DBHelper;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.util.Arrays;import java.util.List;import java.util.Map;public class ResultSetHandlerTest &#123; QueryRunner queryRunner = null; Connection connection = DBHelper.getConnection(); public ResultSetHandlerTest() &#123; queryRunner = new QueryRunner(); connection = DBHelper.getConnection(); &#125; /** * 把结果集中的某一行数据转成对象数组。 * * @throws SQLException */ @Test public void testArrayHandler() throws SQLException &#123; String sql = &quot;select * from admin where Id=3&quot;; Object result[] = (Object[]) queryRunner.query(connection, sql, new ArrayHandler()); System.out.println(Arrays.asList(result)); //list toString() &#125; /** * 把结果集中的每一行数据都转成一个数组，再存放到List中。 * * @throws SQLException */ @Test public void testArrayListHandler() throws SQLException &#123; QueryRunner queryRunner = new QueryRunner(); String sql = &quot;select * from admin&quot;; List&lt;Object[]&gt; list = (List) queryRunner.query(connection, sql, new ArrayListHandler()); for (Object[] o : list) &#123; System.out.println(Arrays.asList(o)); &#125; &#125; /** * 将结果集中某一列的数据存放到List中。 * 获取固定列的所有数据 * * @throws SQLException */ @Test public void testColumnListHandler() throws SQLException &#123; QueryRunner queryRunner = new QueryRunner(); String sql = &quot;select * from admin&quot;; List list = (List) queryRunner.query(connection, sql, new ColumnListHandler(&quot;username&quot;)); System.out.println(list); &#125; /** * 将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。 * * @throws SQLException */ @Test public void testKeyedHandler() throws SQLException &#123; QueryRunner queryRunner = new QueryRunner(); String sql = &quot;select * from admin&quot;; Map&lt;Integer, Map&gt; map = (Map) queryRunner.query(connection, sql, new KeyedHandler(&quot;Id&quot;)); System.out.println(map.entrySet()); /* [1=&#123;Id=1, username=1, password=1&#125;, 2=&#123;Id=2, username=秦, password=123&#125;, 3=&#123;Id=3, username=秦光旭, password=1234567&#125;, 4=&#123;Id=4, username=秦光旭, password=123456&#125;] */ System.out.println(map.get(1)); //&#123;Id=1, username=1, password=1&#125; for (Map.Entry&lt;Integer, Map&gt; me : map.entrySet()) &#123; int id = me.getKey(); Map&lt;String, Object&gt; innermap = me.getValue(); for (Map.Entry&lt;String, Object&gt; innerme : innermap.entrySet()) &#123; String columnName = innerme.getKey(); Object value = innerme.getValue(); System.out.println(columnName + &quot;=&quot; + value); &#125; System.out.println(&quot;----------------&quot;); &#125; /*Id=1username=1password=1----------------Id=2username=秦password=123----------------Id=3username=秦光旭password=1234567----------------Id=4username=秦光旭password=123456---------------- */ &#125; /** * 将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。 * * @throws SQLException */ @Test public void testMapHandler() throws SQLException &#123; QueryRunner queryRunner = new QueryRunner(); String sql = &quot;select * from admin&quot;; Map&lt;String, Object&gt; map = queryRunner.query(connection, sql, new MapHandler()); for (Map.Entry&lt;String,Object&gt; me : map.entrySet())&#123; System.out.println(me.getKey() + &quot;=&quot; +me.getValue()); &#125; &#125; /** * 将结果集中的每一行数据都封装到一个Map里，然后再存放到List * @throws SQLException */ @Test public void testMapListHandler() throws SQLException&#123; QueryRunner queryRunner = new QueryRunner(); String sql = &quot;select * from admin&quot;; List&lt;Map&gt; list = (List) queryRunner.query(connection,sql,new MapListHandler()); for (Map&lt;String,Object&gt; map:list) &#123; for (Map.Entry&lt;String,Object&gt; me:map.entrySet()) &#123; System.out.println(me.getKey()+&quot;=&quot;+me.getValue()); &#125; &#125; &#125; /** * * @throws SQLException */ @Test public void testScalarHandler() throws SQLException&#123; QueryRunner queryRunner = new QueryRunner(); String sql = &quot;select count(*) from admin&quot;; long count = queryRunner.query(connection,sql,new ScalarHandler&lt;&gt;(1)); int count1 = Integer.parseInt(String.valueOf(count)); System.out.println(count); System.out.println(count1); &#125;&#125; 四、DbUtils类使用讲解DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下： public static void close(…) throws java.sql.SQLException： DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。 public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。 public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://yoursite.com/categories/javaEE/"}],"tags":[{"name":"Apache的DBUtils","slug":"Apache的DBUtils","permalink":"http://yoursite.com/tags/Apache的DBUtils/"}]},{"title":"javaweb (六 )","slug":"文件下载","date":"2018-07-20T04:10:37.797Z","updated":"2018-07-20T04:10:37.797Z","comments":true,"path":"2018/07/20/文件下载/","link":"","permalink":"http://yoursite.com/2018/07/20/文件下载/","excerpt":"","text":"文件下载文件下载功能是web开发中经常使用到的功能，使用HttpServletResponse对象就可以实现文件的下载文件下载功能的实现思路： 1.获取要下载的文件的绝对路径 2.获取要下载的文件名 3.设置content-disposition响应头控制浏览器以下载的形式打开文件 4.获取要下载的文件输入流 5.创建数据缓冲区 6.通过response对象获取OutputStream流 7.将FileInputStream流写入到buffer缓冲区 8.使用OutputStream将缓冲区的数据输出到客户端浏览器范例：使用Response实现文件下载 123456789101112131415161718192021222324252627282930313233343536package qgx.response.study;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.*;import java.net.URLEncoder;@WebServlet(name = &quot;ResponseDemo2&quot;)public class ResponseDemo2 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; downloadChineseFileByOutputStream(response);//下载中文文件 &#125; private void downloadChineseFileByOutputStream(HttpServletResponse response) throws IOException &#123; String realPath = this.getServletContext().getRealPath(&quot;/download/自由.jpg&quot;);//获取要下载的文件的绝对路径 String fileName = realPath.substring(realPath.lastIndexOf(&quot;\\\\&quot;)+1);//获取要下载的文件名 //设置content-disposition响应头控制浏览器以下载的形式打开文件，中文文件名要使用URLEncoder.encode方法进行编码，否则会出现文件名乱码 response.setHeader(&quot;content-disposition&quot;, &quot;attachment;filename=&quot;+ URLEncoder.encode(fileName, &quot;UTF-8&quot;)); InputStream in = new FileInputStream(realPath);//获取文件输入流 int len = 0; byte[] buffer = new byte[1024]; OutputStream out = response.getOutputStream(); while ((len = in.read(buffer)) &gt; 0) &#123; out.write(buffer,0,len);//将缓冲区的数据输出到客户端浏览器 &#125; in.close(); out.close(); &#125;&#125; 下载中文文件时，需要注意的地方就是中文文件名要使用URLEncoder.encode方法进行编码(URLEncoder.encode(fileName, “字符编码”))，否则会出现文件名乱码。 文件下载注意事项：编写文件下载功能时推荐使用OutputStream流，避免使用PrintWriter流，因为OutputStream流是字节流，可以处理任意类型的数据，而PrintWriter流是字符流，只能处理字符数据，如果用字符流处理字节数据，会导致数据丢失。","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://yoursite.com/categories/javaEE/"}],"tags":[{"name":"HttpServletResponse","slug":"HttpServletResponse","permalink":"http://yoursite.com/tags/HttpServletResponse/"}]},{"title":"java 基础知识","slug":"集合框架二","date":"2018-07-20T04:10:37.797Z","updated":"2018-07-20T04:10:37.797Z","comments":true,"path":"2018/07/20/集合框架二/","link":"","permalink":"http://yoursite.com/2018/07/20/集合框架二/","excerpt":"","text":"集合框架二7、集合类各容器方法：接口Collection方法摘要(没有构造方法)1234567891011121314151617181920a)添加：i. boolean add(E e)j. boolean addAll(Collection c)b)删除：i. void clear():清空容器j. boolean remove(Objec object):k. boolean removeAll(Collection c):c)判断：i. boolean contains(Object object):判断是否包含此元素j. boolean containsAll(Collection c):判断是否包含一堆元素k. boolean equals(Object object):比较此collection与指定对象是否相等m. boolean isEmpty():判断是否集合为空d)获取：h. Iterator iterator():取出i. int hashCode():返回此collection的哈希值j. int size():返回此collection中元素的个数k. boolean retainAll(Collection c):取交集m. Object toArray():返回此collection中所有元素的数组n. T[] toArray(T[] a):返回包含此collection中所有元素的数值。 List集合子类及其方法 (1)List接口是Collection接口的一个子接口。 (2)List接口中的元素有如下特点(对角标的操作都是特有方法，因为有序)：A:元素有序(存储顺序和取出顺序一致)B:元素可以重复 (3)List接口中的特有方法A:add(int index,Object obj):在指定位置加入元素B:remove(int index):移除指定位置的元素C:set(int index,Object obj):修改指定位置的元素D:get(int index):获取指定位置的元素E:indexOf(Object obj):获取指定元素的位置F:subList(int start,int end):从一个大的List中截取一个小的ListG:listIterator():返回一个List接口特有的迭代器 (1)、ArrayList：构造方法摘要：(少用，不是重点)ArrayList()：构造一个初始容量为 10 的空列表。ArrayList(Collection&lt;? extends E&gt; c)： 构造一个包含指定 collection 的元素的列表， ArrayList(int initialCapacity)： 构造一个具有指定初始容量的空列表。 方法摘要：1234567891011121314151617181920212223添加：boolean add(E e)： 将指定的元素添加到此列表的尾部。void add(int index, E element)： 将指定的元素插入此列表中的指定位置。boolean addAll(Collection&lt;? extends E&gt; c):按照指定 collection 的迭代器所返回的元素顺序，将该 collection 中的所有元素添加到此列表的尾部 boolean addAll(int index, Collection&lt;? extends E&gt; c)： 从指定的位置开始，将指定 collection 中的所有元素插入到此列表中。 删除：void clear(): 移除此列表中的所有元素。 remove(int index): 移除此列表中指定位置上的元素。 boolean remove(Object o): 移除此列表中首次出现的指定元素（如果存在）。protected void removeRange(int fromIndex, int toIndex): 移除列表中索引在 fromIndex（包括）和 toIndex（不包括）之间的所有元素。boolean removeAll(Collection&lt;?&gt; c): 从列表中移除指定 collection 中包含的其所有元素 |获取： get(int index): 返回此列表中指定位置上的元素。int indexOf(Object o): 返回此列表中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1。int lastIndexOf(Object o) 返回此列表中最后一次出现的指定元素的索引，或如果此列表不包含索引，则返回 -1。 public List&lt;E&gt; subList(int fromIndex,int toIndex): 返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的部分视图。Iterator&lt;E&gt; iterator(): 返回按适当顺序在列表的元素上进行迭代的迭代器。ListIterator&lt;E&gt; listIterator(int index):返回列表中元素的列表迭代器(按适当顺序),从列表的指定位置开始。修改：(特有方法！！) set(int index, E element): 用指定的元素替代此列表中指定位置上的元素。 (2)LinkedList:构造方法摘要：LinkedList(): 构造一个空列表。LinkedList(Collection&lt;? extends E&gt; c): 构造一个包含指定 collection 中的元素的列表， 这些元素按其 collection 的迭代器返回的顺序排列。方法摘要:(特有的)1234567891011121314151617181920添加void addFirst(E e): 将指定元素插入此列表的开头。 void addLast(E e): 将指定元素添加到此列表的结尾。 获取元素，但不删除元素 get(int index): 返回此列表中指定位置处的元素。 getFirst(): 返回此列表的第一个元素。 getLast(): 返回此列表的最后一个元素。获取元素且删除元素 remove()： 获取并移除此列表的头（第一个元素）。 remove(int index)： 移除此列表中指定位置处的元素。 boolean remove(Object o)： 从此列表中移除首次出现的指定元素（如果存在）。 removeFirst()： 移除并返回此列表的第一个元素。 removeLast(): 移除并返回此列表的最后一个元素。修改 set(int index, E element) 将此列表中指定位置的元素替换为指定的元素。 #### (3)Vector构造方法摘要：Vector(): 构造一个空向量，使其内部数据数组的大小为 10，其标准容量增量为零。 Vector(Collection&lt;? extends E&gt; c): 构造一个包含指定 collection 中的元素的向量， 这些元素按其 collection 的迭代器返回元素的顺序排列。 方法摘要：12345678910111213141516添加：boolean add(E e): 将指定元素添加到此向量的末尾。void add(int index, E element): 在此向量的指定位置插入指定的元素。 boolean addAll(Collection&lt;? extends E&gt; c):将指定 Collection 中的所有元素添加到此向量的末尾， 按照指定 collection 的迭代器所返回的顺序添加这些元素。 boolean addAll(int index, Collection&lt;? extends E&gt; c): 在指定位置将指定 Collection 中的所有元素插入到此向量中。获取:Enumeration&lt;E&gt; elements(): 返回此向量的组件的枚举。 Vector特有的取出方式: 枚举和迭代器很像，其实枚举和迭代器是一样的，只是因为枚举的名称和方法的名称 名字都过长，所以枚举被迭代器取代了。枚举Enumeration的方法摘要：boolean hasMoreElements(): 测试此枚举是否包含更多的元素。 nextElement(): 如果此枚举对象至少还有一个可提供的元素， 则返回此枚举的下一个元素。 Set集合子类及其方法(1)HashSet:它不保证set的迭代顺序;特别是它不保证该顺序恒久不变.此类允许使用null元素。构造方法：HashSet() 构造一个新的空 set，其底层 HashMap 实例的默认初始容量是 16，加载因子是 0.75。HashSet(Collection&lt;? extends E&gt; c) 构造一个包含指定 collection 中的元素的新 set。方法摘要：1234567891011121314151617boolean add(E e) 如果此 set 中尚未包含指定元素，则添加指定元素。 void clear() 从此 set 中移除所有元素。 Object clone() 返回此 HashSet 实例的浅表副本：并没有复制这些元素本身。 boolean contains(Object o) 如果此 set 包含指定元素，则返回 true。 boolean isEmpty() 如果此 set 不包含任何元素，则返回 true。 Iterator&lt;E&gt; iterator() 返回对此 set 中元素进行迭代的迭代器。 boolean remove(Object o) 如果指定元素存在于此 set 中，则将其移除。 int size() 返回此 set 中的元素的数量（set 的容量）。 (2)TreeSet:使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的 Comparator 进行排序.构造方法：TreeSet() 构造一个新的空 set，该set根据其元素的自然顺序进行排序。 TreeSet(Collection&lt;? extends E&gt; c) 构造一个包含指定 collection 元素的新 TreeSet，它按照其元素的自然顺序进行排序。 TreeSet(Comparator&lt;? super E&gt; comparator) 构造一个新的空 TreeSet，它根据指定比较器进行排序。 方法摘要：123456789101112131415161718添加：boolean add(E e) 将指定的元素添加到此 set（如果该元素尚未存在于 set 中）。boolean addAll(Collection&lt;? extends E&gt; c) 将指定 collection 中的所有元素添加到此 set 中。删除： void clear() 移除此 set 中的所有元素。 boolean remove(Object o) 将指定的元素从 set 中移除（如果该元素存在于此 set 中）。 pollFirst() 获取并移除第一个（最低）元素；如果此 set 为空，则返回 null。 pollLast() 获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。 获取： Iterator&lt;E&gt; iterator() 返回在此 set 中的元素上按升序进行迭代的迭代器。 first() 返回此 set 中当前第一个（最低）元素。 last() 返回此 set 中当前最后一个（最高）元素。 int size() 返回 set 中的元素数（set 的容量）。判断：boolean isEmpty() 如果此 set 不包含任何元素，则返回 true。 boolean contains(Object o) 如果此 set 包含指定的元素，则返回 true。 Map:将键映射到值的对象。Map集合没有迭代器！Map集合特点：该集合存储键值对。而且键是唯一的。方法摘要： 添加： V put(K key, V value) 将指定的值与此映射中的指定键关联（可选操作）。 void putAll(Map&lt;? extends K,? extends V&gt; m) 从指定映射中将所有映射关系复制到此映射中 删除： void clear() 从此映射中移除所有映射关系（可选操作）。 V remove(Object key) 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。 判断 boolean containsKey(Object key) 如果此映射包含指定键的映射关系，则返回 true。 boolean containsValue(Object value) 如果此映射将一个或多个键映射到指定值，则返回 true。 boolean isEmpty() 如果此映射未包含键-值映射关系，则返回 true。 获取 int size() 返回此映射中的键-值映射关系数。 Collection values() 返回此映射中包含的值的 Collection 视图。` 重点：Map集合没有迭代器，以下是Map的两种取出方式： 第一种：Set keySet()返回此映射中包含的键的Set视图，将Map集合中所有的键存入Set集合，然后再通过Set集合的迭代器取出所有的键，再根据get方法获取每个键的值； 第二种：Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()返回此映射中包含的映射关系的Set视图，将Map集合中的映射关系存入到Set集合中，这个映射关系的数据类型是Map.entry,再通过Map.Entry类的方法再要取出关系里面的键和值Map.Entry的方法摘要：boolean equals(Object o) 比较指定对象与此项的相等性。 K getKey() 返回与此项对应的键。 V getValue() 返回与此项对应的值。 int hashCode() 返回此映射项的哈希码值。V setValue(V value) 用指定的值替换与此项对应的值(特有！！！)。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"集合框架二","slug":"集合框架二","permalink":"http://yoursite.com/tags/集合框架二/"}]},{"title":"组合模式","slug":"组合模式","date":"2018-07-20T04:10:37.797Z","updated":"2018-07-20T04:10:37.793Z","comments":true,"path":"2018/07/20/组合模式/","link":"","permalink":"http://yoursite.com/2018/07/20/组合模式/","excerpt":"","text":"组合模式组合模式的设计动机：组合模式定义了如何将容器对象和叶子对象进行递归组合，使得客户在使用的过程中无须进行区分，可以对他们进行一致的处理。 定义： 组合模式组合多个对象形成树形结构以表示“整体-部分”的结构层次。 组合模式对单个对象(叶子对象)和组合对象(组合对象)具有一致性，它将对象组织到树结构中，可以用来描述整体与部分的关系。同时它也模糊了简单元素(叶子对象)和复杂元素(容器对象)的概念，使得客户能够像处理简单元素一样来处理复杂元素，从而使客户程序能够与复杂元素的内部结构解耦。 结构： 组合模式主要包含如下几个角色： 1.Component ：组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component子部件。 2.Leaf：叶子对象。叶子结点没有子结点。 3.Composite：容器对象，定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关操作，如增加(add)和删除(remove)等。 从模式结构中我们看出了叶子节点和容器对象都实现Component接口，这也是能够将叶子对象和容器对象一致对待的关键所在。 模式实现： 在文件系统中，可能存在很多种格式的文件，如果图片，文本文件、视频文件等等，这些不同的格式文件的浏览方式都不同，同时对文件夹的浏览就是对文件夹中文件的浏览，但是对于客户而言都是浏览文件，两者之间不存在什么差别，现在只用组合模式来模拟浏览文件 首先是文件类：File.java1234567891011121314151617public abstract class File &#123; String name; public File(String name)&#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public abstract void display();&#125; 然后是文件夹类：Folder.java，该类包含对文件的增加、删除和浏览三个方法1234567891011121314151617181920212223242526272829303132333435public class Folder extends File&#123; private List&lt;File&gt; files; public Folder(String name)&#123; super(name); files = new ArrayList&lt;File&gt;(); &#125; /** * 浏览文件夹中的文件 */ public void display() &#123; for(File file : files)&#123; file.display(); &#125; &#125; /** * @desc 向文件夹中添加文件 * @param file * @return void */ public void add(File file)&#123; files.add(file); &#125; /** * @desc 从文件夹中删除文件 * @param file * @return void */ public void remove(File file)&#123; files.remove(file); &#125;&#125; 然后是三个文件类：TextFile.java、ImageFile.java、VideoFile.javaTextFile.java1234567891011public class TextFile extends File&#123; public TextFile(String name) &#123; super(name); &#125; public void display() &#123; System.out.println(&quot;这是文本文件，文件名：&quot; + super.getName()); &#125; &#125; ImageFile.java1234567891011public class ImagerFile extends File&#123; public ImagerFile(String name) &#123; super(name); &#125; public void display() &#123; System.out.println(&quot;这是图像文件，文件名：&quot; + super.getName()); &#125;&#125; VideoFile.java1234567891011public class VideoFile extends File&#123; public VideoFile(String name) &#123; super(name); &#125; public void display() &#123; System.out.println(&quot;这是影像文件，文件名：&quot; + super.getName()); &#125;&#125; 最后是客户端1234567891011121314151617181920212223242526272829303132333435363738public class Client &#123; public static void main(String[] args) &#123; /** * 我们先建立一个这样的文件系统 * 总文件 * * a.txt b.jpg c文件夹 * c_1.text c_1.rmvb c_1.jpg * */ //总文件夹 Folder zwjj = new Folder(&quot;总文件夹&quot;); //向总文件夹中放入三个文件：1.txt、2.jpg、1文件夹 TextFile aText= new TextFile(&quot;a.txt&quot;); ImagerFile bImager = new ImagerFile(&quot;b.jpg&quot;); Folder cFolder = new Folder(&quot;C文件夹&quot;); zwjj.add(aText); zwjj.add(bImager); zwjj.add(cFolder); //向C文件夹中添加文件：c_1.txt、c_1.rmvb、c_1.jpg TextFile cText = new TextFile(&quot;c_1.txt&quot;); ImagerFile cImage = new ImagerFile(&quot;c_1.jpg&quot;); VideoFile cVideo = new VideoFile(&quot;c_1.rmvb&quot;); cFolder.add(cText); cFolder.add(cImage); cFolder.add(cVideo); //遍历C文件夹 cFolder.display(); //将c_1.txt删除 cFolder.remove(cText); System.out.println(&quot;-----------------------&quot;); cFolder.display(); &#125;&#125; 优点 1、可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，使得增加新构件也更容易。 2、客户端调用简单，客户端可以一致的使用组合结构或其中单个对象。 3、定义了包含叶子对象和容器对象的类层次结构，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，可以形成复杂的树形结构。 4、更容易在组合体内加入对象构件，客户端不必因为加入了新的对象构件而更改原有代码。 缺点设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联 使用场景1，你想表示对象的部分-整体层次结构 2，你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。 模式总结1、 组合模式用于将多个对象组合成树形结构以表示“整体-部分”的结构层次。组合模式对单个对象（叶子对象）和组合对象（容器对象）的使用具有一致性。 2、 组合对象的关键在于它定义了一个抽象构建类，它既可表示叶子对象，也可表示容器对象，客户仅仅需要针对这个抽象构建进行编程，无须知道他是叶子对象还是容器对象，都是一致对待。 3、 组合模式虽然能够非常好地处理层次结构，也使得客户端程序变得简单，但是它也使得设计变得更加抽象，而且也很难对容器中的构件类型进行限制，这会导致在增加新的构件时会产生一些问题。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"Spring Boot(二)","slug":"Spring Boot 常用注解","date":"2018-07-20T04:10:37.797Z","updated":"2018-07-20T04:10:37.797Z","comments":true,"path":"2018/07/20/Spring Boot 常用注解/","link":"","permalink":"http://yoursite.com/2018/07/20/Spring Boot 常用注解/","excerpt":"","text":"Spring Boot 常用注解@RestController和@RequestMapping@RestController被称为一个构造型（stereotype）注解。它为阅读代码的开发人员提供建议。对于Spring，该类扮演了一个特殊角色。它继承自@Controller注解。4.0之前的版本，spring MVC的组件都使用@Controller来标识当前类是一个控制器servlet。 使用这个特性，我们可以开发REST服务的时候不需要使用@Controller而专门的@RestController。 实例：在本实例中，Example的类是一个web @Controller，所以当处理进来的web请求时，Spring会询问它。123456789101112131415import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.stereotype.*;import org.springframework.web.bind.annotation.*;@RestController@EnableAutoConfigurationpublic class Example &#123; @RequestMapping(&quot;/&quot;) String home() &#123; return &quot;Hello World!&quot;; &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(Example.class, args); &#125;&#125; @RequestMapping：注解提供路由信息。它告诉Spring任何来自”/“路径的HTTP请求都应该被映射到home方法。 @RestController注解告诉Spring以字符串的形式渲染结果，并直接返回给调用者。该注解有六个属性： params：指定request中必须包含某些参数值是，才让该方法处理。 headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。 value：指定请求的实际地址，指定的地址可以是URI Template 模式。 method：指定请求的method类型， GET、POST、PUT、DELETE等。 consumes：指定处理请求的提交内容类型（Content-Type），如application/json,text/html。 produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回。实例：12345@RequestMapping(“/test”) @ResponseBody public String test()&#123; return ”ok”; &#125; 注意：@RestController和@RequestMapping注解是Spring MVC注解（它们不是Spring Boot的特定部分） @EnableAutoConfiguration第二个类级别的注解是@EnableAutoConfiguration。这个注解告诉Spring Boot根据添加的jar依赖猜测你想如何配置Spring。由于spring-boot-starter-web添加了Tomcat和Spring MVC，所以auto-configuration将假定正在开发一个web应用并相应地对Spring进行设置。 Starter POMs和Auto-Configuration设计auto-configuration的目的是更好的使用”Starter POMs”，但这两个概念没有直接的联系。可以自由地挑选starter POMs以外的jar依赖，并且Spring Boot将仍旧尽最大努力去自动配置你的应用。 你可以通过将@EnableAutoConfiguration或@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。 注意：只需要添加一个@EnableAutoConfiguration注解。建议将它添加到主@Configuration类上，如果发现应用不想要的特定自动配置类，可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。12345678import org.springframework.boot.autoconfigure.*; import org.springframework.boot.autoconfigure.jdbc.*; import org.springframework.context.annotation.*; @Configuration @EnableAutoConfiguration(exclude=&#123;DataSourceAutoConfiguration.class&#125;) public class MyConfiguration &#123; // ... &#125; @ConfigurationSpring Boot提倡基于Java的配置。尽管可以使用一个XML源来调用SpringApplication.run()，但官方建议使用@Configuration类作为主要源。一般定义main方法的类也是主要@Configuration的一个很好候选。 不需要将所有的@Configuration放进一个单独的类。@Import注解可以用来导入其他配置类。另外也可以使用@ComponentScan注解自动收集所有的Spring组件，包括@Configuration类。 如果需要使用基于XML的配置，官方建议仍旧从一个@Configuration类开始。可以使用附加的@ImportResource注解加载XML配置文件。 @Configuration注解该类，等价与XML中配置beans；用@Bean标注方法等价于XML中配置bean。@ComponentScan(basePackages = “com.yoodb.blog”,includeFilters = {@ComponentScan.Filter(Aspect.class)}) @ComponentScan：表示将该类自动发现扫描组件。如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。 使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。如果没有配置，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。 @SpringBootApplication很多Spring Boot开发者总是使用@Configuration，@EnableAutoConfiguration和@ComponentScan注解他们的main类。由于这些注解被如此频繁地一块使用（特别是你遵循以上最佳实践时），Spring Boot提供一个方便的@SpringBootApplication选择。 该@SpringBootApplication注解等价于以默认属性使用@Configuration，@EnableAutoConfiguration和@ComponentScan。12345678910import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication // 等同于@Configuration @EnableAutoConfiguration @ComponentScan public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; &#125; Spring Boot将尝试校验外部的配置，默认使用JSR-303（如果在classpath路径中）。可以轻松的为@ConfigurationProperties类添加JSR-303 javax.validation约束注解：1234567@Component @ConfigurationProperties(prefix=&quot;connection&quot;) public class ConnectionSettings &#123; @NotNull private InetAddress remoteAddress; // ... getters and setters &#125; @ProfilesSpring Profiles提供了一种隔离应用程序配置的方式，并让这些配置只能在特定的环境下生效。任何@Component或@Configuration都能被@Profile标记，从而限制加载它的时机。12345@Configuration @Profile(&quot;production&quot;) public class ProductionConfiguration &#123; // ... &#125; 全局异常处理@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。12345678910111213141516/** * 全局异常处理 */ @ControllerAdvice public class GlobalDefaultExceptionHandler &#123; public static final String DEFAULT_ERROR_VIEW = &quot;error&quot;; @ExceptionHandler(&#123;TypeMismatchException.class,NumberFormatException.class&#125;) public ModelAndView formatErrorHandler(HttpServletRequest req, Exception e) throws Exception &#123; ModelAndView mav = new ModelAndView(); mav.addObject(&quot;error&quot;,&quot;参数类型错误&quot;); mav.addObject(&quot;exception&quot;, e); mav.addObject(&quot;url&quot;, RequestUtils.getCompleteRequestUrl(req)); mav.addObject(&quot;timestamp&quot;, new Date()); mav.setViewName(DEFAULT_ERROR_VIEW); return mav; &#125;&#125;通过@value注解来读取application.properties里面的配置，使用实例参考： 12345678910//************** application.properties *************//qq_api_key=********1***********qq_api_secrt=******2***********/************* Java **************/@Value(&quot;$&#123;qq_api_key&#125;&quot;) private String API_KEY; @Value(&quot;$&#123;qq_api_secrt&#125;&quot;) private String API_SECRET; 注意：使用@Value注解的时其使用的类如果被其他类作为对象引用，必须要使用注入的方式而不能new，一般常用的配置在application.properties文件。 其他注解@ResponseBody：表示该方法的返回结果直接写入HTTP response body中一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@Responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。如异步获取json数据，加上@Responsebody后，会直接返回json数据。 @Component：泛指组件，当组件不好归类时，可以使用这个注解进行标注。一般公共的方法会用上这个注解。 @RequestParam：用在方法的参数前面，实例：@RequestParam String a =request.getParameter(“a”); @PathVariable:路径变量注解，其参数与大括号里的名字一样要保持一致，实例：1234RequestMapping(&quot;yoodb/detail/&#123;id&#125;&quot;) public String getByMacAddress(@PathVariable String id)&#123; //do something; &#125; @Inject：等价于默认的@Autowired，只是没有required属性。 @Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。 @AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。 @Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：1234@Autowired @Qualifier(value = &quot;demoInfoService&quot;) private DemoInfoService demoInfoService;@Resource(name=&quot;name&quot;,type=&quot;type&quot;)：没有括号内内容的话，默认byName。与@Autowired类似。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"Spring Boot 常用注解","slug":"Spring-Boot-常用注解","permalink":"http://yoursite.com/tags/Spring-Boot-常用注解/"}]},{"title":"Android 编程知识","slug":"XML解析","date":"2018-07-20T04:10:37.793Z","updated":"2018-07-20T04:10:37.793Z","comments":true,"path":"2018/07/20/XML解析/","link":"","permalink":"http://yoursite.com/2018/07/20/XML解析/","excerpt":"","text":"XML解析DOM Document Object Model，文档对象模型。这种方式是W3C推荐的处理XML的一种标准方式。 缺点：必须读取整个XML文档，才能构建DOM模型，如果XML文档过大，造成资源的浪费。 优点：适合对XML中的数据进行操作（CRUD）。利用JAXP进行DOM方式解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//JAXP进行DOM方式解析的基本操作 public class JaxpDemo1 &#123; public static void main(String[] args) throws Exception &#123; //得到解析器 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = factory.newDocumentBuilder(); //通过解析器就可以得到代表整个内存中XML的Document对象 Document document = builder.parse(&quot;src/book.xml&quot;); test8(document); &#125; // 1、得到某个具体的节点内容: private static void test1(Document document)&#123; NodeList nl = document.getElementsByTagName(&quot;作者&quot;); Node authorNode = nl.item(0); System.out.println(authorNode.getTextContent()); &#125; // 2、遍历所有元素节点:打印元素的名称 private static void test2(Node node)&#123; //确定node的类型 //方式一 // if(node.getNodeType()==Node.ELEMENT_NODE)&#123; // //是元素 // &#125; //方式二 if(node instanceof Element)&#123; //是元素 Element e = (Element)node; System.out.println(e.getNodeName());//打印元素名称 &#125; //判断有没有子节点 NodeList nl = node.getChildNodes(); for(int i=0;i&lt;nl.getLength();i++)&#123; Node n = nl.item(i); test2(n); &#125; &#125; // 3、修改某个元素节点的主体内容:&lt;售价&gt;39.00元&lt;/售价&gt;---&gt;10元 private static void test3(Document document) throws Exception&#123; //得到售价 Node priceNode = document.getElementsByTagName(&quot;售价&quot;).item(0); priceNode.setTextContent(&quot;10元&quot;); //更新XML文件 TransformerFactory tf = TransformerFactory.newInstance(); Transformer t = tf.newTransformer(); //构建输入源： Source source = new DOMSource(document); //构建目标： Result result = new StreamResult(&quot;src/book.xml&quot;); t.transform(source, result); &#125; // 4、向指定元素节点中增加子元素节点:第一本书添加子元素 &lt;出版社&gt;黑马程序员&lt;/出版社&gt; private static void test4(Document document) throws Exception&#123; //创建：&lt;出版社&gt;黑马程序员&lt;/出版社&gt; Element e = document.createElement(&quot;出版社&quot;); e.setTextContent(&quot;黑马程序员&quot;); //得到书，把新节点挂上去 Node bookNode = document.getElementsByTagName(&quot;书&quot;).item(0); bookNode.appendChild(e); //更新XML文件 TransformerFactory tf = TransformerFactory.newInstance(); Transformer t = tf.newTransformer(); //构建输入源： Source source = new DOMSource(document); //构建目标： Result result = new StreamResult(&quot;src/book.xml&quot;); t.transform(source, result); &#125; // 5、向指定元素节点上增加同级元素节点:第一本书&lt;售价&gt;前面添加&lt;批发价&gt;30&lt;/批发价&gt; private static void test5(Document document) throws Exception&#123; //创建新节点 Element e = document.createElement(&quot;批发价&quot;); e.setTextContent(&quot;30元&quot;); //找到&lt;售价&gt; Node priceNode = document.getElementsByTagName(&quot;售价&quot;).item(0); //父标签：调用insertBefore(新节点,参考节点); Node bookNode = priceNode.getParentNode(); bookNode.insertBefore(e, priceNode); //更新XML文件 TransformerFactory tf = TransformerFactory.newInstance(); Transformer t = tf.newTransformer(); //构建输入源： Source source = new DOMSource(document); //构建目标： Result result = new StreamResult(&quot;src/book.xml&quot;); t.transform(source, result); &#125; // 6、删除指定元素节点:删除批发价 private static void test6(Document document) throws Exception&#123; Node priceNode = document.getElementsByTagName(&quot;批发价&quot;).item(0); priceNode.getParentNode().removeChild(priceNode); //更新XML文件 TransformerFactory tf = TransformerFactory.newInstance(); Transformer t = tf.newTransformer(); //构建输入源： Source source = new DOMSource(document); //构建目标： Result result = new StreamResult(&quot;src/book.xml&quot;); t.transform(source, result); &#125; // 7、操作XML文件属性:书籍添加一个属性：ISBN=“ABC” private static void test7(Document document) throws Exception&#123; Node bookNode = document.getElementsByTagName(&quot;书&quot;).item(0); if(bookNode instanceof Element)&#123; Element e = (Element)bookNode; e.setAttribute(&quot;ISBN&quot;, &quot;ABC&quot;); &#125; //更新XML文件 TransformerFactory tf = TransformerFactory.newInstance(); Transformer t = tf.newTransformer(); //构建输入源： Source source = new DOMSource(document); //构建目标： Result result = new StreamResult(&quot;src/book.xml&quot;); t.transform(source, result); &#125; // 8、操作XML文件属性:获取ISBN=“ABC” private static void test8(Document document) throws Exception&#123; Node bookNode = document.getElementsByTagName(&quot;书&quot;).item(0); if(bookNode instanceof Element)&#123; Element e = (Element)bookNode; System.out.println(e.getAttribute(&quot;ISBN&quot;)); &#125; &#125; &#125; SAX SAX：Simple API for XML。这种方式不是官方标准，属于开源社区XML-DEV，几乎所有的XML解析器都支持它。 sax解析原理在使用 DOM 解析 XML 文档时，需要读取整个 XML 文档，在内存中构架代表整个 DOM 树的Doucment对象，从而再对XML文档进行操作。此种情况下，如果 XML 文档特别大，就会消耗计算机的大量内存，并且容易导致内存溢出。SAX解析允许在读取文档的时候，即对文档进行处理，而不必等到整个文档装载完才会文档进行操作。SAX采用事件处理的方式解析XML文件，利用 SAX 解析 XML 文档，涉及两个部分： 解析器和事件处理器： 解析器可以使用JAXP的API创建，创建出SAX解析器后，就可以指定解析器去解析某个XML文档。 解析器采用SAX方式在解析某个XML文档时，它只要解析到XML文档的一个组成部分，都会去调用事件处理器的一个方法，解析器在调用事件处理器的方法时，会把当前解析到的xml文件内容作为方法的参数传递给事件处理器。 事件处理器由程序员编写，程序员通过事件处理器中方法的参数，就可以很轻松地得到sax解析器解析到的数据，从而可以决定如何对数据进行处理 基本解析操作12345678//1解析器 SAXParser parse = SAXParserFactory.newInstance().newSAXParser(); //2获取xml读取器 XMLReader reader = parse.getXMLReader(); //3注册内容处理器 reader.setContentHandler(new ContentHandler1()); //4读取xml文档 reader.parse(&quot;src/book.xml&quot;);","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"XML","slug":"XML","permalink":"http://yoursite.com/tags/XML/"}]},{"title":"java 基础题(一)","slug":"面试题一","date":"2018-07-20T04:10:37.793Z","updated":"2018-07-20T04:10:37.793Z","comments":true,"path":"2018/07/20/面试题一/","link":"","permalink":"http://yoursite.com/2018/07/20/面试题一/","excerpt":"","text":"1、一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？ 可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。 2、Java有没有goto? java中的保留字，现在没有在java中使用。 3、说说&amp;和&amp;&amp;的区别。 &amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。 &amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式，例如，对于if(str!= null&amp;&amp; !str.equals(s))表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException如果将&amp;&amp;改为&amp;，则会抛出NullPointerException异常。If(x==33 &amp;++y&gt;0) y会增长，If(x==33 &amp;&amp; ++y&gt;0)不会增长 &amp;还可以用作位运算符，当&amp;操作符两边的表达式不是boolean类型时，&amp;表示按位与操作，我们通常使用0x0f来与一个整数进行&amp;运算，来获取该整数的最低4个bit位，例如，0x31 &amp; 0x0f的结果为0x01。 4、在JAVA中如何跳出当前的多重嵌套循环？ 在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，让外层的循环条件表达式的结果可以受到里层循环体代码的控制，例如，要在二维数组中查找到某个数字。1234567891011int arr[][] =&#123;&#123;1,2,3&#125;,&#123;4,5,6,7&#125;,&#123;9&#125;&#125;;boolean found = false;for(int i=0;i&lt;arr.length&amp;&amp;!found;i++) &#123; for(intj=0;j&lt;arr[i].length;j++)&#123; System.out.println(“i=” + i + “,j=” + j); if(arr[i][j] ==5) &#123; found =true; break; &#125; &#125;&#125; 5、switch语句能否作用在byte上，能否作用在long上，能否作用在String上? 在switch（e）中，e只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。显然，long和String类型都不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它们不能作用于swtich语句中。 switch语句能否作用在String上说错了，Java1.7之后已经支持这种写法了！ 6、short s1= 1; s1 = （s1+1）（（s1+1）是int类型，而等号左边的是short类型，所以需要强转）1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?(没有错) 对于short s1= 1; s1 = s1 + 1;由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。 对于short s1= 1; s1 += 1;由于 +=是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。 7、char型变量中能不能存贮一个中文汉字?为什么? char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。 补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。 8、用最有效率的方法算出2乘以8等於几? 2&lt;&lt; 3，(左移三位)因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算cpu直接支持的，效率最高，所以，2乘以8等於几的最效率的方法是2&lt;&lt; 3。 9、使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？ 使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，对于如下语句：12345678910 finalStringBuffer a=new StringBuffer(&quot;immutable&quot;);执行如下语句将报告编译期错误：a=new StringBuffer(&quot;&quot;);但是，执行如下语句则可以通过编译：a.append(&quot; broken!&quot;);有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象：public void method(final StringBuffer param)&#123;&#125;实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象： param.append(&quot;a&quot;); 10，静态变量和实例变量的区别？ 在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。 在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。 例如，对于下面的程序，无论创建多少个实例对象，永远都只分配了一个staticVar变量，并且每创建一个实例对象，这个staticVar就会加1；但是，每创建一个实例对象，就会分配一个instanceVar，即可能分配多个instanceVar，并且每个instanceVar的值都只自加了1次。123456789public class VariantTest&#123; publicstatic int staticVar = 0; publicint instanceVar = 0; publicVariantTest()&#123; staticVar++; instanceVar++; System.out.println(staticVar +instanceVar); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java题","slug":"java题","permalink":"http://yoursite.com/tags/java题/"}]},{"title":"初识GitLab","slug":"详细讲解Android Studio中使用Git","date":"2018-07-20T04:10:37.793Z","updated":"2018-07-20T04:10:37.793Z","comments":true,"path":"2018/07/20/详细讲解Android Studio中使用Git/","link":"","permalink":"http://yoursite.com/2018/07/20/详细讲解Android Studio中使用Git/","excerpt":"","text":"详细讲解Android Studio中使用Git作者博客链接：https://www.jianshu.com/p/059ed1e01229 前言以前项目版本管理工具一直用的都是SVN，现在换成Git，并且项目托管平台使用的是GitLab。虽然经常用GitHub，但是却很少使用到分支，因为都是自己在写，也不用开发版与发布版、打Tag那些，所以这篇文章主要讲下GitLab与Git的使用。 这篇文章还是会按我以前的写作风格，写的通俗易懂，并且全程自己操作一遍，目的是为了初学者也能看懂。 简介Git：Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。简单说，它就是一个管理项目版本的工具。 GitLab：GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务。简单说，GitLab的性质是和GitHub一样的，都是用来存储项目的仓库。 准备 Git3.1 安装Git 下载地址：http://git-scm.com/download/ 安装步骤：双击安装，按默认选项一路下去即可。安装完成后，在开始菜单里找到“Git”–&gt;“Git Bash”，出现如下图，就说明Git安装成功！ 3.2 配置信息 在上图命令行中输入你的用户名与邮箱12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 命令中的 –global 参数表示你这台机器上所有的Git仓库都会使用这个配置。 3.3 Android Studio中配置Git 在Android Studio中点击Settings–&gt;Version Control –&gt; Git，然后在Path To Git executable上输入你刚刚安装Git的位置，最后点击Test按钮出现Git executed successfully说明配置成功，如下图： GitLab 使用4.1 注册账号 这里说下注册账号的时候需要注意的事项。如果注册账号的时候提示如下错误1there was an error with the reCAPTCHA,please solve the reCAPTCHA again 那是因为注册时需要验证码验证，就是reCAPTCHA，是一个图形验证码。但是这个验证码需要FQ才能看得到，否则你一直都注册不了。如图：4.2 GitLab账户配置SSH Keys 4.2.1 首先需要检查你电脑是否已经有 SSH Keys 在Git Bash 客户端，输入如下代码：12$ cd ~/.ssh$ ls 如下说明已经存在，存在就可以忽略步骤4.2.2，直接进入步骤4.2.3 4.2.2 创建一个 SSH Keys 在Git Bash 客户端，输入如下代码：1$ ssh-keygen -t rsa -C &quot;your_email&quot; 然后根据提示进行相应操作，如下图所示： 第一个Enter表示Keys存储的位置，默认按回车键即可。第二个和第三个Enter表示Push文件的时候要输入的密码，不需要密码就默认按回车键即可，然后出现如图底部信息就说明创建成功了！ 4.2.3 GitLab配置SSH Keys 进入上图所示存储 id_rsa.pub 的文件夹拷贝该文件中的内容，然后登录你的GitLab账号，点击网页右上角的头像–&gt;Settings，点击左边菜单栏的 SSH Keys 进入页面添加 SSH key。如下操作： 4.3 创建项目 在GitLab网站点击导航条上的 “+” 即可进入创建项目的页面，然后根据提示填写相应信息，如下图： Project path：项目路径Project name：项目名称Project description (optional)：项目描述（可选项）Visibility Level：可见登记，Private表示私有的，只有你自己或者组内的成员能访问，Internal表示所有登录的用户，Public表示公开的，所有人都可以访问。 创建完成后是这样的： Android Studio中使用Git5.1 将项目上传到GitLab 本地已创建好的项目为WildmaGit 5.1.1 配置忽略文件 Android Studio创建项目后会自动生成.gitignore文件，这个文件可以用来忽略那些不用加入到仓库的文件。项目根目录下与module目录下都会生成该文件，如下：一般情况下我们只需要将项目根目录下的/.idea/workspace.xml与/.idea/libraries改成.idea即可，其他没有特殊要求就用默认的。如下： 修改前：修改后：5.1.2 初始化本地Git仓库 点击Android Studio顶部菜单栏上的VCS–&gt;Import into Version Control–&gt;Create Git Repository，如图：然后选择需要初始化的项目根目录，如图：初始化之后发现文件名由原来的白色变成了红色，这表示文件已经被git跟踪了，但是并没有添加到仓库中。如图：5.1.3 将本地Git仓库已与远程仓库进行关联 打开项目文件夹，在该文件夹中打开Git Bash。输入如下命令后就代表本地Git仓库已与远程仓库进行关联了。1git remote add origin git@gitlab.com:wildma/WildmaGit.git 具体步骤见下图：其中 git@gitlab.com:wildma/WildmaGit.git 为我们项目的远程地址，可以到我们前面创建项目中复制，如下： 5.1.4 添加文件 选中项目的根目录，点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Add…，如下图：添加文件后发现文件名由原来的红色变成了绿色，说明已经将文件添加进仓库了。如下图：5.1.5 提交文件 每次提交前需要先更新项目，原因是如果是多人合作的项目，需要先将远程仓库中他人提交的最新代码更新到本地仓库。如图：然后选中Merge，点击OK，如果本地代码与远程代码有冲突就会弹出冲突提示，根据需求Merge即可，如图： Update后就可以提交文件了，选中项目的根目录，点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Commit Directory…，如图： 然后会弹出如下提交框，这里可以选择你要提交的文件和填写提交信息，如图：提交文件后发现文件名由原来的绿色又变成了最开始的白色，说明已经将文件提交上仓库了。如图： 5.1.6 将提交的文件推送到远程仓库 选中项目的根目录，点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Push…，如下图：然后会弹出如下推送框点击Push后，就可以在GitLab上看到刚刚推送的内容了。如下图： 5.2 从GitLab上clone项目 首先到GitLab上复制项目的地址，如图：然后点击Android Studio顶部菜单栏上的VCS–&gt;Checkout from Version Control–&gt;Git ，如图：最后填写相应的信息即可，如下图： Git Repository URL：填写刚刚复制的项目地址Parent Directory：项目路径Directory Name：项目文件夹名称点击clone后，项目就clone下来了！5.3 分支管理 5.3.1 分支策略 在实际开发中，我们会用到很多分支。这里说下各分支的作用。 master分支：最稳定的分支，保存需要发布的版本，不在该分支上做任何开发。dev分支：开发分支，保存最新的代码，平时开发就在该分支上。当某个版本开发完成后就合并到master分支，然后在master分支进行版本发布。bug分支：用来修复bug的分支，一般是线上版出现bug的时候，从master分支创建一个新的bug分支进行bug修复，修复完成合并到master分支和dev分支（保证master分支与dev分支同步），然后删除该bug分支。 实际开发中我主要用到这三个分支，当然每个人都不同，有些人还会细分到功能分支，预发分支。其中master分支与dev分支都需要推送到远程，为了其他成员能共同开发，bug分支则放在本地即可，你自己修复完bug删掉即可。 5.3.2 分支操作 1. 创建分支 点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Branches…，如图：然后选择New Branch，输入分支的名字，例如“dev”，如图：点击OK，分支dev就创建成功了，并且默认切换到该分支。重复上面的步骤可以看到当前分支显示的是dev，如图： 2. 推送分支到远程 这时候我们在dev分支上修改内容，然后按照前面说的提交文件（步骤5.1.5），将提交的文件推送到远程仓库（步骤5.1.6）即可。如图：点击push，然后就可以到Gitlab上看到我们刚刚推送的dev分支了，如图：3. 切换分支 dev分支上版本V1.0开发完了，需要将代码合并到master上进行发布。因为当前在dev分支，所以需要先切换到master分支，点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Branches…，打开Git Branches窗口，然后选择本地分支栏下的master-&gt;origin/master，然后点击Checkout。如图：4. 合并分支 第三步已经将分支切换到master了，现在进行分支合并。点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Branches…，打开Git Branches窗口，然后选择远程分支栏下的origin/dev，然后点击Merge。如图：这个时候到GitLab上却发现master分支上并没有合并到dev分支修改的内容，那是因为刚刚只是将远程dev分支的内容合并到本地master分支，本地master分支还没有push到远程，push一下就可以啦~ 如图：这个时候发现GitLab上master分支与dev分支是保持一致的了。然后将最新的master分支打包发布即可！ 5. 删除分支 删除本地分支： 点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Branches…，打开Git Branches窗口，选中本地dev分支，选择Delete即可。如图：删除远程分支： 点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Branches…，打开Git Branches窗口，选中远程dev分支，选择Delete即可。如图：5.4 标签(Tag)管理 标签一般是用于标记某个发布的版本， 例如你发布了版本v1.0，这个时候会打一个v1.0的Tag，主要是方便以后查看和管理某个版本的代码。 1. 创建标签 点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Tag…，如图：然后填写Tag名称与Tag信息，点击Create Tag即可创建本地标签。其中Commit可填写以前某次提交记录的id，表示在该次提交上打Tag。如果不填表示Tag打在最新提交的commit上。如图：2. 推送标签到远程 点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Push…，如图：然后弹出Push框，选中Push Tags，点击Push即可推送到远程。如图：最后到GitLab就可以看到刚刚创建的Tag了，如图：3. checkout某个标签的代码 点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Branches…，如图：然后选择Checkout Tag or Revision…，最后在弹出的Checkout框中填入Tag的名称即可。如图： 4. 删除标签 在Android Studio中没找到删除Tag的操作，所以这里用Git命令。（有发现的小伙伴可以告诉我） 查看本地标签：git tag 删除本地标签：git tag -d tagName 删除远程标签：git push origin :refs/tags/tagName 以上命令需要在Android Studio自带的命令行中输入，如图：希望这种图文结合的方式大家都能看懂吧！写的不好的地方请多交流~ 项目地址：https://gitlab.com/wildma/WildmaGit","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"初识GitLab","slug":"初识GitLab","permalink":"http://yoursite.com/tags/初识GitLab/"}]},{"title":"单片机","slug":"单片机","date":"2018-07-20T04:10:37.793Z","updated":"2018-07-20T04:10:37.793Z","comments":true,"path":"2018/07/20/单片机/","link":"","permalink":"http://yoursite.com/2018/07/20/单片机/","excerpt":"","text":"单片机4、89C51共有哪些中断源？对其中端请求如何进行控制？答：（1）89C51有如下中断源①:外部中断0请求，低电平有效②:外部中断1请求，低电平有效③T0：定时器、计数器0溢出中断请求④T1：定时器、计数器1溢出中断请求⑤TX/RX：串行接口中断请求（2）通过对特殊功能寄存器TCON、SCON、IE、IP的各位进行置位或复位等操作，可实现各种中断控制功能 5、什么是中断优先级？中断优先处理的原则是什么？答：中断优先级是CPU相应中断的先后顺序。原则：（1） 先响应优先级高的中断请求，再响应优先级低的（2） 如果一个中断请求已经被响应，同级的其它中断请求将被禁止（3） 如果同级的多个请求同时出现，则CPU通过内部硬件查询电路，按查询顺序确定应该响应哪个中断请求查询顺序：外部中断0→定时器0中断→外部中断1→定时器1中断→串行接口中断 11、当正在执行某一个中断源的中断服务程序时，如果有新的中断请求出现，试问在什么情况下可响应新的中断请求？在什么情况下不能响应新的中断请求？答：（1）符合以下6个条件可响应新的中断请求：a) 有中断源发出中断请求b) 中断允许位EA=1，即CPU开中断c) 申请中断的中断源的中断允许位为1，即中断没有被屏蔽d) 无同级或更高级中断正在被服务e) 当前的指令周期已结束f) 若现行指令为RETI或访问IE或IP指令时，该指令以及紧接着的另一条指令已被执行完 14、89C51各中断源的中断标志是如何产生的？又是如何清0的？CPU响应中断时，中断入口地址各是多少？答：各中断标志的产生和清“0”如下：（1） 外部中断类外部中断是由外部原因引起的，可以通过两个固定引脚，即外部中断0和外部中断1输入信号。外部中断0请求信号，由P3.2脚输入。通过IT0来决定中断请求信号是低电平有效还是下跳变有效。一旦输入信号有效，则向CPU申请中断，并且使IE0=1。硬件复位。外部中断1请求信号，功能与用法类似外部中断0（2） 定时中断类定时中断是为满足定时或计数溢出处理需要而设置的。当定时器/计数器中的计数结构发生计数溢出的，即表明定时时间到或计数值已满，这时就以计数溢出信号作为中断请求，去置位一个溢出标志位。这种中断请求是在单片机芯片内部发生的，无需在芯片上设置引入端，但在计数方式时，中断源可以由外部引入。TF0：定时器T0溢出中断请求。当定时器T0产生溢出时，定时器T0请求标志TF0=1，请求中断处理。使用中断时由硬件复位，在查询方式下可由软件复位。TF1：定时器T1溢出中断请求。功能与用法类似定时器T0（3） 串行口中断类串行口中断是为串行数据的传送需要而设置的。串行中断请求也是在单片机芯片内部发生的，但当串行口作为接收端时，必须有一完整的串行帧数据从RI端引入芯片，才可能引发中断。RI或TI：串行口中断请求。当接收或发送一串帧数据时，使内部串行口中断请求标志RI或TI=1，并请求中断。响应后必须软件复位。 CPU响应中断时，中断入口地址如下： 中断源 入口地址外部中断0 0003H定时器T0中断000BH外部中断1 0013H定时器T1中断001BH串行口中断 0023H 答案： 1）首先判断有无键按下： (3分) 将列线全部置0，读行线状态，若P1.0~P1.3全为1，则表明无键按下，若出现低电平即0，则有键按下，记录下行号 i ; 2) 其次，如有键按下，判断具体键号 (7分) 方法如下：逐列为低，其它为高，再读行线状态，如出现哪一行为低，记录此时的列号j ， 则证明第i行第j列的按键被按下，至此完成键盘的行列式扫描。","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"http://yoursite.com/categories/杂七杂八/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"http://yoursite.com/tags/单片机/"}]},{"title":"JAVA线程池原理详解","slug":"JAVA线程池原理详解","date":"2018-07-20T04:10:37.793Z","updated":"2018-07-20T04:10:37.793Z","comments":true,"path":"2018/07/20/JAVA线程池原理详解/","link":"","permalink":"http://yoursite.com/2018/07/20/JAVA线程池原理详解/","excerpt":"","text":"JAVA线程池原理详解线程池的优点121、线程是稀缺资源，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以重复使用。2、可以根据系统的承受能力，调整线程池中工作线程的数量，防止因为消耗过多内存导致服务器崩溃。 线程池的创建12345678910111213public ThreadPoolExecutor( int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)corePoolSize：线程池核心线程数量maximumPoolSize:线程池最大线程数量keepAliverTime：当活跃线程数大于核心线程数时，空闲的多余线程最大存活时间unit：存活时间的单位workQueue：存放任务的队列handler：超出线程范围和队列容量的任务的处理程序 线程池的实现原理提交一个任务到线程池中，线程池的处理流程如下： 1、判断线程池里的核心线程是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。 2、线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。 3、判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。 线程池的源码解读1、ThreadPoolExecutor的execute()方法12345678910111213141516public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); //如果线程数大于等于基本线程数或者线程创建失败，将任务加入队列 if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123; //线程池处于运行状态并且加入队列成功 if (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123; if (runState != RUNNING || poolSize == 0) ensureQueuedTaskHandled(command); &#125; //线程池不处于运行状态或者加入队列失败，则创建线程（创建的是非核心线程） else if (!addIfUnderMaximumPoolSize(command)) //创建线程失败，则采取阻塞处理的方式 reject(command); // is shutdown or saturated &#125; &#125; 2、创建线程的方法：addIfUnderCorePoolSize(command)123456789101112131415private boolean addIfUnderCorePoolSize(Runnable firstTask) &#123; Thread t = null; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; if (poolSize &lt; corePoolSize &amp;&amp; runState == RUNNING) t = addThread(firstTask); &#125; finally &#123; mainLock.unlock(); &#125; if (t == null) return false; t.start(); return true;&#125; 我们重点来看第7行：123456789101112private Thread addThread(Runnable firstTask) &#123; Worker w = new Worker(firstTask); Thread t = threadFactory.newThread(w); if (t != null) &#123; w.thread = t; workers.add(w); int nt = ++poolSize; if (nt &gt; largestPoolSize) largestPoolSize = nt; &#125; return t;&#125; 这里将线程封装成工作线程worker，并放入工作线程组里，worker类的方法run方法：123456789101112public void run() &#123; try &#123; Runnable task = firstTask; firstTask = null; while (task != null || (task = getTask()) != null) &#123; runTask(task); task = null; &#125; &#125; finally &#123; workerDone(this); &#125;&#125; worker在执行完任务后，还会通过getTask方法循环获取工作队里里的任务来执行。我们通过一个程序来观察线程池的工作原理：1、创建一个线程123456789101112131415public class ThreadPoolTest implements Runnable&#123; @Override public void run() &#123; try &#123; Thread.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2、线程池循环运行16个线程：1234567891011121314151617public static void main(String[] args) &#123; LinkedBlockingQueue&lt;Runnable&gt; queue = new LinkedBlockingQueue&lt;Runnable&gt;(5); ThreadPoolExecutor threadPool = new ThreadPoolExecutor(5, 10, 60, TimeUnit.SECONDS, queue); for (int i = 0; i &lt; 16 ; i++) &#123; threadPool.execute( new Thread(new ThreadPoolTest(), &quot;Thread&quot;.concat(i + &quot;&quot;))); System.out.println(&quot;线程池中活跃的线程数： &quot; + threadPool.getPoolSize()); if (queue.size() &gt; 0) &#123; System.out.println(&quot;----------------队列中阻塞的线程数&quot; + queue.size()); &#125; &#125; threadPool.shutdown(); &#125; 执行结果：123456789101112131415161718192021222324252627282930线程池中活跃的线程数： 1线程池中活跃的线程数： 2线程池中活跃的线程数： 3线程池中活跃的线程数： 4线程池中活跃的线程数： 5线程池中活跃的线程数： 5----------------队列中阻塞的线程数1线程池中活跃的线程数： 5----------------队列中阻塞的线程数2线程池中活跃的线程数： 5----------------队列中阻塞的线程数3线程池中活跃的线程数： 5----------------队列中阻塞的线程数4线程池中活跃的线程数： 5----------------队列中阻塞的线程数5线程池中活跃的线程数： 6----------------队列中阻塞的线程数5线程池中活跃的线程数： 7----------------队列中阻塞的线程数5线程池中活跃的线程数： 8----------------队列中阻塞的线程数5线程池中活跃的线程数： 9----------------队列中阻塞的线程数5线程池中活跃的线程数： 10----------------队列中阻塞的线程数5Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task Thread[Thread15,5,main] rejected from java.util.concurrent.ThreadPoolExecutor@232204a1[Running, pool size = 10, active threads = 10, queued tasks = 5, completed tasks = 0] at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047) at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823) at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369) at test.ThreadTest.main(ThreadTest.java:17) 从结果可以观察出：创建的线程池具体配置为：核心线程数量为5个；全部线程数量为10个；工作队列的长度为5。我们通过queue.size()的方法来获取工作队列中的任务数。运行原理： 刚开始都是在创建新的线程，达到核心线程数量5个后，新的任务进来后不再创建新的线程，而是将任务加入工作队列，任务队列到达上线5个后，新的任务又会创建新的普通线程，直到达到线程池最大的线程数量10个，后面的任务则根据配置的饱和策略来处理。我们这里没有具体配置，使用的是默认的配置AbortPolicy:直接抛出异常。 当然，为了达到我需要的效果，上述线程处理的任务都是利用休眠导致线程没有释放！！ RejectedExecutionHandler：饱和策略当队列和线程池都满了，说明线程池处于饱和状态，那么必须对新提交的任务采用一种特殊的策略来进行处理。这个策略默认配置是AbortPolicy，表示无法处理新的任务而抛出异常。JAVA提供了4中策略： AbortPolicy：直接抛出异常 CallerRunsPolicy：只用调用所在的线程运行任务 DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。 DiscardPolicy：不处理，丢弃掉。 我们现在用第四种策略来处理上面的程序：12345678910111213141516171819202122232425262728293031323334353637public static void main(String[] args) &#123; LinkedBlockingQueue&lt;Runnable&gt; queue = new LinkedBlockingQueue&lt;Runnable&gt;(3); RejectedExecutionHandler handler = new ThreadPoolExecutor.DiscardPolicy(); ThreadPoolExecutor threadPool = new ThreadPoolExecutor(2, 5, 60, TimeUnit.SECONDS, queue,handler); for (int i = 0; i &lt; 9 ; i++) &#123; threadPool.execute( new Thread(new ThreadPoolTest(), &quot;Thread&quot;.concat(i + &quot;&quot;))); System.out.println(&quot;线程池中活跃的线程数： &quot; + threadPool.getPoolSize()); if (queue.size() &gt; 0) &#123; System.out.println(&quot;----------------队列中阻塞的线程数&quot; + queue.size()); &#125; &#125; threadPool.shutdown(); &#125;执行结果线程池中活跃的线程数： 1线程池中活跃的线程数： 2线程池中活跃的线程数： 2----------------队列中阻塞的线程数1线程池中活跃的线程数： 2----------------队列中阻塞的线程数2线程池中活跃的线程数： 2----------------队列中阻塞的线程数3线程池中活跃的线程数： 3----------------队列中阻塞的线程数3线程池中活跃的线程数： 4----------------队列中阻塞的线程数3线程池中活跃的线程数： 5----------------队列中阻塞的线程数3线程池中活跃的线程数： 5----------------队列中阻塞的线程数3 这里采用了丢弃策略后，就没有再抛出异常，而是直接丢弃。在某些重要的场景下，可以采用记录日志或者存储到数据库中，而不应该直接丢弃。设置策略有两种方式： 第一种：RejectedExecutionHandler handler = new ThreadPoolExecutor.DiscardPolicy();ThreadPoolExecutor threadPool = new ThreadPoolExecutor(2, 5, 60, TimeUnit.SECONDS, queue,handler); 第二种：ThreadPoolExecutor threadPool = new ThreadPoolExecutor(2, 5, 60, TimeUnit.SECONDS, queue);threadPool.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://yoursite.com/categories/javaEE/"}],"tags":[{"name":"JAVA线程池原理详解","slug":"JAVA线程池原理详解","permalink":"http://yoursite.com/tags/JAVA线程池原理详解/"}]},{"title":"我的第一个原型设计——模仿知乎的注册界面","slug":"我的第一个原型设计——模仿知乎的注册界面","date":"2018-07-20T04:10:37.793Z","updated":"2018-07-20T04:10:37.793Z","comments":true,"path":"2018/07/20/我的第一个原型设计——模仿知乎的注册界面/","link":"","permalink":"http://yoursite.com/2018/07/20/我的第一个原型设计——模仿知乎的注册界面/","excerpt":"","text":"我的第一个原型设计——模仿知乎的注册界面一.模仿什么？模仿一个网站，从两个方面来看。首先是用元件所呈现的这个界面最直观的部分，然后就是交互部分。 1.元件布局首先我们来看一下知乎注册界面： 从这个布局，我们很容易分析出来它的各个元件，如下： 2.交互效果从上往下看 （1）logo和标语，没有什么交互效果，只需要填充相应的数据就可以了。 （2）注册矩形框，和下面的条条一样是蓝色的。 （3）登录矩形框 鼠标悬浮的时候，颜色会变浅 点击登陆后，登录的字体的颜色会变蓝色 注册的字体颜色会变成灰色 下面的蓝色小条条会移动到登录矩形框的下面 界面也会变成登陆的时的界面。 （4）输入，包括姓名、手机号和密码对于页面载入时，鼠标的光标的焦点在姓名输入框；如果三个文本框都没有输入文字，点击注册按钮，这时在姓名文本框后面就会出现一个提示“姓名不能为空”，并且这个文字会抖动一下。同样姓名填了，手机号没有填，右侧就会提醒手机号不能为空，文字也会抖几下，密码同上。当出现提示文字的时候，如果把鼠标的焦点移到该输入文本框时候，提示文字就会从右侧逐渐消退。 （5）提示中的知乎协议和下载知乎APP,点击就会进入另外的界面。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Axure","slug":"Axure","permalink":"http://yoursite.com/tags/Axure/"}]},{"title":"javaweb (一)","slug":"Servlet 简介","date":"2018-07-20T04:10:37.793Z","updated":"2018-07-20T04:10:37.793Z","comments":true,"path":"2018/07/20/Servlet 简介/","link":"","permalink":"http://yoursite.com/2018/07/20/Servlet 简介/","excerpt":"","text":"Servlet 简介 Servlet是sun公司提供的一门用于开发动态web资源的技术。 Sun公司在其API中提供了一个servlet接口，用户若想用发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤： 1、编写一个Java类，实现servlet接口。 2、把开发好的Java类部署到web服务器中。 按照一种约定俗成的称呼习惯，通常我们也把实现了servlet接口的java程序，称之为Servlet。 Servlet 的运行过程Servlet 程序是由WEB服务器收到客户端的Servlet访问请求后 web服务器首先检查是否已经装载并创建了该Servlet的实例对象，如果是，则执行第4步，否则，执行第2步。 2.装载并创建该Servlet 的一个实例对象 3.调用Servlet实例对象的init()方法。 4.创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。 web应用程序被停止或重新启动之前，Servlet 引擎将卸载Servlet，并在卸载之前调用Servlet的destory()方法。在IDEA中开发Servlet在IDEA中新建一个Web project工程。 Servlet接口SUN公司定义了两个默认实现类，分别为：GenericServlet、HttpServlet。 HttpServlet指能够处理HTTP请求的servlet，它在原有Servlet接口上添加了一些与HTTP协议处理方法，它比Servlet接口的功能更为强大。因此开发人员在编写Servlet时，通常应继承这个类，而避免直接去实现Servlet接口。HttpServlet在实现Servlet接口时，覆写了service方法，该方法体内的代码会自动判断用户的请求方式，如为GET请求，则调用HttpServlet的doGet方法，如为Post请求，则调用doPost方法。因此，开发人员在编写Servlet时，通常只需要覆写doGet或doPost方法，而不要去覆写service方法。ServletDemo1123456789101112131415161718192021222324252627282930import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(name = &quot;ServletDemo1&quot;)public class ServletDemo1 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;!DOCTYPE HTML PUBLIC \\&quot;-//W3C//DTD HTML 4.01 Transitional//EN\\&quot;&gt;&quot;); out.println(&quot;&lt;HTML&gt;&quot;); out.println(&quot; &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;/TITLE&gt;&lt;/HEAD&gt;&quot;); out.println(&quot; &lt;BODY&gt;&quot;); out.print(&quot; This is &quot;); out.print(this.getClass()); out.println(&quot;, using the GET method&quot;); out.println(&quot; &lt;/BODY&gt;&quot;); out.println(&quot;&lt;/HTML&gt;&quot;); out.flush(); out.close(); &#125;&#125; 配置web.xml1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/s&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 然后我们就可以通过浏览器访问ServletDemo1这个Servlet，如下图所示： Servlet开发注意细节Servlet 访问URL映射配置由于客户端是通过URL地址访问web服务器中的资源，所以Servlet程序若想被外界访问，必须把servlet程序映射到一个URL地址上，这个工作在web.xml文件中使用元素和元素完成。 元素用于注册Servlet，它包含有两个主要的子元素：和，分别用于设置Servlet的注册名称和Servlet的完整类名。一个元素用于映射一个已注册的Servlet的一个对外访问路径，它包含有两个子元素：和，分别用于指定Servlet的注册名称和Servlet的对外访问路径。例如：12345678 &lt;servlet&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;ServletDemo1&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/s&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 同一个Servlet可以被映射到多个URL上，即多个元素的子元素的设置值可以是同一个Servlet的注册名。 例如：1234567891011121314151617181920212223&lt;servlet&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;ServletDemo1&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/s&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/s1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/s.htm&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/s.jsp&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 通过上面的配置，当我们想访问名称是ServletDemo1的Servlet，可以使用如下的几个地址去访问：1234http://localhost:8080/shttp://localhost:8080/s1http://localhost:8080/s.jsphttp://localhost:8080/s.htm ServletDemo1被映射到了多个URL上。 Servlet访问URL使用*通配符映射 在Servlet映射到的URL中也可以使用*通配符，但是只能有两种固定的格式：一种格式是”*.扩展名”，另一种格式是以正斜杠（/）开头并以”/*”结尾。例如：123456789&lt;servlet&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 可以匹配任意的字符，所以此时可以用任意的URL去访问ServletDemo1这个Servlet，如下图所示：对于如下的一些映射关系： Servlet1 映射到 /abc/ Servlet2 映射到 / Servlet3 映射到 /abc Servlet4 映射到 .do问题： 当请求URL为“/abc/a.html”，“/abc/”和“/”都匹配，哪个servlet响应 Servlet引擎将调用Servlet1。 当请求URL为“/abc”时，“/abc/”和“/abc”都匹配，哪个servlet响应 Servlet引擎将调用Servlet3。 当请求URL为“/abc/a.do”时，“/abc/”和“.do”都匹配，哪个servlet响应 Servlet引擎将调用Servlet1。 当请求URL为“/a.do”时，“/”和“.do”都匹配，哪个servlet响应 Servlet引擎将调用Servlet2。 当请求URL为“/xxx/yyy/a.do”时，“/”和“*.do”都匹配，哪个servlet响应 Servlet引擎将调用Servlet2。 匹配的原则就是”谁长得更像就找谁” Servlet 与普通java类的区别 Servlet是一个供其他Java程序（Servlet引擎）调用的Java类，它不能独立运行，它的运行完全由Servlet引擎来控制和调度。 针对客户端的多次Servlet请求，通常情况下，服务器只会创建一个Servlet实例对象，也就是说Servlet实例对象一旦创建，它就会驻留在内存中，为后续的其它请求服务，直至web容器退出，servlet实例对象才会销毁。 在Servlet的整个生命周期内，Servlet的init方法只被调用一次。而对一个Servlet的每次访问请求都导致Servlet引擎调用一次servlet的service方法。对于每次访问请求，Servlet引擎都会创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象，然后将这两个对象作为参数传递给它调用的Servlet的service()方法，service方法再根据请求方式分别调用doXXX方法。 如果在元素中配置了一个元素，那么WEB应用程序在启动时，就会装载并创建Servlet的实例对象、以及调用Servlet实例对象的init()方法。 举例：1234567&lt;servlet&gt; &lt;servlet-name&gt;invoker&lt;/servlet-name&gt; &lt;servlet-class&gt; org.apache.catalina.servlets.InvokerServlet &lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 用途：为web应用写一个InitServlet，这个servlet配置为启动时装载，为整个web应用创建必要的数据库表和数据。 缺省Servlet 如果某个Servlet的映射路径仅仅为一个正斜杠（/），那么这个Servlet就成为当前Web应用程序的缺省Servlet。 凡是在web.xml文件中找不到匹配的元素的URL，它们的访问请求都将交给缺省Servlet处理，也就是说，缺省Servlet用于处理所有其他Servlet都不处理的访问请求。 例如：1234567891011&lt;servlet&gt; &lt;servlet-name&gt;ServletDemo2&lt;/servlet-name&gt; &lt;servlet-class&gt;ServletDemo2&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 将ServletDemo2配置成缺省Servlet --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo2&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 当访问不存在的Servlet时，就使用配置的默认Servlet进行处理，如下图所示： 在&lt;tomcat的安装目录&gt;\\conf\\web.xml文件中，注册了一个名称为org.apache.catalina.servlets.DefaultServlet的Servlet，并将这个Servlet设置为了缺省Servlet。 当访问Tomcat服务器中的某个静态HTML文件和图片时，实际上是在访问这个缺省Servlet。","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://yoursite.com/categories/javaEE/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"}]},{"title":"Linux常用命令学习","slug":"Linux常用命令学习","date":"2018-07-20T04:10:37.793Z","updated":"2018-07-20T04:10:37.793Z","comments":true,"path":"2018/07/20/Linux常用命令学习/","link":"","permalink":"http://yoursite.com/2018/07/20/Linux常用命令学习/","excerpt":"","text":"Linux常用命令学习显示命令arch 显示机器的处理器架构(1)uname -m 显示机器的处理器架构(2)uname -r 显示正在使用的内核版本dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)hdparm -i /dev/hda 罗列一个磁盘的架构特性hdparm -tT /dev/sda 在磁盘上执行测试性读取操作cat /proc/cpuinfo 显示CPU info的信息cat /proc/interrupts 显示中断cat /proc/meminfo 校验内存使用cat /proc/swaps 显示哪些swap被使用cat /proc/version 显示内核的版本cat /proc/net/dev 显示网络适配器及统计cat /proc/mounts 显示已加载的文件系统lspci -tv 罗列 PCI 设备lsusb -tv 显示 USB 设备date 显示系统日期cal 2007 显示2007年的日历表date 041217002007.00 设置日期和时间 - 月日时分年.秒clock -w 将时间修改保存到 BIOS 关机 (系统的关机、重启以及登出 )shutdown -h now 关闭系统(1)init 0 关闭系统(2)telinit 0 关闭系统(3)shutdown -h hours:minutes &amp; 按预定时间关闭系统shutdown -c 取消按预定时间关闭系统shutdown -r now 重启(1)reboot 重启(2)logout 注销 文件和目录cd /home 进入 ‘/ home’ 目录’cd .. 返回上一级目录cd ../.. 返回上两级目录cd 进入个人的主目录cd ~user1 进入个人的主目录cd - 返回上次所在的目录pwd 显示工作路径ls 查看目录中的文件ls -F 查看目录中的文件ls -l 显示文件和目录的详细资料ls -a 显示隐藏文件ls [0-9] 显示包含数字的文件名和目录名tree 显示文件和目录由根目录开始的树形结构(1)lstree 显示文件和目录由根目录开始的树形结构(2)mkdir dir1 创建一个叫做 ‘dir1’ 的目录’mkdir dir1 dir2 同时创建两个目录mkdir -p /tmp/dir1/dir2 创建一个目录树rm -f file1 删除一个叫做 ‘file1’ 的文件’rmdir dir1 删除一个叫做 ‘dir1’ 的目录’rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容rm -rf dir1 dir2 同时删除两个目录及它们的内容mv dir1 new_dir 重命名/移动 一个目录cp file1 file2 复制一个文件cp dir/* . 复制一个目录下的所有文件到当前工作目录cp -a /tmp/dir1 . 复制一个目录到当前工作目录cp -a dir1 dir2 复制一个目录ln -s file1 lnk1 创建一个指向文件或目录的软链接ln file1 lnk1 创建一个指向文件或目录的物理链接touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)file file1 outputs the mime type of the file as texticonv -l 列出已知的编码 文件搜索find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录find / -user user1 搜索属于用户 ‘user1’ 的文件和目录find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件find / -name *.rpm -exec chmod 755 ‘{}’ \\; 搜索以 ‘.rpm’ 结尾的文件并定义其权限find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令whereis halt 显示一个二进制文件、源码或man的位置which halt 显示一个二进制文件或可执行文件的完整路径 挂载一个文件系统mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出fuser -km /mnt/hda2 当设备繁忙时强制卸载umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用mount /dev/fd0 /mnt/floppy 挂载一个软盘mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrommount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrommount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrommount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 磁盘空间df -h 显示已经挂载的分区列表ls -lSr |more 以尺寸大小排列文件和目录du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) 用户和群组groupadd group_name 创建一个新用户组groupdel group_name 删除一个用户组groupmod -n new_group_name old_group_name 重命名一个用户组useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户useradd user1 创建一个新用户userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性passwd 修改口令passwd user1 修改一个用户的口令 (只允许root执行)chage -E 2005-12-31 user1 设置用户口令的失效期限pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消ls -lh 显示权限ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限chown user1 file1 改变一个文件的所有人属性chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性chgrp group1 file1 改变文件的群组chown user1:group1 file1 改变一个文件的所有人和群组属性find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限chmod u-s /bin/file1 禁用一个二进制文件的 SUID位chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的chmod g-s /home/public 禁用一个目录的 SGID 位chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件chmod o-t /home/public 禁用一个目录的 STIKY 位 文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消chattr +a file1 只允许以追加方式读写文件chattr +c file1 允许这个文件能被内核自动压缩/解压chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接chattr +s file1 允许一个文件被安全地删除chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件lsattr 显示特殊的属性 打包和压缩文件bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件bzip2 file1 压缩一个叫做 ‘file1’ 的文件gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件gzip file1 压缩一个叫做 ‘file1’的文件gzip -9 file1 最大程度压缩rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’rar x file1.rar 解压rar包unrar x file1.rar 解压rar包tar -cvf archive.tar file1 创建一个非压缩的 tarballtar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件tar -tf archive.tar 显示一个包中的内容tar -xvf archive.tar 释放一个包tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包zip file1.zip file1 创建一个zip格式的压缩包zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包unzip file1.zip 解压一个zip格式压缩包 RPM 包 - （Fedora, Redhat及类似系统）rpm -ivh package.rpm 安装一个rpm包rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告rpm -U package.rpm 更新一个rpm包但不改变其配置文件rpm -F package.rpm 更新一个确定已经安装的rpm包rpm -e package_name.rpm 删除一个rpm包rpm -qa 显示系统中所有已经安装的rpm包rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包rpm -qi package_name 获取一个已安装包的特殊信息rpm -qg “System Environment/Daemons” 显示一个组件的rpm包rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表rpm -q package_name –whatprovides 显示一个rpm包所占的体积rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本lrpm -q package_name –changelog 显示一个rpm包的修改历史rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书rpm –checksig package.rpm 确认一个rpm包的完整性rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间rpm -Va 检查系统中所有已安装的rpm包- 小心使用rpm -Vp package.rpm 确认一个rpm包还未安装rpm2cpio package.rpm | cpio –extract –make-directories bin 从一个rpm包运行可执行文件rpm -ivh /usr/src/redhat/RPMS/arch/package.rpm 从一个rpm源码安装一个构建好的包rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 YUM 软件包升级器 - （Fedora, RedHat及类似系统）yum install package_name 下载并安装一个rpm包yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系yum update package_name.rpm 更新当前系统中所有安装的rpm包yum update package_name 更新一个rpm包yum remove package_name 删除一个rpm包yum list 列出当前系统中安装的所有包yum search package_name 在rpm仓库中搜寻软件包yum clean packages 清理rpm缓存删除下载的包yum clean headers 删除所有头文件yum clean all 删除所有缓存的包和头文件 DEB 包 (Debian, Ubuntu 以及类似系统)dpkg -i package.deb 安装/更新一个 deb 包dpkg -r package_name 从系统删除一个 deb 包dpkg -l 显示系统中所有已经安装的 deb 包dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包dpkg -s package_name 获得已经安装在系统中一个特殊包的信息dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 APT 软件工具 (Debian, Ubuntu 以及类似系统)apt-get install package_name 安装/更新一个 deb 包apt-cdrom install package_name 从光盘安装/更新一个 deb 包apt-get update 升级列表中的软件包apt-get upgrade 升级所有已安装的软件apt-get remove package_name 从系统删除一个deb包apt-get check 确认依赖的软件仓库正确apt-get clean 从下载的软件包中清理缓存apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 查看文件内容cat file1 从第一个字节开始正向查看文件的内容tac file1 从最后一行开始反向查看一个文件的内容more file1 查看一个长文件的内容less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作head -2 file1 查看一个文件的前两行tail -2 file1 查看一个文件的最后两行tail -f /var/log/messages 实时查看被添加到一个文件中的内容","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"初识Linux命令","slug":"初识Linux命令","permalink":"http://yoursite.com/tags/初识Linux命令/"}]},{"title":"Linux下安装jdk8步骤详述","slug":"Linux下安装jdk8步骤详述","date":"2018-07-20T04:10:37.789Z","updated":"2018-07-20T04:10:37.789Z","comments":true,"path":"2018/07/20/Linux下安装jdk8步骤详述/","link":"","permalink":"http://yoursite.com/2018/07/20/Linux下安装jdk8步骤详述/","excerpt":"","text":"Linux下安装jdk8步骤详述下载jdk8登录网址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html选择对应jdk版本下载。（可在Windows下下载完成后，通过文件夹共享到Linux上） 登录Linux，切换到root用户su root 获取root用户权限，当前工作目录不变(需要root密码)或sudo -i 不需要root密码直接切换成root（需要当前用户密码） 在usr目录下建立java安装目录cd /usrmkdir java 将jdk-8u60-linux-x64.tar.gz拷贝到java目录下cp /mnt/hgfs/linux/jdk-8u181-linux-x64.tar.gz /usr/java 解压jdk到当前目录tar -zxvf jdk-8u60-linux-x64.tar.gz 编辑配置文件，配置环境变量vim /etc/profile 添加如下内容：JAVA_HOME根据实际目录来1234JAVA_HOME=/usr/java/jdk1.8.0_181CLASSPATH=$JAVA_HOME/lib/PATH=$PATH:$JAVA_HOME/binexport PATH JAVA_HOME CLASSPATH 重启机器或执行命令执行命令 ：source /etc/profile或重启机器：sudo shutdown -r now 查看安装情况java -version 123java version &quot;1.8.0_181&quot;Java(TM) SE Runtime Environment (build 1.8.0_181-b27)Java HotSpot(TM) Client VM (build 25.181-b23, mixed mode) 可能出现的错误信息：bash: ./java: cannot execute binary file 出现这个错误的原因可能是在32位的操作系统上安装了64位的jdk，查看jdk版本和Linux版本位数是否一致。查看你安装的Ubuntu是32位还是64位系统：sudo uname –mi686 //表示是32位x86_64 // 表示是64位","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"初识Linux","slug":"初识Linux","permalink":"http://yoursite.com/tags/初识Linux/"}]},{"title":"javaweb (八)","slug":"commons-dbutils简介","date":"2018-07-20T04:10:37.789Z","updated":"2018-07-20T04:10:37.789Z","comments":true,"path":"2018/07/20/commons-dbutils简介/","link":"","permalink":"http://yoursite.com/2018/07/20/commons-dbutils简介/","excerpt":"","text":"commons-dbutils简介 commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。因此dbutils成为很多不喜欢hibernate的公司的首选。commons-dbutilsAPI介绍： org.apache.commons.dbutils.QueryRunner org.apache.commons.dbutils.ResultSetHandler工具类 org.apache.commons.dbutils.DbUtils QueryRunner类使用讲解 该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。 QueryRunner类提供了两个构造方法： 默认的构造方法 需要一个 javax.sql.DataSource 来作参数的构造方法。QueryRunner类的主要方法 public Object query(Connection conn, String sql, Object[] params, ResultSetHandler rsh) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。 public Object query(String sql, Object[] params, ResultSetHandler rsh) throws SQLException: 几乎与第一种方法一样；唯一的不同在于它不将数据库连接提供给方法，并且它是从提供给构造方法的数据源(DataSource) 或使用的setDataSource 方法中重新获得 Connection。 public Object query(Connection conn, String sql, ResultSetHandler rsh) throws SQLException : 执行一个不需要置换参数的查询操作。 public int update(Connection conn, String sql, Object[] params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。 public int update(Connection conn, String sql) throws SQLException：用来执行一个不需要置换参数的更新操作。 使用QueryRunner类实现CRUD","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://yoursite.com/categories/javaEE/"}],"tags":[{"name":"commons-dbutils","slug":"commons-dbutils","permalink":"http://yoursite.com/tags/commons-dbutils/"}]},{"title":"Fragment  的详细介绍和使用方法","slug":"一、Fragment的基础知识介绍","date":"2018-07-20T04:10:37.789Z","updated":"2018-07-20T04:10:37.789Z","comments":true,"path":"2018/07/20/一、Fragment的基础知识介绍/","link":"","permalink":"http://yoursite.com/2018/07/20/一、Fragment的基础知识介绍/","excerpt":"","text":"转载:http://blog.csdn.net/yangyu20121224/article/details/8995025 &amp;#8195&amp;#8195由于TabActivity在Android4.0以后已经被完全弃用，那么我就不再浪费口水继续讲解它了，取而代之的是Fragment。Fragment是Android3.0新增的概念，Fragment翻译成中文是碎片的意思，不过却和Activity十分的相似，这一篇我花大量的篇幅来详细的讲解Fragment的介绍和使用方法。 一、Fragment的基础知识介绍1.1概述1.1.1 特性&amp;#8195&amp;#8195Fragment是activity的界面中的一部分或一种行为。可以把多个Fragment组合到一个activity中来创建一个多界面并且可以在多个activity中重用一个Fragment。可以把Fragment任务模块化的一段activity，它具有自己的生命周期，接收它自己的事件，并可以在activity运行时被添加或删除。&amp;#8195&amp;#8195 Fragment不能独立存在，它必须嵌入到activity中，而且Fragment的生命周期直接受所在的activity的影响。例如：当activity暂停时，他拥有的所有的Fragment都暂停了，当activity销毁时，他拥有的所有Fragment都被销毁。然而，当activity运行时（在onResume()之后，onPause()之前），可以单独地操作每个Fragment，比如添加或删除它们。当中执行上述针对Fragment的事务时，可以将事务添加到一个栈中，这个栈被activity管理，栈中的每一条都是一个Fragment的一次事务。有了这个栈，就可以反向执行Fragment的事务，这样就可以在Fragment级支持“返回”键（向后导航）。&amp;#8195&amp;#8195当向activity中添加一个Fragment时，它须置于ViewGroup控件中，并且需定义Fragment自己的界面。可以在layout.xml布局文件中声明Fragment，元素为：；也可以在代码中创建Fragment，然后把它加入到ViewGroup控件中。然而，Fragment不一定非要放在activity的界面中，它可以隐藏在后台为activity工作。 1.1.2 生命周期onCreate()：&amp;#8195&amp;#8195当创建fragment时系统调用此方法。在其中必须初始化fragment的基础组件们。可参考activity的说明； onCreateView()：&amp;#8195&amp;#8195系统在fragment要画自己的界面时调用（在真正显示之前）此方法，这个方法必须返回fragment的layout的根控件，如果这个fragment不提供界面，那它应返回null； onPause()：&amp;#8195&amp;#8195大多数程序应最少对fragment实现这三个方法，当然还有其它几个回调方法可应该按情况实现之，所有的声明周期。下图为fragment的生命周期（它所在的activity处于运行状态） Activity和Fragment生命周期对比图如下： 两个的生命周期很类似，也息息相关。 1.1.3 派生类DialogFragment 显示一个浮动的对话框。使用这个类创建对话框是替代activity创建对话框的最佳选择。因为可以把fragmentdialog放入到activity的返回栈中，使用户能再返回到这个对话框。 ListFragment 显示一个列表控件，就像ListActivity类，它提供了很多管理列表的方法，比如onListItemClick()方法响应click事件。 PreferenceFragment 显示一个由Preference对象组成的列表，与PreferenceActivity相同。它用于为程序创建“设置”activity。1.2 范例写一个读新闻的程序，可以用一个fragment显示标题列表，另一个fragment显示选中标题的内容，这两个fragment都在一个activity上，并排显示。那么这两个fragment都有自己的生命周期并响应自己感兴趣的事件。于是，不需要再像手机上那样用一个activity显示标题列表，用另一个activity显示新闻内容；现在可以把两者放在一个activity上同时显示出来。如下图：Fragment必须被写成可重用的模块。因为fragment有自己的layout，自己进行事件响应，拥有自己的生命周期和行为，所以可以在多个activity中包含同一个Fragment的不同实例。这对于让世界在不同的屏幕尺寸下都能给用户完美的体验尤其重要。比如可以在程序运行于大屏幕中时启动包含很多fragment的activity，而在运行小屏幕时启动一个包含少量fragment的activity。刚才读新闻的程序，当检测到程序运行于大屏幕时，启动activityA，将标题列表和新闻内容这两个fragment都放 在activityA中；当检测到程序运行于小屏幕时，还是启动activityA，但此时A中只有标题列表fragment，当选中一个标题时，activityA启动activityB，B中含有新闻内容fragment。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Fragment","slug":"Fragment","permalink":"http://yoursite.com/tags/Fragment/"}]},{"title":"javaweb (八)","slug":"验证码图片","date":"2018-07-20T04:10:37.789Z","updated":"2018-07-20T04:10:37.789Z","comments":true,"path":"2018/07/20/验证码图片/","link":"","permalink":"http://yoursite.com/2018/07/20/验证码图片/","excerpt":"","text":"验证码图片123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160package qgx.response.study;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;@WebServlet(name = &quot;DrawImage&quot;)public class DrawImage extends HttpServlet &#123; public static final int WIDTH = 120;//生成的图片的宽度 public static final int HEIGHT = 30;//生成的图片的高度 protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;//接收客户端传递的createTypeFlag标识 String createTypeFlag = request.getParameter(&quot;createTypeFlag&quot;);//1.在内存中创建一张图片 BufferedImage bi = new BufferedImage(WIDTH, HEIGHT, BufferedImage.TYPE_INT_RGB); //2. 得到图片 Graphics g = bi.getGraphics(); //3.设置图片的背景色 setBackGround(g); //4. 设置图片的边框 setBorder(g); //5. 在图片上画干扰线 drawRandomLine(g); //6.写在图片上随机数 String random = drawRandomNum((Graphics2D) g, createTypeFlag);//根据客户端传递的createTypeFlag标识生成验证码图片 //7.将随机数存在session中 request.getSession().setAttribute(&quot;checkcode&quot;, random); //8.设置响应头通知浏览器以图片的形式打开 response.setContentType(&quot;image/jpeg&quot;);//等同于response.setHeader(&quot;Content-Type&quot;, &quot;image/jpeg&quot;); //9.设置响应头控制浏览器不要缓存 response.setDateHeader(&quot;expries&quot;, -1); response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;); response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;); //10.将图片写给浏览器 ImageIO.write(bi, &quot;jpg&quot;, response.getOutputStream()); &#125; /** * 画随机字符 * * @param g * @param createTypeFlag * @return */ private String drawRandomNum(Graphics2D g, String... createTypeFlag) &#123; // 设置颜色 g.setColor(Color.RED); // 设置字体 g.setFont(new Font(&quot;行书&quot;, Font.BOLD, 20)); //常用的中国汉字 String baseChineseChar = &quot;\\u5218\\u4FED\\u6885&quot;;// String baseChineseChar = &quot;\\u7684\\u4e00\\u4e86\\u662f\\u6211\\u4e0d\\u5728\\u4eba\\u4eec\\u6709\\u6765\\u4ed6\\u8fd9\\u4e0a\\u7740\\u4e2a\\u5730\\u5230\\u5927\\u91cc\\u8bf4\\u5c31\\u53bb\\u5b50\\u5f97\\u4e5f\\u548c\\u90a3\\u8981\\u4e0b\\u770b\\u5929\\u65f6\\u8fc7\\u51fa\\u5c0f\\u4e48\\u8d77\\u4f60\\u90fd\\u628a\\u597d\\u8fd8\\u591a\\u6ca1\\u4e3a\\u53c8\\u53ef\\u5bb6\\u5b66\\u53ea\\u4ee5\\u4e3b\\u4f1a\\u6837\\u5e74\\u60f3\\u751f\\u540c\\u8001\\u4e2d\\u5341\\u4ece\\u81ea\\u9762\\u524d\\u5934\\u9053\\u5b83\\u540e\\u7136\\u8d70\\u5f88\\u50cf\\u89c1\\u4e24\\u7528\\u5979\\u56fd\\u52a8\\u8fdb\\u6210\\u56de\\u4ec0\\u8fb9\\u4f5c\\u5bf9\\u5f00\\u800c\\u5df1\\u4e9b&quot; +// &quot;\\u73b0\\u5c71\\u6c11\\u5019\\u7ecf\\u53d1\\u5de5\\u5411\\u4e8b\\u547d\\u7ed9\\u957f\\u6c34\\u51e0\\u4e49\\u4e09\\u58f0\\u4e8e\\u9ad8\\u624b\\u77e5\\u7406\\u773c\\u5fd7\\u70b9\\u5fc3\\u6218\\u4e8c\\u95ee\\u4f46\\u8eab\\u65b9\\u5b9e\\u5403\\u505a\\u53eb\\u5f53\\u4f4f\\u542c\\u9769\\u6253\\u5462\\u771f\\u5168\\u624d\\u56db\\u5df2\\u6240\\u654c\\u4e4b\\u6700\\u5149\\u4ea7\\u60c5\\u8def\\u5206\\u603b\\u6761\\u767d\\u8bdd\\u4e1c\\u5e2d\\u6b21\\u4eb2\\u5982\\u88ab\\u82b1\\u53e3\\u653e\\u513f\\u5e38\\u6c14\\u4e94\\u7b2c\\u4f7f\\u5199\\u519b\\u5427\\u6587\\u8fd0\\u518d\\u679c\\u600e\\u5b9a\\u8bb8\\u5feb\\u660e\\u884c\\u56e0\\u522b\\u98de\\u5916\\u6811\\u7269&quot; +// &quot;\\u6d3b\\u90e8\\u95e8\\u65e0\\u5f80\\u8239\\u671b\\u65b0\\u5e26\\u961f\\u5148\\u529b\\u5b8c\\u5374&quot; +// &quot;\\u7ad9\\u4ee3\\u5458\\u673a\\u66f4\\u4e5d\\u60a8\\u6bcf\\u98ce\\u7ea7\\u8ddf\\u7b11\\u554a\\u5b69\\u4e07\\u5c11\\u76f4\\u610f\\u591c\\u6bd4\\u9636\\u8fde\\u8f66\\u91cd\\u4fbf\\u6597\\u9a6c\\u54ea\\u5316\\u592a\\u6307\\u53d8\\u793e\\u4f3c\\u58eb\\u8005\\u5e72\\u77f3\\u6ee1\\u65e5\\u51b3\\u767e\\u539f\\u62ff\\u7fa4\\u7a76\\u5404\\u516d\\u672c\\u601d\\u89e3\\u7acb\\u6cb3\\u6751\\u516b\\u96be\\u65e9\\u8bba\\u5417\\u6839\\u5171\\u8ba9\\u76f8\\u7814\\u4eca\\u5176\\u4e66\\u5750\\u63a5\\u5e94\\u5173\\u4fe1\\u89c9\\u6b65\\u53cd\\u5904\\u8bb0\\u5c06\\u5343\\u627e\\u4e89\\u9886\\u6216\\u5e08\\u7ed3\\u5757\\u8dd1\\u8c01\\u8349\\u8d8a\\u5b57\\u52a0\\u811a\\u7d27\\u7231&quot; +// &quot;\\u7b49\\u4e60\\u9635\\u6015\\u6708\\u9752\\u534a\\u706b\\u6cd5\\u9898\\u5efa\\u8d76\\u4f4d\\u5531\\u6d77\\u4e03\\u5973\\u4efb\\u4ef6\\u611f\\u51c6\\u5f20\\u56e2\\u5c4b\\u79bb\\u8272\\u8138\\u7247\\u79d1\\u5012\\u775b\\u5229\\u4e16\\u521a\\u4e14\\u7531\\u9001\\u5207\\u661f\\u5bfc\\u665a\\u8868\\u591f\\u6574\\u8ba4\\u54cd\\u96ea\\u6d41\\u672a\\u573a\\u8be5\\u5e76\\u5e95\\u6df1\\u523b\\u5e73\\u4f1f\\u5fd9\\u63d0\\u786e\\u8fd1\\u4eae\\u8f7b\\u8bb2\\u519c\\u53e4\\u9ed1\\u544a\\u754c\\u62c9\\u540d\\u5440\\u571f\\u6e05\\u9633\\u7167\\u529e\\u53f2\\u6539\\u5386\\u8f6c\\u753b\\u9020\\u5634\\u6b64\\u6cbb\\u5317\\u5fc5\\u670d\\u96e8\\u7a7f\\u5185\\u8bc6\\u9a8c\\u4f20\\u4e1a&quot; +// &quot;\\u83dc\\u722c\\u7761\\u5174\\u5f62\\u91cf\\u54b1\\u89c2\\u82e6\\u4f53\\u4f17\\u901a\\u51b2\\u5408\\u7834\\u53cb\\u5ea6\\u672f\\u996d\\u516c\\u65c1\\u623f\\u6781\\u5357\\u67aa\\u8bfb\\u6c99\\u5c81\\u7ebf\\u91ce\\u575a\\u7a7a\\u6536\\u7b97\\u81f3\\u653f\\u57ce\\u52b3\\u843d\\u94b1\\u7279\\u56f4\\u5f1f\\u80dc\\u6559\\u70ed\\u5c55\\u5305\\u6b4c\\u7c7b\\u6e10\\u5f3a\\u6570\\u4e61\\u547c\\u6027\\u97f3\\u7b54\\u54e5\\u9645\\u65e7\\u795e\\u5ea7\\u7ae0\\u5e2e\\u5566\\u53d7\\u7cfb\\u4ee4\\u8df3\\u975e\\u4f55\\u725b\\u53d6\\u5165\\u5cb8\\u6562\\u6389\\u5ffd\\u79cd\\u88c5\\u9876\\u6025\\u6797\\u505c\\u606f\\u53e5\\u533a\\u8863\\u822c\\u62a5\\u53f6\\u538b\\u6162\\u53d4\\u80cc\\u7ec6&quot;; //数字和字母的组合 String baseNumLetter = &quot;0123456789ABCDEFGHJKLMNOPQRSTUVWXYZ&quot;; //纯数字 String baseNum = &quot;0123456789&quot;; //纯字母 String baseLetter = &quot;ABCDEFGHJKLMNOPQRSTUVWXYZ&quot;; //createTypeFlag[0]==null表示没有传递参数 if (createTypeFlag.length &gt; 0 &amp;&amp; null != createTypeFlag[0]) &#123; if (createTypeFlag[0].equals(&quot;ch&quot;)) &#123; // 截取汉字 return createRandomChar(g, baseChineseChar); &#125; else if (createTypeFlag[0].equals(&quot;nl&quot;)) &#123; // 截取数字和字母的组合 return createRandomChar(g, baseNumLetter); &#125; else if (createTypeFlag[0].equals(&quot;n&quot;)) &#123; // 截取数字 return createRandomChar(g, baseNum); &#125; else if (createTypeFlag[0].equals(&quot;l&quot;)) &#123; // 截取字母 return createRandomChar(g, baseLetter); &#125; &#125; else &#123; // 默认截取数字和字母的组合 return createRandomChar(g, baseNumLetter); &#125; return &quot;&quot;; &#125; private String createRandomChar(Graphics2D g, String baseChar) &#123; StringBuffer sb = new StringBuffer(); int x = 5; String ch = &quot;&quot;; // 控制字数 for (int i = 0; i &lt; 4; i++) &#123; // 设置字体旋转角度 int degree = new Random().nextInt() % 30; ch = baseChar.charAt(new Random().nextInt(baseChar.length())) + &quot;&quot;; sb.append(ch); // 正向角度 g.rotate(degree * Math.PI / 180, x, 20); g.drawString(ch, x, 20); // 反向角度 g.rotate(-degree * Math.PI / 180, x, 20); x += 30; &#125; return sb.toString(); &#125; /** * 在图片上画干扰线 * * @param g */ private void drawRandomLine(Graphics g) &#123; // 设置颜色 g.setColor(Color.GREEN); // 设置线条个数并画线 for (int i = 0; i &lt; 5; i++) &#123; int x1 = new Random().nextInt(WIDTH); int y1 = new Random().nextInt(HEIGHT); int x2 = new Random().nextInt(WIDTH); int y2 = new Random().nextInt(HEIGHT); g.drawLine(x1, y1, x2, y2); &#125; &#125; /** * 设置图片的边框 * * @param g */ private void setBorder(Graphics g) &#123; // 设置边框颜色 g.setColor(Color.BLUE); // 边框区域 g.drawRect(1, 1, WIDTH - 2, HEIGHT - 2); &#125; /** * 设置图片背景色 * * @param g */ private void setBackGround(Graphics g) &#123; // 设置颜色 g.setColor(Color.WHITE); // 填充区域 g.fillRect(0, 0, WIDTH, HEIGHT); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 运行结果： 在Form表单中使用验证码图片12345678910111213141516171819202122232425262728&lt;%-- Created by IntelliJ IDEA. User: qgx Date: 2018/5/16 Time: 22:38 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;在Form表单中使用验证码&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function changeImg()&#123; document.getElementById(&quot;validateCodeImg&quot;).src=&quot;$&#123;pageContext.request.contextPath&#125;/DrawImage?&quot;+Math.random(); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/&quot; method=&quot;post&quot;&gt; 验证码：&lt;input type=&quot;text&quot; name=&quot;validateCode&quot;/&gt; &lt;img alt=&quot;验证码看不清，换一张&quot; src=&quot;$&#123;pageContext.request.contextPath&#125;/servlet/DrawImage&quot; id=&quot;validateCodeImg&quot; onclick=&quot;changeImg()&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;changeImg()&quot;&gt;看不清，换一张&lt;/a&gt; &lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536&lt;%-- Created by IntelliJ IDEA. User: qgx Date: 2018/5/16 Time: 22:38 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;在Form表单中使用验证码&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function changeImg(obj,createTypeFlag)&#123; document.getElementById(obj.id).src=&quot;$&#123;pageContext.request.contextPath&#125;/DrawImage?createTypeFlag=&quot;+createTypeFlag+&quot;&amp;&quot;+Math.random(); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/CheckServlet&quot; method=&quot;post&quot;&gt; 数字字母混合验证码：&lt;input type=&quot;text&quot; name=&quot;validateCode&quot;/&gt; &lt;img alt=&quot;验证码看不清，换一张&quot; src=&quot;$&#123;pageContext.request.contextPath&#125;/DrawImage&quot; id=&quot;validateCodeImg1&quot; onclick=&quot;changeImg(this,&apos;nl&apos;)&quot;&gt; &lt;br/&gt; 中文验证码：&lt;input type=&quot;text&quot; name=&quot;validateCode&quot;/&gt; &lt;img alt=&quot;验证码看不清，换一张&quot; src=&quot;$&#123;pageContext.request.contextPath&#125;/DrawImage?createTypeFlag=ch&quot; id=&quot;validateCodeImg2&quot; onclick=&quot;changeImg(this,&apos;ch&apos;)&quot;&gt; &lt;br/&gt; 英文验证码：&lt;input type=&quot;text&quot; name=&quot;validateCode&quot;/&gt; &lt;img alt=&quot;验证码看不清，换一张&quot; src=&quot;$&#123;pageContext.request.contextPath&#125;/DrawImage?createTypeFlag=l&quot; id=&quot;validateCodeImg3&quot; onclick=&quot;changeImg(this,&apos;l&apos;)&quot;&gt; &lt;br/&gt; 数字验证码：&lt;input type=&quot;text&quot; name=&quot;validateCode&quot;/&gt; &lt;img alt=&quot;验证码看不清，换一张&quot; src=&quot;$&#123;pageContext.request.contextPath&#125;/DrawImage?createTypeFlag=n&quot; id=&quot;validateCodeImg4&quot; onclick=&quot;changeImg(this,&apos;n&apos;)&quot;&gt; &lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425package qgx.response.study;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = &quot;CheckServlet&quot;)public class CheckServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String clientCheckcode = request.getParameter(&quot;validateCode&quot;);//接收客户端浏览器提交上来的验证码 String serverCheckcode = (String) request.getSession().getAttribute(&quot;checkcode&quot;);//从服务器端的session中取出验证码 if (clientCheckcode.equals(serverCheckcode)) &#123;//将客户端验证码和服务器端验证比较，如果相等，则表示验证通过 System.out.println(&quot;验证码验证通过！&quot;); &#125; else &#123; System.out.println(&quot;验证码验证失败！&quot;); &#125; &#125;&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://yoursite.com/categories/javaEE/"}],"tags":[{"name":"BufferedImage","slug":"BufferedImage","permalink":"http://yoursite.com/tags/BufferedImage/"}]},{"title":"javaweb (十一 )","slug":"一、Session简单介绍","date":"2018-07-20T04:10:37.789Z","updated":"2018-07-20T04:10:37.789Z","comments":true,"path":"2018/07/20/一、Session简单介绍/","link":"","permalink":"http://yoursite.com/2018/07/20/一、Session简单介绍/","excerpt":"","text":"一、Session简单介绍在WEB开发中，服务器可以为每个用户浏览器创建一个会话对象（session对象），注意：一个浏览器独占一个session对象(默认情况下)。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其它程序时，其它程序可以从用户的session中取出该用户的数据，为用户服务。 二、Session和Cookie的主要区别 Cookie是把用户的数据写给用户的浏览器。 Session技术把用户的数据写到用户独占的session中。 Session对象由服务器创建，开发人员可以调用request对象的getSession方法得到session对象。三、session实现原理3.1、服务器是如何实现一个session为一个用户浏览器服务的？ 服务器创建session出来后，会把session的id号，以cookie的形式回写给客户机，这样，只要客户机的浏览器不关，再去访问服务器时，都会带着session的id号去，服务器发现客户机浏览器带session id过来了，就会使用内存中与之对应的session为之服务。可以用如下的代码证明：123456789101112131415161718192021222324252627282930package qgx.session;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;@WebServlet(name = &quot;SessionDemo1&quot;)public class SessionDemo1 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=UTF-8&quot;); HttpSession session = request.getSession(); session.setAttribute(&quot;data&quot;, &quot;刘俭梅&quot;); String sessionId = session.getId(); if (session.isNew()) &#123; response.getWriter().print(&quot;session创建成功，session的id为:&quot; + sessionId); &#125; else &#123; response.getWriter().print(&quot;服务器已经存在该session了，session的is为:&quot; + sessionId); &#125; &#125;&#125; 第一次访问时，服务器会创建一个新的sesion，并且把session的Id以cookie的形式发送给客户端浏览器，如下图所示： 点击刷新按钮，再次请求服务器，此时就可以看到浏览器再请求服务器时，会把存储到cookie中的session的Id一起传递到服务器端了，如下图所示：request.getSession()方法内部新创建了Session之后一定是做了如下的处理 1234567//获取session的Id String sessionId = session.getId(); //将session的Id存储到名字为JSESSIONID的cookie中 Cookie cookie = new Cookie(&quot;JSESSIONID&quot;, sessionId);//设置cookie的有效路径 cookie.setPath(request.getContextPath()); response.addCookie(cookie); 四、session对象的创建和销毁时机4.1、session对象的创建时机在程序中第一次调用request.getSession()方法时就会创建一个新的Session，可以用isNew()方法来判断Session是不是新创建的 范例：创建session12345678910//使用request对象的getSession()获取session，如果session不存在则创建一个HttpSession session = request.getSession();//获取session的IdString sessionId = session.getId();//判断session是不是新创建的if (session.isNew()) &#123; response.getWriter().print(&quot;session创建成功，session的id是：&quot;+sessionId);&#125;else &#123; response.getWriter().print(&quot;服务器已经存在session，session的id是：&quot;+sessionId);&#125; 4.2、session对象的销毁时机 session对象默认30分钟没有使用，则服务器会自动销毁session，在web.xml文件中可以手工配置session的失效时间，例如： 1234&lt;!-- 设置Session的有效时间:以分钟为单位--&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt; 当需要在程序中手动设置Session失效时，可以手工调用session.invalidate方法，摧毁session。123HttpSession session = request.getSession();//手工调用session.invalidate方法，摧毁sessionsession.invalidate();","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://yoursite.com/categories/javaEE/"}],"tags":[{"name":"Session","slug":"Session","permalink":"http://yoursite.com/tags/Session/"}]},{"title":"Android 编程知识","slug":"在LitePal中解析XML","date":"2018-07-20T04:10:37.789Z","updated":"2018-07-20T04:10:37.789Z","comments":true,"path":"2018/07/20/在LitePal中解析XML/","link":"","permalink":"http://yoursite.com/2018/07/20/在LitePal中解析XML/","excerpt":"","text":"在LitePal中解析XML在使用LitePal的时候有些关键步骤不可获取，其中一个是创建litepal.xml文件，放到assets目录下，里面有一些数据库名、版本号、映射列表等。那么LitePal需要怎么获取到我们配置的数据呢？这里就要去解析xml文件了。LitePal默认使用的是SAX解析。还有Pull和DOM解析未来将会被引入。 LitePalParser下面先列出几个需要解析的node和attribute：1234567static final String NODE_DB_NAME = &quot;dbname&quot;; static final String NODE_VERSION = &quot;version&quot;; static final String NODE_LIST = &quot;list&quot;; static final String NODE_MAPPING = &quot;mapping&quot;; static final String NODE_CASES = &quot;cases&quot;; static final String ATTR_VALUE = &quot;value&quot;; static final String ATTR_CLASS = &quot;class&quot;; 默认会使用SAX解析，首先要从根目录的assests目录下面去遍历到literpal.xml，然后转成数据流给解析器 解析。 LitePalAttr从litepal.xml里面解析出来的一些属性将会存到这个类。单例模式，全局只有一个。12345private static LitePalAttr litePalAttr; private int version ; private String dbName ; private String cases ; private List&lt;String&gt; classNames ; LitePalContentHandler继承了sax解析的DefaultHandler用来解析litepal.xml文件。然后把值set到LitePalAttr里面。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"litepal","slug":"litepal","permalink":"http://yoursite.com/tags/litepal/"}]}]}