<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>qin12的学习博客</title>
  
  <subtitle>只为成功找方法，不为失败找借口！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-17T14:45:07.478Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Qgx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenCV入门</title>
    <link href="http://yoursite.com/2018/09/17/OpenCV%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/09/17/OpenCV入门/</id>
    <published>2018-09-17T14:45:07.478Z</published>
    <updated>2018-09-17T14:45:07.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenCV入门"><a href="#OpenCV入门" class="headerlink" title="OpenCV入门"></a>OpenCV入门</h1><h2 id="OpenCV-的图像读取显示及保存"><a href="#OpenCV-的图像读取显示及保存" class="headerlink" title="OpenCV 的图像读取显示及保存"></a>OpenCV 的图像读取显示及保存</h2><h3 id="1、cv2-imread-文件名，-标记-读入图像"><a href="#1、cv2-imread-文件名，-标记-读入图像" class="headerlink" title="1、cv2.imread(文件名， 标记)   读入图像"></a>1、cv2.imread(文件名， 标记)   读入图像</h3><pre><code>① 、cv2.IMREAD_COLOR() : 读入彩色图像；②、 cv2.IMREAD_GRAYSCALE() : 以灰色模式读入图像</code></pre><h3 id="2、cv2-imshow-显示图像"><a href="#2、cv2-imshow-显示图像" class="headerlink" title="2、cv2.imshow()显示图像"></a>2、cv2.imshow()显示图像</h3><ul><li>cv2.waitkey() 等待键盘输入，为毫秒级</li><li>cv2.destoryAllWindows() 可以轻易删除任何我们建立的窗口，括号内输入想删除的窗口名。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cv2.namedWindow(<span class="string">'image'</span>,cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h3 id="3、-cv2-imwrite-文件名-，-img-保存图像"><a href="#3、-cv2-imwrite-文件名-，-img-保存图像" class="headerlink" title="3、 cv2.imwrite(文件名 ， img) 保存图像"></a>3、 cv2.imwrite(文件名 ， img) 保存图像</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">'111.png'</span>,img)</span><br></pre></td></tr></table></figure><h3 id="4、-练习加载一个灰度图，-显示图片，按下-’-s-‘-键保存后退出，或者按下ESC键退出不保存。"><a href="#4、-练习加载一个灰度图，-显示图片，按下-’-s-‘-键保存后退出，或者按下ESC键退出不保存。" class="headerlink" title="4、 练习加载一个灰度图， 显示图片，按下 ’ s ‘ 键保存后退出，或者按下ESC键退出不保存。"></a>4、 练习加载一个灰度图， 显示图片，按下 ’ s ‘ 键保存后退出，或者按下ESC键退出不保存。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = cv2.imread(<span class="string">'111.png'</span>, cv2.IMREAD_GRAYSCALE())</span><br><span class="line">cv2.imshow(<span class="string">'111img'</span>,img)</span><br><span class="line">k = cv2.waitkey(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> k==<span class="number">27</span>:</span><br><span class="line">    cv2.destoryAllWindows() <span class="comment"># wait for 'ESC' key to exit</span></span><br><span class="line"><span class="keyword">elif</span> k == ord(<span class="string">'s'</span>)</span><br><span class="line">cv2.imwrite(<span class="string">'222.png'</span>,img) <span class="comment">#  wait for 's' key to save and exit</span></span><br><span class="line">    cv2.destoryAllWindows()</span><br></pre></td></tr></table></figure><p><strong>如果用的是64位系统，需将key=cv2.waitKey(0)改为k=cv2.waitKey(0)&amp;0xFF @！！</strong></p><h3 id="5、-Matplotlib绘图库"><a href="#5、-Matplotlib绘图库" class="headerlink" title="5、 Matplotlib绘图库"></a>5、 Matplotlib绘图库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv2.imread(<span class="string">'111.png'</span>,<span class="number">0</span>)</span><br><span class="line">plt.show(img, cmap=<span class="string">'gray'</span> , interpolation = <span class="string">'bicubic'</span>)</span><br><span class="line">plt.xticks([]),plt.yticks([]) <span class="comment">#to hide tick values on X and Y axis</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="OpenCV视频操作"><a href="#OpenCV视频操作" class="headerlink" title="OpenCV视频操作"></a>OpenCV视频操作</h2><h3 id="1、用摄像头来捕捉视频"><a href="#1、用摄像头来捕捉视频" class="headerlink" title="1、用摄像头来捕捉视频"></a>1、用摄像头来捕捉视频</h3><p>cv2.VideoCapture() : 0为默认摄像头， 1可以更换来源：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">True</span>):</span><br><span class="line">    ret , frame = cap.read()</span><br><span class="line">    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GARY)</span><br><span class="line">    cv2.imshow(<span class="string">'frame'</span>,gray)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>)&amp;<span class="number">0xFF</span> == ord(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destoryAllWindows()</span><br></pre></td></tr></table></figure><h3 id="2、从文件中播放视频"><a href="#2、从文件中播放视频" class="headerlink" title="2、从文件中播放视频"></a>2、从文件中播放视频</h3><p>把设备索引号改成文件名即可。在播放每一帧时，使用cv2.waitKey()适当持续时间，一般可以设置25ms。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">cap=cv2.VideoCapture(<span class="string">'filename.avi'</span>)<span class="comment">#文件名及格式</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">True</span>):</span><br><span class="line">    ret , frame = cap.read()</span><br><span class="line">    gray = cv2.cvtColor(frame , cv2.COLOR_BGR2GRAY)</span><br><span class="line">    cv2.imshow(<span class="string">'frame'</span>,gray)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp;<span class="number">0xFF</span> ==ord(<span class="string">'q'</span>):  <span class="comment">#按q键退出</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><img src="https://box.kancloud.cn/bfe1412f9928c24f3711d654682ee9ba_578x242.jpg" alt=""></p><h3 id="3、保存视频"><a href="#3、保存视频" class="headerlink" title="3、保存视频"></a>3、保存视频</h3><ul><li>创建一个VideoWrite的对象，确定输出文件名，指定FourCC编码，播放频率和帧的大小，最后是isColor标签True为彩色。</li><li>FourCC是一个4字节码，用来确定视频的编码格式。<br>[1.In]  Fedora : DIVX , XVID , MJPG , X264 , WMV1 , WMV2<br>XVID是最好的，MJPG是高尺寸视频，X264得到小尺寸视频<br>[2.In]  Windows : DIVX<br>[3.In]   OSX :不知道用什么好</li></ul><p>设置FourCC格式时，原文里采用了cv2.VideoWriter_fourcc()这个函数，若运行程序的时候显示这个函数不存在，可以改用了cv2.cv.CV_FOURCC这个函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">fourcc = cv2.VideoWriter_fourcc(*<span class="string">'XVID'</span>)</span><br><span class="line">out = cv2.VideoWriter(<span class="string">'output.avi'</span>,fourcc, <span class="number">20.0</span>, (<span class="number">640</span>,<span class="number">480</span>))</span><br><span class="line"><span class="keyword">while</span>(cap.isOpened()):</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> ret==<span class="keyword">True</span>:</span><br><span class="line">        frame = cv2.flip(frame,<span class="number">0</span>)</span><br><span class="line">        out.write(frame)</span><br><span class="line">        cv2.imshow(<span class="string">'frame'</span>,frame)</span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">out.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="OpenCV中的绘图函数"><a href="#OpenCV中的绘图函数" class="headerlink" title="OpenCV中的绘图函数"></a>OpenCV中的绘图函数</h2><p>涉及的函数：cv2.line() , cv2.cicle() , cv2.rectangle() , cv2.ellipse() , cv2.putText()等<br>需要设置的参数：<br>img 你想要绘制的图形的那副图像<br>color 形状的颜色，以RGB为例，需要传入的元组，例（255,0,0）代表蓝色，对于灰度图只需传入灰度值<br>thickness 线条的粗细，如果给一个闭合图形设置为-1，那么这个图形就会被填充，默认值为1<br>linetype 线条的类型，8连接，抗锯齿等。默认是8连接。cv2.LINE_AA为抗锯齿</p><h3 id="1、画线"><a href="#1、画线" class="headerlink" title="1、画线"></a>1、画线</h3><p>需要告诉函数这条线的起点和终点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img= np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>),np,uint8)</span><br><span class="line">cv2.line(img,(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">260</span>,<span class="number">260</span>),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">5</span>)</span><br><span class="line">cv2.nameWindows(<span class="string">'image'</span>,<span class="number">1000</span>,<span class="number">1000</span>)</span><br><span class="line">cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destoryAllWindows()</span><br></pre></td></tr></table></figure><h3 id="2、画矩形"><a href="#2、画矩形" class="headerlink" title="2、画矩形"></a>2、画矩形</h3><p>需要告诉函数左上角顶点和右下角顶点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)</span><br><span class="line">cv2.rectangle(img,(<span class="number">350</span>,<span class="number">0</span>),(<span class="number">500</span>,<span class="number">128</span>),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">3</span>)</span><br><span class="line">cv2.nameWindow(<span class="string">'image'</span>,cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.resize(<span class="string">'image'</span>,<span class="number">1000</span>,<span class="number">1000</span>)</span><br><span class="line">cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destoryAllWindows()</span><br></pre></td></tr></table></figure><h3 id="3、画圆"><a href="#3、画圆" class="headerlink" title="3、画圆"></a>3、画圆</h3><p>需要指定圆心坐标和半径大小，可以在上面矩形中画一个圆</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)</span><br><span class="line">cv2.rectangle(img,(<span class="number">350</span>,<span class="number">0</span>),(<span class="number">500</span>,<span class="number">128</span>),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">3</span>)</span><br><span class="line">cv2.circle(img,(<span class="number">425</span>,<span class="number">63</span>),<span class="number">63</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">-1</span>)<span class="comment"># -1为内填充</span></span><br><span class="line">cv2.nameWindow(<span class="string">'image'</span>,cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.resize(<span class="string">'image'</span>,<span class="number">1000</span>,<span class="number">1000</span>)</span><br><span class="line">cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destoryAllWindows()</span><br></pre></td></tr></table></figure><h3 id="4、画椭圆"><a href="#4、画椭圆" class="headerlink" title="4、画椭圆"></a>4、画椭圆</h3><p>需要中心的坐标 和  和短的度。椭圆沿时针方向旋的度，圆弧演 时方向始的度和结束度如果是 0 很 360就是整个椭圆。查看 cv2.ellipse() 可以得到更多信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)</span><br><span class="line">cv2.ellipse(img,(<span class="number">256</span>,<span class="number">256</span>),(<span class="number">100</span>,<span class="number">50</span>),<span class="number">0</span>,<span class="number">0</span>,<span class="number">360</span>,<span class="number">255</span>,<span class="number">-1</span>)</span><br><span class="line">cv2.nameWindow(<span class="string">'image'</span>,cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.resize(<span class="string">'image'</span>,<span class="number">1000</span>,<span class="number">1000</span>)</span><br><span class="line">cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destoryAllWindows()</span><br></pre></td></tr></table></figure><h3 id="5、画多边形"><a href="#5、画多边形" class="headerlink" title="5、画多边形"></a>5、画多边形</h3><p>需要指定每个顶点的坐标，构建一个大小相等于行数X1X2的数组，行数就是点的数目，这个数组必须为int32。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create a black image</span></span><br><span class="line">img = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)</span><br><span class="line"></span><br><span class="line">pts=np.array([[<span class="number">10</span>,<span class="number">5</span>],[<span class="number">20</span>,<span class="number">30</span>],[<span class="number">70</span>,<span class="number">20</span>],[<span class="number">50</span>,<span class="number">10</span>]],np.int32)</span><br><span class="line">pts = pts.reshape((<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"><span class="comment">#这里reshape的第一个参数为-1，表明这一维度的长度是根据后面的维度计算出来的</span></span><br><span class="line">cv2.polylines(img,[pts],<span class="keyword">True</span>,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">255</span>)) </span><br><span class="line"><span class="comment">#注意第三个参数若是False，我们得到的是不闭合的线</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#为了演示，建窗口显示出来</span></span><br><span class="line">cv2.namedWindow(<span class="string">'image'</span>,cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.resizeWindow(<span class="string">'image'</span>,<span class="number">1000</span>,<span class="number">1000</span>)<span class="comment">#定义frame的大小</span></span><br><span class="line">cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>cv2.polylines() 可以用来画很多条线。只把想画的线放在一 个列中将个列传给函数就可以了。每条线会独立绘制。会比用 cv2.line() 一条一条的绘制快一些。</p><h3 id="6、在图片上添加文字"><a href="#6、在图片上添加文字" class="headerlink" title="6、在图片上添加文字"></a>6、在图片上添加文字</h3><p>需要设置，文字内容，绘制的位置，字体类型、大小、颜色、粗细、类型等，这里推荐linetype=cv2.LINE_AA</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create a black image</span></span><br><span class="line">img = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)</span><br><span class="line"></span><br><span class="line">font = cv2.FONT_HERSHEY_SIMPLEX  </span><br><span class="line">cv2.putText(img,<span class="string">'OpenCV'</span>,(<span class="number">10</span>,<span class="number">500</span>), font, <span class="number">4</span>,(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>),<span class="number">2</span>,cv2.LINE_AA)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#为了演示，建窗口显示出来</span></span><br><span class="line">cv2.namedWindow(<span class="string">'image'</span>,cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.resizeWindow(<span class="string">'image'</span>,<span class="number">1000</span>,<span class="number">1000</span>)<span class="comment">#定义frame的大小</span></span><br><span class="line">cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="OpenCV-处理鼠标事件"><a href="#OpenCV-处理鼠标事件" class="headerlink" title="OpenCV 处理鼠标事件"></a>OpenCV 处理鼠标事件</h2><h3 id="1、图片上双击过的位置绘制一个圆圈"><a href="#1、图片上双击过的位置绘制一个圆圈" class="headerlink" title="1、图片上双击过的位置绘制一个圆圈"></a>1、图片上双击过的位置绘制一个圆圈</h3><p>创建鼠标事件回调函数，当鼠标事件发生时就会被执行。<br>比如左键按下，松开，左键双击等。可以通过鼠标事件获得相对应的图片上的坐标，根据这些信息可以做想做的事。所有鼠标事件回调函数都有一个统一的格式，不同的地方是被调用后的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看所有被支持的鼠标事件</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">events = [i <span class="keyword">for</span> i <span class="keyword">in</span> dir(cv2) <span class="keyword">if</span> <span class="string">'EVENT'</span> <span class="keyword">in</span> i]</span><br><span class="line"><span class="keyword">print</span> (events)</span><br></pre></td></tr></table></figure><p>功能实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># mouse callback function</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_circle</span><span class="params">(event, x, y, flags, param)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> event == cv2.EVENT_LBUTTONDBLCLK:</span><br><span class="line">        cv2.circle(img, (x, y), <span class="number">100</span>, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建图像与窗口并将窗口与回调函数绑定</span></span><br><span class="line">img = np.zeros((<span class="number">500</span>, <span class="number">500</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line">cv2.namedWindow(<span class="string">'image'</span>)</span><br><span class="line">cv2.setMouseCallback(<span class="string">'image'</span>, draw_circle)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'image'</span>, img)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>)&amp;<span class="number">0xFF</span> == ord(<span class="string">'q'</span>):<span class="comment">#按q键退出</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h3 id="2、在拖动鼠标时绘制矩形"><a href="#2、在拖动鼠标时绘制矩形" class="headerlink" title="2、在拖动鼠标时绘制矩形"></a>2、在拖动鼠标时绘制矩形</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#当鼠标按下时为True</span></span><br><span class="line">drawing = <span class="keyword">False</span></span><br><span class="line"><span class="comment">#如果mode为true时绘制矩形，按下'm'变成绘制曲线</span></span><br><span class="line">mode = <span class="keyword">True</span></span><br><span class="line">ix,iy = <span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_circle</span><span class="params">(event,x,y,flags,param)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> ix,iy,drawing,mode</span><br><span class="line">    <span class="comment">#当按下左键时返回起始位置坐标</span></span><br><span class="line">    <span class="keyword">if</span> event == cv2.EVENT_LBUTTONDOWN:</span><br><span class="line">        drawing = <span class="keyword">True</span></span><br><span class="line">        ix,iy=x,y</span><br><span class="line">    <span class="comment">#当左键按下并移动时绘制图形，event可以查看移动，flag查看是否按下</span></span><br><span class="line">    <span class="keyword">elif</span> event==cv2.EVENT_MOUSEMOVE <span class="keyword">and</span> flags==cv2.EVENT_FLAG_LBUTTON:</span><br><span class="line">        <span class="keyword">if</span> drawing == <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">if</span> mode == <span class="keyword">True</span>:</span><br><span class="line">                cv2.rectangle(img,(ix,iy),(x,y),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#绘制圆圈，小圆点连在一起就成了线，3代表笔画的粗细</span></span><br><span class="line">                cv2.circle(img,(x,y),<span class="number">3</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">-1</span>)</span><br><span class="line">              </span><br><span class="line">    <span class="comment">#当鼠标松开时停止绘图</span></span><br><span class="line">    <span class="keyword">elif</span> event ==cv2.EVENT_LBUTTONUP:</span><br><span class="line">        drawing == <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">下面把回调函数与OpenCV窗口绑定在一起，在主循环中奖'm'键与模式转换绑定在一起</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">img = np.zeros((<span class="number">500</span>,<span class="number">500</span>,<span class="number">3</span>),np.uint8)</span><br><span class="line">cv2.namedWindow(<span class="string">'image'</span>)</span><br><span class="line">cv2.setMouseCallback(<span class="string">'image'</span>,draw_circle)</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">    k=cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> k ==ord(<span class="string">'m'</span>):</span><br><span class="line">        mode=<span class="keyword">not</span> mode</span><br><span class="line">    <span class="keyword">elif</span> k==ord(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="OpenCV图像的基本操作"><a href="#OpenCV图像的基本操作" class="headerlink" title="OpenCV图像的基本操作"></a>OpenCV图像的基本操作</h2><h3 id="1、获取并修改像素值"><a href="#1、获取并修改像素值" class="headerlink" title="1、获取并修改像素值"></a>1、获取并修改像素值</h3><p>读取一副图像，根据像素的行和列的坐标获取它的像素值，对于RGB图像而言，返回RGB的值，对于灰度图则返回灰度值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line">img = cv2.imread(<span class="string">'45.jpg'</span>)</span><br><span class="line">px = img[<span class="number">100</span>,<span class="number">100</span>]</span><br><span class="line">print(px)</span><br><span class="line">blue = img[<span class="number">100</span>,<span class="number">100</span>,<span class="number">0</span>]</span><br><span class="line">print(blue)</span><br><span class="line">img[<span class="number">101</span>,<span class="number">101</span>]=[<span class="number">255</span>,<span class="number">2555</span>,<span class="number">255</span>]</span><br><span class="line">print(img[<span class="number">101</span>,<span class="number">101</span>])</span><br></pre></td></tr></table></figure><p>numpy是经过优化了的进行快速矩阵运算的包，所以不推荐逐个获取像素值并修改能矩阵运算就不要用循环。</p><p>例如前5行的后3列，用numpy的array.item()和array.itemset()会更好。但是如果返回的是标量，如果想获得所有RGB的值，需要使用array.item()分割他们。</p><p>更好的办法是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy </span><br><span class="line">img = cv2.imread(<span class="string">"45.jpg"</span>)</span><br><span class="line">print(img.item(<span class="number">10</span>,<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line">img.itemset((<span class="number">10</span>,<span class="number">10</span>,<span class="number">2</span>),<span class="number">100</span>)</span><br><span class="line">print(img.item(<span class="number">10</span>,<span class="number">10</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><h3 id="2、获取图像属性"><a href="#2、获取图像属性" class="headerlink" title="2、获取图像属性"></a>2、获取图像属性</h3><p>图像属性包括：行，列，通道，图像数据类型，像素数目等</p><p>img.shape()可以获取图像的形状，返回值包含行数，列数，通道数的元组。</p><p>img.size可以返回图像的像素数目</p><p>img.dtype 可以返回图像的数据类型，因为OpenCV-python代码中经常出现数据类型的不一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line">img = cv2.imread(<span class="string">"45.jpg"</span>)</span><br><span class="line">print(img.shape)</span><br><span class="line">print(img.size)</span><br><span class="line">print(img.dtype)</span><br></pre></td></tr></table></figure><h3 id="3、图像ROI"><a href="#3、图像ROI" class="headerlink" title="3、图像ROI"></a>3、图像ROI</h3><p>对于图像的特定区域操作，ROI是使用numpy索引来获得的。</p><p>选择球的部分来拷贝到其他区域</p><p><img src="https://box.kancloud.cn/0e93e1656483b21559045976353106ce_347x212.jpg" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy </span><br><span class="line">img = cv2.imread(<span class="string">'roi.jpg'</span>)</span><br><span class="line">ball = img[<span class="number">20</span>:<span class="number">30</span>,<span class="number">30</span>:<span class="number">30</span>]</span><br><span class="line">img[<span class="number">40</span>:<span class="number">40</span>,<span class="number">50</span>:<span class="number">50</span>] = ball</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OpenCV入门&quot;&gt;&lt;a href=&quot;#OpenCV入门&quot; class=&quot;headerlink&quot; title=&quot;OpenCV入门&quot;&gt;&lt;/a&gt;OpenCV入门&lt;/h1&gt;&lt;h2 id=&quot;OpenCV-的图像读取显示及保存&quot;&gt;&lt;a href=&quot;#OpenCV-的图像读取
      
    
    </summary>
    
      <category term="大四" scheme="http://yoursite.com/categories/%E5%A4%A7%E5%9B%9B/"/>
    
    
      <category term="OpenCV" scheme="http://yoursite.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>J2EE基础</title>
    <link href="http://yoursite.com/2018/09/16/J2EE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/09/16/J2EE基础知识/</id>
    <published>2018-09-16T13:10:32.404Z</published>
    <updated>2018-09-16T13:10:32.404Z</updated>
    
    <content type="html"><![CDATA[<!-- MarkdownTOC --><ul><li><a href="#servlet总结">Servlet总结</a></li><li><a href="#阐述servlet和cgi的区别">阐述Servlet和CGI的区别?</a><ul><li><a href="#cgi的不足之处">CGI的不足之处:</a></li><li><a href="#servlet的优点">Servlet的优点：</a></li></ul></li><li><a href="#servlet接口中有哪些方法及servlet生命周期探秘">Servlet接口中有哪些方法及Servlet生命周期探秘</a></li><li><a href="#get和post请求的区别">get和post请求的区别</a></li><li><a href="#什么情况下调用doget和dopost">什么情况下调用doGet()和doPost()</a></li><li><a href="#转发forward和重定向redirect的区别">转发（Forward）和重定向（Redirect）的区别</a></li><li><a href="#自动刷新refresh">自动刷新(Refresh)</a></li><li><a href="#servlet与线程安全">Servlet与线程安全</a></li><li><a href="#jsp和servlet是什么关系">JSP和Servlet是什么关系</a></li><li><a href="#jsp工作原理">JSP工作原理</a></li><li><a href="#jsp有哪些内置对象、作用分别是什么">JSP有哪些内置对象、作用分别是什么</a></li><li><a href="#request对象的主要方法有哪些">Request对象的主要方法有哪些</a></li><li><a href="#requestgetattribute和-requestgetparameter有何区别">request.getAttribute()和 request.getParameter()有何区别</a></li><li><a href="#include指令include的行为的区别">include指令include的行为的区别</a></li><li><a href="#jsp九大内置对象，七大动作，三大指令">JSP九大内置对象，七大动作，三大指令</a></li><li><a href="#讲解jsp中的四种作用域">讲解JSP中的四种作用域</a></li><li><a href="#如何实现jsp或servlet的单线程模式">如何实现JSP或Servlet的单线程模式</a></li><li><a href="#实现会话跟踪的技术有哪些">实现会话跟踪的技术有哪些</a></li><li><a href="#cookie和session的的区别">Cookie和Session的的区别</a></li></ul><!-- /MarkdownTOC --><h2 id="Servlet总结"><a href="#Servlet总结" class="headerlink" title="Servlet总结"></a>Servlet总结</h2><p>在Java Web程序中，<strong>Servlet</strong>主要负责接收用户请求<strong>HttpServletRequest</strong>,在<strong>doGet()</strong>,<strong>doPost()</strong>中做相应的处理，并将回应<strong>HttpServletResponse</strong>反馈给用户。Servlet可以设置初始化参数，供Servlet内部使用。一个Servlet类只会有一个实例，在它初始化时调用<strong>init()方法</strong>，销毁时调用<strong>destroy()方法</strong>。<strong>Servlet需要在web.xml中配置</strong>（MyEclipse中创建Servlet会自动配置），<strong>一个Servlet可以设置多个URL访问</strong>。<strong>Servlet不是线程安全</strong>，因此要谨慎使用类变量。</p><h2 id="阐述Servlet和CGI的区别"><a href="#阐述Servlet和CGI的区别" class="headerlink" title="阐述Servlet和CGI的区别?"></a>阐述Servlet和CGI的区别?</h2><h3 id="CGI的不足之处"><a href="#CGI的不足之处" class="headerlink" title="CGI的不足之处:"></a>CGI的不足之处:</h3><p>1，需要为每个请求启动一个操作CGI程序的系统进程。如果请求频繁，这将会带来很大的开销。</p><p>2，需要为每个请求加载和运行一个CGI程序，这将带来很大的开销 </p><p>3，需要重复编写处理网络协议的代码以及编码，这些工作都是非常耗时的。</p><h3 id="Servlet的优点"><a href="#Servlet的优点" class="headerlink" title="Servlet的优点:"></a>Servlet的优点:</h3><p>1，只需要启动一个操作系统进程以及加载一个JVM，大大降低了系统的开销</p><p>2，如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销</p><p>3，所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量。</p><p>4，Servlet能直接和Web服务器交互，而普通的CGI程序不能。Servlet还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。</p><p>补充：Sun Microsystems公司在1996年发布Servlet技术就是为了和CGI进行竞争，Servlet是一个特殊的Java程序，一个基于Java的Web应用通常包含一个或多个Servlet类。Servlet不能够自行创建并执行，它是在Servlet容器中运行的，容器将用户的请求传递给Servlet程序，并将Servlet的响应回传给用户。通常一个Servlet会关联一个或多个JSP页面。以前CGI经常因为性能开销上的问题被诟病，然而Fast CGI早就已经解决了CGI效率上的问题，所以面试的时候大可不必信口开河的诟病CGI，事实上有很多你熟悉的网站都使用了CGI技术。</p><p>参考：《javaweb整合开发王者归来》P7</p><h2 id="Servlet接口中有哪些方法及Servlet生命周期探秘"><a href="#Servlet接口中有哪些方法及Servlet生命周期探秘" class="headerlink" title="Servlet接口中有哪些方法及Servlet生命周期探秘"></a>Servlet接口中有哪些方法及Servlet生命周期探秘</h2><p>Servlet接口定义了5个方法，其中<strong>前三个方法与Servlet生命周期相关</strong>：</p><ul><li><strong>void init(ServletConfig config) throws ServletException</strong></li><li><strong>void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException</strong></li><li><strong>void destory()</strong></li><li>java.lang.String getServletInfo()</li><li>ServletConfig getServletConfig()</li></ul><p><strong>生命周期：</strong> <strong>Web容器加载Servlet并将其实例化后，Servlet生命周期开始</strong>，容器运行其<strong>init()方法</strong>进行Servlet的初始化；请求到达时调用Servlet的<strong>service()方法</strong>，service()方法会根据需要调用与请求对应的<strong>doGet或doPost</strong>等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的<strong>destroy()方法</strong>。<strong>init方法和destory方法只会执行一次，service方法客户端每次请求Servlet都会执行</strong>。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。</p><h2 id="get和post请求的区别"><a href="#get和post请求的区别" class="headerlink" title="get和post请求的区别"></a>get和post请求的区别</h2><p>①get请求用来从服务器上获得资源，而post是用来向服务器提交数据；</p><p>②get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用”?”连接，而各个变量之间使用”&amp;”连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL；</p><p>③get传输的数据要受到URL长度限制（1024字节即256个字符）；而post可以传输大量的数据，上传文件通常要使用post方式；</p><p>④使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post；</p><p>⑤get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是”%20”。</p><p>补充：GET方式提交表单的典型应用是搜索引擎。GET方式就是被设计为查询用的。</p><h2 id="什么情况下调用doGet-和doPost"><a href="#什么情况下调用doGet-和doPost" class="headerlink" title="什么情况下调用doGet()和doPost()"></a>什么情况下调用doGet()和doPost()</h2><p>Form标签里的method的属性为get时调用doGet()，为post时调用doPost()。</p><h2 id="转发-Forward-和重定向-Redirect-的区别"><a href="#转发-Forward-和重定向-Redirect-的区别" class="headerlink" title="转发(Forward)和重定向(Redirect)的区别"></a>转发(Forward)和重定向(Redirect)的区别</h2><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p><p><strong>转发（Forword）</strong><br>通过RequestDispatcher对象的forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher可以通过HttpServletRequest 的getRequestDispatcher()方法获得。例如下面的代码就是跳转到login_success.jsp页面。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">"login_success.jsp"</span>).forward(request, response);</span><br></pre></td></tr></table></figure></p><p><strong>重定向（Redirect）</strong> 是利用服务器返回的状态吗来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过HttpServletRequestResponse的setStatus(int status)方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。 </p><ol><li><strong>从地址栏显示来说</strong></li></ol><p>forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.<br>redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.</p><ol start="2"><li><strong>从数据共享来说</strong></li></ol><p>forward:转发页面和转发到的页面可以共享request里面的数据.<br>redirect:不能共享数据.</p><ol start="3"><li><strong>从运用地方来说</strong></li></ol><p>forward:一般用于用户登陆的时候,根据角色转发到相应的模块.<br>redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等</p><ol start="4"><li>从效率来说</li></ol><p>forward:高.<br>redirect:低.</p><h2 id="自动刷新-Refresh"><a href="#自动刷新-Refresh" class="headerlink" title="自动刷新(Refresh)"></a>自动刷新(Refresh)</h2><p>自动刷新不仅可以实现一段时间之后自动跳转到另一个页面，还可以实现一段时间之后自动刷新本页面。Servlet中通过HttpServletResponse对象设置Header属性实现自动刷新例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response.setHeader(<span class="string">"Refresh"</span>,<span class="string">"1000;URL=http://localhost:8080/servlet/example.htm"</span>);</span><br></pre></td></tr></table></figure></p><p>其中1000为时间，单位为毫秒。URL指定就是要跳转的页面（如果设置自己的路径，就会实现没过一秒自动刷新本页面一次）</p><h2 id="Servlet与线程安全"><a href="#Servlet与线程安全" class="headerlink" title="Servlet与线程安全"></a>Servlet与线程安全</h2><p><strong>Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。</strong> 解决的办法是尽量不要定义name属性，而是要把name变量分别定义在doGet()和doPost()方法内。虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。<br>注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的。</p><h2 id="JSP和Servlet是什么关系"><a href="#JSP和Servlet是什么关系" class="headerlink" title="JSP和Servlet是什么关系"></a>JSP和Servlet是什么关系</h2><p>其实这个问题在上面已经阐述过了，Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。</p><h2 id="JSP工作原理"><a href="#JSP工作原理" class="headerlink" title="JSP工作原理"></a>JSP工作原理</h2><p>JSP是一种Servlet，但是与HttpServlet的工作方式不太一样。HttpServlet是先由源代码编译为class文件后部署到服务器下，为先编译后部署。而JSP则是先部署后编译。JSP会在客户端第一次请求JSP文件时被编译为HttpJspPage类（接口Servlet的一个子类）。该类会被服务器临时存放在服务器工作目录里面。下面通过实例给大家介绍。<br>工程JspLoginDemo下有一个名为login.jsp的Jsp文件，把工程第一次部署到服务器上后访问这个Jsp文件，我们发现这个目录下多了下图这两个东东。<br>.class文件便是JSP对应的Servlet。编译完毕后再运行class文件来响应客户端请求。以后客户端访问login.jsp的时候，Tomcat将不再重新编译JSP文件，而是直接调用class文件来响应客户端请求。<br><img src="https://user-gold-cdn.xitu.io/2018/3/31/1627bee073079a28?w=675&amp;h=292&amp;f=jpeg&amp;s=133553" alt="JSP工作原理"><br>由于JSP只会在客户端第一次请求的时候被编译 ，因此第一次请求JSP时会感觉比较慢，之后就会感觉快很多。如果把服务器保存的class文件删除，服务器也会重新编译JSP。</p><p>开发Web程序时经常需要修改JSP。Tomcat能够自动检测到JSP程序的改动。如果检测到JSP源代码发生了改动。Tomcat会在下次客户端请求JSP时重新编译JSP，而不需要重启Tomcat。这种自动检测功能是默认开启的，检测改动会消耗少量的时间，在部署Web应用的时候可以在web.xml中将它关掉。</p><h2 id="JSP有哪些内置对象、作用分别是什么"><a href="#JSP有哪些内置对象、作用分别是什么" class="headerlink" title="JSP有哪些内置对象、作用分别是什么"></a>JSP有哪些内置对象、作用分别是什么</h2><p><a href="http://blog.csdn.net/qq_34337272/article/details/64310849" target="_blank" rel="noopener">JSP内置对象 - CSDN博客 </a> </p><p>JSP有9个内置对象：</p><ul><li>request：封装客户端的请求，其中包含来自GET或POST请求的参数；</li><li>response：封装服务器对客户端的响应；</li><li>pageContext：通过该对象可以获取其他对象；</li><li>session：封装用户会话的对象；</li><li>application：封装服务器运行环境的对象；</li><li>out：输出服务器响应的输出流对象；</li><li>config：Web应用的配置对象；</li><li>page：JSP页面本身（相当于Java程序中的this）；</li><li>exception：封装页面抛出异常的对象。</li></ul><h2 id="Request对象的主要方法有哪些"><a href="#Request对象的主要方法有哪些" class="headerlink" title="Request对象的主要方法有哪些"></a>Request对象的主要方法有哪些</h2><ul><li>setAttribute(String name,Object)：设置名字为name的request 的参数值 </li><li>getAttribute(String name)：返回由name指定的属性值 </li><li>getAttributeNames()：返回request 对象所有属性的名字集合，结果是一个枚举的实例 </li><li>getCookies()：返回客户端的所有 Cookie 对象，结果是一个Cookie 数组 </li><li>getCharacterEncoding() ：返回请求中的字符编码方式 = getContentLength() ：返回请求的 Body的长度 </li><li>getHeader(String name) ：获得HTTP协议定义的文件头信息 </li><li>getHeaders(String name) ：返回指定名字的request Header 的所有值，结果是一个枚举的实例 </li><li>getHeaderNames() ：返回所以request Header 的名字，结果是一个枚举的实例 </li><li>getInputStream() ：返回请求的输入流，用于获得请求中的数据 </li><li>getMethod() ：获得客户端向服务器端传送数据的方法 </li><li>getParameter(String name) ：获得客户端传送给服务器端的有 name指定的参数值 </li><li>getParameterNames() ：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例 </li><li>getParameterValues(String name)：获得有name指定的参数的所有值 </li><li>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称 </li><li>getQueryString() ：获得查询字符串 </li><li>getRequestURI() ：获取发出请求字符串的客户端地址 </li><li>getRemoteAddr()：获取客户端的 IP 地址 </li><li>getRemoteHost() ：获取客户端的名字 </li><li>getSession([Boolean create]) ：返回和请求相关 Session </li><li>getServerName() ：获取服务器的名字 </li><li>getServletPath()：获取客户端所请求的脚本文件的路径 </li><li>getServerPort()：获取服务器的端口号 </li><li>removeAttribute(String name)：删除请求中的一个属性 </li></ul><h2 id="request-getAttribute-和-request-getParameter-有何区别"><a href="#request-getAttribute-和-request-getParameter-有何区别" class="headerlink" title="request.getAttribute()和 request.getParameter()有何区别"></a>request.getAttribute()和 request.getParameter()有何区别</h2><p><strong>从获取方向来看：</strong></p><p>getParameter()是获取 POST/GET 传递的参数值；</p><p>getAttribute()是获取对象容器中的数据值；</p><p><strong>从用途来看：</strong></p><p>getParameter用于客户端重定向时，即点击了链接或提交按扭时传值用，即用于在用表单或url重定向传值时接收数据用。</p><p>getAttribute用于服务器端重定向时，即在 sevlet 中使用了 forward 函数,或 struts 中使用了<br>mapping.findForward。 getAttribute 只能收到程序用 setAttribute 传过来的值。</p><p>另外，可以用 setAttribute,getAttribute 发送接收对象.而 getParameter 显然只能传字符串。<br>setAttribute 是应用服务器把这个对象放在该页面所对应的一块内存中去，当你的页面服务器重定向到另一个页面时，应用服务器会把这块内存拷贝另一个页面所对应的内存中。这样getAttribute就能取得你所设下的值，当然这种方法可以传对象。session也一样，只是对象在内存中的生命周期不一样而已。getParameter只是应用服务器在分析你送上来的 request页面的文本时，取得你设在表单或 url 重定向时的值。</p><p><strong>总结：</strong></p><p>getParameter 返回的是String,用于读取提交的表单中的值;（获取之后会根据实际需要转换为自己需要的相应类型，比如整型，日期类型啊等等）</p><p>getAttribute 返回的是Object，需进行转换,可用setAttribute 设置成任意对象，使用很灵活，可随时用</p><h2 id="include指令include的行为的区别"><a href="#include指令include的行为的区别" class="headerlink" title="include指令include的行为的区别"></a>include指令include的行为的区别</h2><p><strong>include指令：</strong> JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。 语法格式如下：<br>&lt;%@ include file=”文件相对 url 地址” %&gt;</p><p>i<strong>nclude动作：</strong> <a href="jsp:include" target="_blank" rel="noopener">jsp:include</a>动作元素用来包含静态和动态的文件。该动作把指定文件插入正在生成的页面。语法格式如下：<br>&lt;jsp:include page=”相对 URL 地址” flush=”true” /&gt;</p><h2 id="JSP九大内置对象，七大动作，三大指令"><a href="#JSP九大内置对象，七大动作，三大指令" class="headerlink" title="JSP九大内置对象，七大动作，三大指令"></a>JSP九大内置对象，七大动作，三大指令</h2><p><a href="http://blog.csdn.net/qq_34337272/article/details/64310849" target="_blank" rel="noopener">JSP九大内置对象，七大动作，三大指令总结</a></p><h2 id="讲解JSP中的四种作用域"><a href="#讲解JSP中的四种作用域" class="headerlink" title="讲解JSP中的四种作用域"></a>讲解JSP中的四种作用域</h2><p>JSP中的四种作用域包括page、request、session和application，具体来说：</p><ul><li><strong>page</strong>代表与一个页面相关的对象和属性。</li><li><strong>request</strong>代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。</li><li><strong>session</strong>代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。</li><li><strong>application</strong>代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。</li></ul><h2 id="如何实现JSP或Servlet的单线程模式"><a href="#如何实现JSP或Servlet的单线程模式" class="headerlink" title="如何实现JSP或Servlet的单线程模式"></a>如何实现JSP或Servlet的单线程模式</h2><p>对于JSP页面，可以通过page指令进行设置。<br>&lt;%@page isThreadSafe=”false”%&gt;</p><p>对于Servlet，可以让自定义的Servlet实现SingleThreadModel标识接口。</p><p>说明：如果将JSP或Servlet设置成单线程工作模式，会导致每个请求创建一个Servlet实例，这种实践将导致严重的性能问题（服务器的内存压力很大，还会导致频繁的垃圾回收），所以通常情况下并不会这么做。</p><h2 id="实现会话跟踪的技术有哪些"><a href="#实现会话跟踪的技术有哪些" class="headerlink" title="实现会话跟踪的技术有哪些"></a>实现会话跟踪的技术有哪些</h2><ol><li><strong>使用Cookie</strong></li></ol><p>向客户端发送Cookie<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cookie c =<span class="keyword">new</span> Cookie(<span class="string">"name"</span>,<span class="string">"value"</span>); <span class="comment">//创建Cookie </span></span><br><span class="line">c.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>); <span class="comment">//设置最大时效，此处设置的最大时效为一天</span></span><br><span class="line">response.addCookie(c); <span class="comment">//把Cookie放入到HTTP响应中</span></span><br></pre></td></tr></table></figure></p><p>从客户端读取Cookie<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String name =<span class="string">"name"</span>; </span><br><span class="line">Cookie[]cookies =request.getCookies(); </span><br><span class="line"><span class="keyword">if</span>(cookies !=<span class="keyword">null</span>)&#123; </span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;cookies.length;i++)&#123; </span><br><span class="line">    Cookie cookie =cookies[i]; </span><br><span class="line">    <span class="keyword">if</span>(name.equals(cookis.getName())) </span><br><span class="line">    <span class="comment">//something is here. </span></span><br><span class="line">    <span class="comment">//you can get the value </span></span><br><span class="line">    cookie.getValue(); </span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p><strong>优点:</strong> 数据可以持久保存，不需要服务器资源，简单，基于文本的Key-Value</p><p><strong>缺点:</strong> 大小受到限制，用户可以禁用Cookie功能，由于保存在本地，有一定的安全风险。</p><ol start="2"><li>URL 重写</li></ol><p>在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。 </p><p><strong>优点：</strong> 在Cookie被禁用的时候依然可以使用</p><p><strong>缺点：</strong> 必须对网站的URL进行编码，所有页面必须动态生成，不能用预先记录下来的URL进行访问。</p><p>3.隐藏的表单域<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span> =<span class="string">"session"</span> <span class="attr">value</span>=<span class="string">"..."</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>优点：</strong> Cookie被禁时可以使用</p><p><strong>缺点：</strong> 所有页面必须是表单提交之后的结果。</p><ol start="4"><li>HttpSession</li></ol><p> 在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建 HttpSession，每个用户可以访问他自己的HttpSession。可以通过HttpServletRequest对象的getSession方 法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用 HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象。与上面三种方式不同的 是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession 中的对象移到其他存储设备中，但是这样势必影响性能。添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了 Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。</p><h2 id="Cookie和Session的的区别"><a href="#Cookie和Session的的区别" class="headerlink" title="Cookie和Session的的区别"></a>Cookie和Session的的区别</h2><ol><li>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。</li><li>思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。</li><li>Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</li></ol><p>参考：</p><p><a href="https://www.zhihu.com/question/19786827/answer/28752144" target="_blank" rel="noopener">https://www.zhihu.com/question/19786827/answer/28752144</a></p><p>Cookie和Session的比较</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- MarkdownTOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#servlet总结&quot;&gt;Servlet总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#阐述servlet和cgi的区别&quot;&gt;阐述Servlet和CGI的区别?&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=
      
    
    </summary>
    
      <category term="大四" scheme="http://yoursite.com/categories/%E5%A4%A7%E5%9B%9B/"/>
    
    
      <category term="J2EE基础" scheme="http://yoursite.com/tags/J2EE%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础</title>
    <link href="http://yoursite.com/2018/09/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/09/15/Java基础知识/</id>
    <published>2018-09-15T12:32:26.417Z</published>
    <updated>2018-09-15T12:32:26.417Z</updated>
    
    <content type="html"><![CDATA[<!-- MarkdownTOC --><ul><li><a href="#1-面向对象和面向过程的区别">1. 面向对象和面向过程的区别</a><ul><li><a href="#面向过程">面向过程</a></li><li><a href="#面向对象">面向对象</a></li></ul></li><li><a href="#2-java-语言有哪些特点？">2. Java 语言有哪些特点？</a></li><li><a href="#3-什么是-jdk？什么是-jre？什么是-jvm？三者之间的联系与区别">3. 什么是 JDK？什么是 JRE？什么是 JVM？三者之间的联系与区别</a></li><li><a href="#4-什么是字节码？采用字节码的最大好处是什么？">4. 什么是字节码？采用字节码的最大好处是什么？</a><ul><li><a href="#先看下-java-中的编译器和解释器：">先看下 java 中的编译器和解释器：</a></li><li><a href="#采用字节码的好处：">采用字节码的好处：</a></li></ul></li><li><a href="#5-java和c的区别">5. Java和C++的区别</a></li><li><a href="#6-什么是-java-程序的主类？应用程序和小程序的主类有何不同？">6. 什么是 Java 程序的主类？应用程序和小程序的主类有何不同？</a></li><li><a href="#7-java-应用程序与小程序之间有那些差别？">7. Java 应用程序与小程序之间有那些差别？</a></li><li><a href="#8-字符型常量和字符串常量的区别">8. 字符型常量和字符串常量的区别</a></li><li><a href="#9-构造器-constructor-是否可被-override">9. 构造器 Constructor 是否可被 override</a></li><li><a href="#10-重载和重写的区别">10. 重载和重写的区别</a></li><li><a href="#11-java-面向对象编程三大特性封装、继承、多态">11. Java 面向对象编程三大特性:封装、继承、多态</a><ul><li><a href="#封装">封装</a></li><li><a href="#继承">继承</a></li><li><a href="#多态">多态</a></li></ul></li><li><a href="#12-string-和-stringbuffer、stringbuilder-的区别是什么？string-为什么是不可变的？">12. String 和 StringBuffer、StringBuilder 的区别是什么？String 为什么是不可变的？</a></li><li><a href="#13-自动装箱与拆箱">13.  自动装箱与拆箱</a></li><li><a href="#14-在一个静态方法内调用一个非静态成员为什么是非法的？">14. 在一个静态方法内调用一个非静态成员为什么是非法的？</a></li><li><a href="#15-在-java-中定义一个不做事且没有参数的构造方法的作用">15. 在 Java 中定义一个不做事且没有参数的构造方法的作用</a></li><li><a href="#16-import-java和javax有什么区别">16. import java和javax有什么区别</a></li><li><a href="#17-接口和抽象类的区别是什么？">17.  接口和抽象类的区别是什么？</a></li><li><a href="#18-成员变量与局部变量的区别有那些？">18.  成员变量与局部变量的区别有那些？</a></li><li><a href="#19-创建一个对象用什么运算符？对象实体与对象引用有何不同？">19. 创建一个对象用什么运算符？对象实体与对象引用有何不同？</a></li><li><a href="#20-什么是方法的返回值？返回值在类的方法里的作用是什么？">20. 什么是方法的返回值？返回值在类的方法里的作用是什么？</a></li><li><a href="#21-一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？">21. 一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？</a></li><li><a href="#22-构造方法有哪些特性？">22. 构造方法有哪些特性？</a></li><li><a href="#23-静态方法和实例方法有何不同？">23. 静态方法和实例方法有何不同？</a></li><li><a href="#24-对象的相等与指向他们的引用相等，两者有什么不同？">24. 对象的相等与指向他们的引用相等，两者有什么不同？</a></li><li><a href="#25-在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？">25. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</a></li><li><a href="#26--与-equals重要">26.  == 与 equals(重要)</a></li><li><a href="#27-hashcode-与-equals（重要）">27. hashCode 与 equals（重要）</a><ul><li><a href="#hashcode（）介绍">hashCode（）介绍</a></li><li><a href="#为什么要有-hashcode">为什么要有 hashCode</a></li><li><a href="#hashcode（）与equals（）的相关规定">hashCode（）与equals（）的相关规定</a></li></ul></li><li><a href="#28-java中的值传递和引用传递">28. Java中的值传递和引用传递</a></li><li><a href="#29-简述线程，程序、进程的基本概念。以及他们之间关系是什么？">29. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？</a></li><li><a href="#30-线程有哪些基本状态？这些状态是如何定义的">30. 线程有哪些基本状态？这些状态是如何定义的?</a></li><li><a href="#31-关于-final-关键字的一些总结">31 关于 final 关键字的一些总结</a></li><li><a href="#java基础学习书籍推荐">Java基础学习书籍推荐</a></li></ul><!-- /MarkdownTOC --><h2 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1. 面向对象和面向过程的区别"></a>1. 面向对象和面向过程的区别</h2><h3 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h3><p><strong>优点：</strong> 性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</p><p><strong>缺点：</strong> 没有面向对象易维护、易复用、易扩展</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p><strong>优点：</strong> 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</p><p><strong>缺点：</strong> 性能比面向过程低</p><h2 id="2-Java-语言有哪些特点？"><a href="#2-Java-语言有哪些特点？" class="headerlink" title="2. Java 语言有哪些特点？"></a>2. Java 语言有哪些特点？</h2><ol><li>简单易学；</li><li>面向对象（封装，继承，多态）；</li><li>平台无关性（ Java 虚拟机实现平台无关性）；</li><li>可靠性；</li><li>安全性；</li><li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li><li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li><li>编译与解释并存；</li></ol><h2 id="3-什么是-JDK？什么是-JRE？什么是-JVM？三者之间的联系与区别"><a href="#3-什么是-JDK？什么是-JRE？什么是-JVM？三者之间的联系与区别" class="headerlink" title="3. 什么是 JDK？什么是 JRE？什么是 JVM？三者之间的联系与区别"></a>3. 什么是 JDK？什么是 JRE？什么是 JVM？三者之间的联系与区别</h2><p>这几个是Java中很基本很基本的东西，但是我相信一定还有很多人搞不清楚！为什么呢？因为我们大多数时候在使用现成的编译工具以及环境的时候，并没有去考虑这些东西。</p><p><strong>JDK:</strong>  顾名思义它是给开发者提供的开发工具箱,是给程序开发者用的。它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。</p><p><strong>JRE:</strong> 普通用户而只需要安装 JRE（Java Runtime Environment）来运行 Java 程序。而程序开发者必须安装JDK来编译、调试程序。</p><p><strong>JVM：</strong> 当我们运行一个程序时，JVM 负责将字节码转换为特定机器代码，JVM 提供了内存管理/垃圾回收和安全机制等。这种独立于硬件和操作系统，正是 java 程序可以一次编写多处执行的原因。</p><p><strong>区别与联系：</strong></p><ol><li>JDK 用于开发，JRE 用于运行java程序 ；</li><li>JDK 和 JRE 中都包含 JVM ；</li><li>JVM 是 java 编程语言的核心并且具有平台独立性。</li></ol><h2 id="4-什么是字节码？采用字节码的最大好处是什么？"><a href="#4-什么是字节码？采用字节码的最大好处是什么？" class="headerlink" title="4. 什么是字节码？采用字节码的最大好处是什么？"></a>4. 什么是字节码？采用字节码的最大好处是什么？</h2><h3 id="先看下-java-中的编译器和解释器："><a href="#先看下-java-中的编译器和解释器：" class="headerlink" title="先看下 java 中的编译器和解释器： 　　"></a>先看下 java 中的编译器和解释器： 　　</h3><p>Java 中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。</p><p>编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在 Java 中，这种供虚拟机理解的代码叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。</p><p>每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java 源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了 Java 的编译与解释并存的特点。</p><p> Java 源代码—-&gt;编译器—-&gt;jvm 可执行的 Java 字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm 中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行。 </p><h3 id="采用字节码的好处："><a href="#采用字节码的好处：" class="headerlink" title="采用字节码的好处：　"></a>采用字节码的好处：　</h3><p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p><h2 id="5-Java和C-的区别"><a href="#5-Java和C-的区别" class="headerlink" title="5. Java和C++的区别"></a>5. Java和C++的区别</h2><p>我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过C++，也要记下来！</p><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li></ul><h2 id="6-什么是-Java-程序的主类？应用程序和小程序的主类有何不同？"><a href="#6-什么是-Java-程序的主类？应用程序和小程序的主类有何不同？" class="headerlink" title="6. 什么是 Java 程序的主类？应用程序和小程序的主类有何不同？"></a>6. 什么是 Java 程序的主类？应用程序和小程序的主类有何不同？</h2><p>一个程序中可以有多个类，但只能有一个类是主类。在 Java 应用程序中，这个主类是指包含 main（）方法的类。而在 Java 小程序中，这个主类是一个继承自系统类 JApplet 或 Applet 的子类。应用程序的主类不一定要求是 public 类，但小程序的主类要求必须是 public 类。主类是 Java 程序执行的入口点。</p><h2 id="7-Java-应用程序与小程序之间有那些差别？"><a href="#7-Java-应用程序与小程序之间有那些差别？" class="headerlink" title="7. Java 应用程序与小程序之间有那些差别？"></a>7. Java 应用程序与小程序之间有那些差别？</h2><p>简单说应用程序是从主线程启动(也就是 main() 方法)。applet 小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟 flash 的小游戏类似。</p><h2 id="8-字符型常量和字符串常量的区别"><a href="#8-字符型常量和字符串常量的区别" class="headerlink" title="8. 字符型常量和字符串常量的区别"></a>8. 字符型常量和字符串常量的区别</h2><ol><li>形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符</li><li>含义上: 字符常量相当于一个整形值( ASCII 值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)</li><li>占内存大小 字符常量只占一个字节 字符串常量占若干个字节(至少一个字符结束标志)</li></ol><h2 id="9-构造器-Constructor-是否可被-override"><a href="#9-构造器-Constructor-是否可被-override" class="headerlink" title="9. 构造器 Constructor 是否可被 override"></a>9. 构造器 Constructor 是否可被 override</h2><p>在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以 Constructor 也就不能被 override,但是可以 overload,所以你可以看到一个类中有多个构造函数的情况。</p><h2 id="10-重载和重写的区别"><a href="#10-重载和重写的区别" class="headerlink" title="10. 重载和重写的区别"></a>10. 重载和重写的区别</h2><p><strong>重载：</strong> 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　</p><p><strong>重写：</strong>   发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。</p><h2 id="11-Java-面向对象编程三大特性-封装、继承、多态"><a href="#11-Java-面向对象编程三大特性-封装、继承、多态" class="headerlink" title="11. Java 面向对象编程三大特性:封装、继承、多态"></a>11. Java 面向对象编程三大特性:封装、继承、多态</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p><p><strong>关于继承如下 3 点请记住：</strong></p><ol><li>子类拥有父类非 private 的属性和方法。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li></ol><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><h2 id="12-String-和-StringBuffer、StringBuilder-的区别是什么？String-为什么是不可变的？"><a href="#12-String-和-StringBuffer、StringBuilder-的区别是什么？String-为什么是不可变的？" class="headerlink" title="12. String 和 StringBuffer、StringBuilder 的区别是什么？String 为什么是不可变的？"></a>12. String 和 StringBuffer、StringBuilder 的区别是什么？String 为什么是不可变的？</h2><p><strong>可变性</strong>　</p><p>String 类中使用字符数组保存字符串，private　final　char　value[]，所以 String 对象是不可变的。StringBuilder 与 StringBuffer 都继承自AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，char[]value，这两种对象都是可变的。　　</p><p><strong>线程安全性</strong></p><p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。　　</p><p><strong>性能</strong></p><p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p><strong>对于三者使用的总结：</strong><br>如果要操作少量的数据用 = String<br>单线程操作字符串缓冲区 下操作大量数据 = StringBuilder<br>多线程操作字符串缓冲区 下操作大量数据 = StringBuffer</p><h2 id="13-自动装箱与拆箱"><a href="#13-自动装箱与拆箱" class="headerlink" title="13.  自动装箱与拆箱"></a>13.  自动装箱与拆箱</h2><p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</p><p><strong>拆箱</strong>：将包装类型转换为基本数据类型；</p><p>Integer i = 10; //装箱</p><p>int   n = i;       //拆箱</p><p>详细拆装箱参考<a href="https://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3780005.html</a></p><h2 id="14-在一个静态方法内调用一个非静态成员为什么是非法的？"><a href="#14-在一个静态方法内调用一个非静态成员为什么是非法的？" class="headerlink" title="14. 在一个静态方法内调用一个非静态成员为什么是非法的？"></a>14. 在一个静态方法内调用一个非静态成员为什么是非法的？</h2><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><h2 id="15-在-Java-中定义一个不做事且没有参数的构造方法的作用"><a href="#15-在-Java-中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="15. 在 Java 中定义一个不做事且没有参数的构造方法的作用"></a>15. 在 Java 中定义一个不做事且没有参数的构造方法的作用</h2><p>　Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。　</p><h2 id="16-import-java和javax有什么区别"><a href="#16-import-java和javax有什么区别" class="headerlink" title="16. import java和javax有什么区别"></a>16. import java和javax有什么区别</h2><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分。</p><p>所以，实际上java和javax没有区别。这都是一个名字。</p><h2 id="17-接口和抽象类的区别是什么？"><a href="#17-接口和抽象类的区别是什么？" class="headerlink" title="17.  接口和抽象类的区别是什么？"></a>17.  接口和抽象类的区别是什么？</h2><ol><li>接口的方法默认是 public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法</li><li>接口中的实例变量默认是 final 类型的，而抽象类中则不一定 </li><li>一个类可以实现多个接口，但最多只能实现一个抽象类 </li><li>一个类实现接口的话要实现接口的所有方法，而抽象类不一定 </li><li>接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li></ol><h2 id="18-成员变量与局部变量的区别有那些？"><a href="#18-成员变量与局部变量的区别有那些？" class="headerlink" title="18.  成员变量与局部变量的区别有那些？"></a>18.  成员变量与局部变量的区别有那些？</h2><ol><li>从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰；</li><li>从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存</li><li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li><li>成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被 final 修饰但没有被 static 修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。</li></ol><h2 id="19-创建一个对象用什么运算符？对象实体与对象引用有何不同？"><a href="#19-创建一个对象用什么运算符？对象实体与对象引用有何不同？" class="headerlink" title="19. 创建一个对象用什么运算符？对象实体与对象引用有何不同？"></a>19. 创建一个对象用什么运算符？对象实体与对象引用有何不同？</h2><p>new运算符，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）。</p><h2 id="20-什么是方法的返回值？返回值在类的方法里的作用是什么？"><a href="#20-什么是方法的返回值？返回值在类的方法里的作用是什么？" class="headerlink" title="20. 什么是方法的返回值？返回值在类的方法里的作用是什么？"></a>20. 什么是方法的返回值？返回值在类的方法里的作用是什么？</h2><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</p><h2 id="21-一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？"><a href="#21-一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？" class="headerlink" title="21. 一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？"></a>21. 一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？</h2><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p><h2 id="22-构造方法有哪些特性？"><a href="#22-构造方法有哪些特性？" class="headerlink" title="22. 构造方法有哪些特性？"></a>22. 构造方法有哪些特性？</h2><ol><li>名字与类名相同；</li><li>没有返回值，但不能用void声明构造函数；</li><li>生成类的对象时自动执行，无需调用。</li></ol><h2 id="23-静态方法和实例方法有何不同？"><a href="#23-静态方法和实例方法有何不同？" class="headerlink" title="23. 静态方法和实例方法有何不同？"></a>23. 静态方法和实例方法有何不同？</h2><ol><li><p>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 </p></li><li><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制.</p></li></ol><h2 id="24-对象的相等与指向他们的引用相等，两者有什么不同？"><a href="#24-对象的相等与指向他们的引用相等，两者有什么不同？" class="headerlink" title="24. 对象的相等与指向他们的引用相等，两者有什么不同？"></a>24. 对象的相等与指向他们的引用相等，两者有什么不同？</h2><p>对象的相等 比的是内存中存放的内容是否相等而引用相等 比较的是他们指向的内存地址是否相等。</p><h2 id="25-在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"><a href="#25-在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？" class="headerlink" title="25. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"></a>25. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</h2><p>帮助子类做初始化工作。</p><h2 id="26-与-equals-重要"><a href="#26-与-equals-重要" class="headerlink" title="26.  == 与 equals(重要)"></a>26.  == 与 equals(重要)</h2><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)</p><p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li><li>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li></ul><p><strong>举个例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aa==bb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">"a==b"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aEQb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</li><li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li></ul><h2 id="27-hashCode-与-equals（重要）"><a href="#27-hashCode-与-equals（重要）" class="headerlink" title="27. hashCode 与 equals（重要）"></a>27. hashCode 与 equals（重要）</h2><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p><h3 id="hashCode（）介绍"><a href="#hashCode（）介绍" class="headerlink" title="hashCode（）介绍"></a>hashCode（）介绍</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。</p><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><h3 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h3><p><strong>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</strong></p><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自《Head fist java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><h3 id="hashCode（）与equals（）的相关规定"><a href="#hashCode（）与equals（）的相关规定" class="headerlink" title="hashCode（）与equals（）的相关规定"></a>hashCode（）与equals（）的相关规定</h3><ol><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个对象分别调用equals方法都返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li><li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ol><h2 id="28-Java中的值传递和引用传递"><a href="#28-Java中的值传递和引用传递" class="headerlink" title="28. Java中的值传递和引用传递"></a>28. Java中的值传递和引用传递</h2><p><strong>值传递</strong>是指对象被值传递，意味着传递了对象的一个副本，即使副本被改变，也不会影响源对象。（因为值传递的时候，实际上是将实参的值复制一份给形参。）</p><p><strong>引用传递</strong>是指对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象的改变会反映到所有的对象上。（因为引用传递的时候，实际上是将实参的地址值复制一份给形参。）</p><h2 id="29-简述线程，程序、进程的基本概念。以及他们之间关系是什么？"><a href="#29-简述线程，程序、进程的基本概念。以及他们之间关系是什么？" class="headerlink" title="29. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？"></a>29. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？</h2><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。  </p><p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p><p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。<br>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p><h2 id="30-线程有哪些基本状态？这些状态是如何定义的"><a href="#30-线程有哪些基本状态？这些状态是如何定义的" class="headerlink" title="30. 线程有哪些基本状态？这些状态是如何定义的?"></a>30. 线程有哪些基本状态？这些状态是如何定义的?</h2><ol><li><strong>新建(new)</strong>：新创建了一个线程对象。</li><li><strong>可运行(runnable)</strong>：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。</li><li><strong>运行(running)</strong>：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。</li><li><strong>阻塞(block)</strong>：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：<br>(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waitting queue)中。<br>(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。<br>(三). 其他阻塞: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</li><li><strong>死亡(dead)</strong>：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/8/9/1651f19d7c4e93a3?w=876&amp;h=492&amp;f=png&amp;s=128092" alt=""></p><p>备注： 可以用早起坐地铁来比喻这个过程：</p><p>还没起床：sleeping </p><p>起床收拾好了，随时可以坐地铁出发：Runnable </p><p>等地铁来：Waiting </p><p>地铁来了，但要排队上地铁：I/O阻塞 </p><p>上了地铁，发现暂时没座位：synchronized阻塞 </p><p>地铁上找到座位：Running </p><p>到达目的地：Dead</p><h2 id="31-关于-final-关键字的一些总结"><a href="#31-关于-final-关键字的一些总结" class="headerlink" title="31 关于 final 关键字的一些总结"></a>31 关于 final 关键字的一些总结</h2><p>final关键字主要用在三个地方：变量、方法、类。</p><ol><li>①对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li><li>②当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。</li><li>③使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为fianl。</li></ol><h1 id="Java基础学习书籍推荐"><a href="#Java基础学习书籍推荐" class="headerlink" title="Java基础学习书籍推荐"></a>Java基础学习书籍推荐</h1><p><strong>《Head First Java.第二版》：</strong></p><p><strong>《Java核心技术卷1+卷2》：</strong></p><p><strong>《Java编程思想(第4版)》：</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- MarkdownTOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-面向对象和面向过程的区别&quot;&gt;1. 面向对象和面向过程的区别&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#面向过程&quot;&gt;面向过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#面向对象&quot;&gt;面向对象&lt;/
      
    
    </summary>
    
      <category term="大四" scheme="http://yoursite.com/categories/%E5%A4%A7%E5%9B%9B/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Spring 的高级特性和核心组件</title>
    <link href="http://yoursite.com/2018/07/29/Spring%20%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2018/07/29/Spring 的高级特性/</id>
    <published>2018-07-29T15:29:07.643Z</published>
    <updated>2018-07-29T15:27:48.555Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring-的高级特性"><a href="#Spring-的高级特性" class="headerlink" title="Spring 的高级特性"></a>Spring 的高级特性</h3><p>由于Spring特殊的依赖注入技巧，导致Bean之间没有耦合度。</p><p>但是Bean有时需要使用spring容器本身的资源，这时你的Bean必须意识到Spring容器的存在。所以得使用Spring Aware，下面来看看Spring Aware提供的接口</p><table><thead><tr><th>BeanNameAware</th><th>获得到容器中Bean的名称</th></tr></thead><tbody><tr><td>BeanFactory</td><td>获得当前的bean factory，这样可以调用容器的服务</td></tr><tr><td>ApplicationContextAware*</td><td>当前application context，这样可以调用容器的服务</td></tr><tr><td>MessageSourceAware</td><td>获得Message source</td></tr><tr><td>ApplicationEventPublisherAware</td><td>应用时间发布器，可以发布时间</td></tr><tr><td>ResourceLoaderAware</td><td>获得资源加载器，可以获得外部资源文件</td></tr></tbody></table><p><strong>@TaskExecutor</strong><br>这样可以实现多线程和并发编程。通过@EnableAsync开启对异步任务的支持，并通过实际执行的Bean的方法始中使用@Async注解来声明其是一个异步任务</p><p><strong>@Scheduled 计划任务</strong><br>首先通过在配置类注解@EnableScheduling来开启对计划任务的支持，然后在要执行计划任务的方法上注解@Scheduled，声明这是一个计划任务</p><p><strong>@Conditional</strong><br>根据满足某一个特定条件创建一个特定的Bean。</p><p><strong>组合注解与元注解</strong><br>元注解就是可以注解到别的注解上的注解，被注解的注解称之为组合注解，组合注解具备注解其上的元注解的功能。</p><p><strong>@Enable*注解的工作原理</strong><br>通过观察这些@Enable*注解的源码，我们发现所有的注解都有一个@Import注解，@Import是用来导入配置类的，这也就意外着这些自动开启的实现其实是导入了一些自动配置的Bean。这些导入配置的方式主要范围以下三种类型：</p><ul><li>第一类：直接导入配置类</li><li>第二类：依据条件选择配置类</li><li>第三类：动态注册Bean</li></ul><h3 id="Spring-框架中的核心组件"><a href="#Spring-框架中的核心组件" class="headerlink" title="Spring 框架中的核心组件"></a>Spring 框架中的核心组件</h3><p>Spring 框架中的核心组件只有三个：<strong>Core、Context</strong> 和 <strong>Bean</strong>。它们构建起了整个 Spring 的骨骼架构。没有它们就不可能有 AOP、Web 等上层的特性功能。下面也将主要从这三个组件入手分析 Spring。</p><h4 id="Spring的设计理念"><a href="#Spring的设计理念" class="headerlink" title="Spring的设计理念"></a>Spring的设计理念</h4><p>Bean在Spring的作用是非常重要的。通过一系列简单的配置来满足类与类之间的依赖关系——这叫做依赖注入。而依赖注入的关系是在一个叫IOC的容器中进行管理。</p><h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><p>我们说到Spring 框架中的核心组件只有三个：<strong>Core、Context</strong> 和 <strong>Bean</strong>。那么Core和Context是如何协作的呢？</p><p>我们知道 Bean 包装的是 Object，而 Object 必然有数据，如何给这些数据提供生存环境就是 Context 要解决的问题，对 Context 来说他就是要发现每个 Bean 之间的关系，为它们建立这种关系并且要维护好这种关系。所以 Context 就是一个 Bean 关系的集合，这个关系集合又叫 Ioc 容器 ，一旦建立起这个 Ioc 容器后 Spring 就可以为你工作了。那 Core 组件又有什么用武之地呢？其实 Core 就是发现、建立和维护每个 Bean 之间的关系所需要的一些列的工具。</p><h4 id="解析核心组件"><a href="#解析核心组件" class="headerlink" title="解析核心组件"></a>解析核心组件</h4><p><strong>Bean</strong><br>前面已经说明了 Bean 组件对 Spring 的重要性，下面看看 Bean 这个组件式怎么设计的。Bean 组件在 Spring 的 org.springframework.beans 包下。这个包下的所有类主要解决了三件事：Bean 的定义、Bean 的创建以及对 Bean 的解析。对 Spring 的使用者来说唯一需要关心的就是 Bean 的创建，其他两个由 Spring 在内部帮你完成了，对你来说是透明的。<br>Spring Bean 的创建时典型的工厂模式，他的顶级接口是 BeanFactory，下图是这个工厂的继承层次关系：<br><img src="/img/springhexin.png" alt=""></p><p>BeanFactory 有三个子类：<strong>ListableBeanFactory、HierarchicalBeanFactory</strong> 和 <strong>AutowireCapableBeanFactory。</strong>但是从上图中我们可以发现最终的默认实现类是 DefaultListableBeanFactory，他实现了所有的接口。那为何要定义这么多层次的接口呢？查阅这些接口的源码和说明发现，每个接口都有他使用的场合，它主要是为了区分在 Spring 内部在操作过程中对象的传递和转化过程中，对对象的数据访问所做的限制。例如 ListableBeanFactory 接口表示这些 Bean 是可列表的，而 HierarchicalBeanFactory 表示的是这些 Bean 是有继承关系的，也就是每个 Bean 有可能有父 Bean。AutowireCapableBeanFactory 接口定义 Bean 的自动装配规则。这四个接口共同定义了 Bean 的集合、Bean 之间的关系、以及 Bean 行为。<br><strong>Context</strong><br><strong>ApplicationContext</strong> 是 Context 的顶级父类，他除了能标识一个应用环境的基本信息外，他还继承了五个接口，这五个接口主要是扩展了 Context 的功能。下面是 Context 的类结构图：<br><img src="/img/springhexin1.png" alt=""></p><p>从上图中可以看出 ApplicationContext 继承了 BeanFactory，这也说明了 Spring 容器中运行的主体对象是 Bean，另外 ApplicationContext 继承了 ResourceLoader 接口，使得 ApplicationContext 可以访问到任何外部资源，这将在 Core 中详细说明。</p><p><strong>ApplicationContext</strong> 的子类主要包含两个方面：</p><ul><li><strong>ConfigurableApplicationContext</strong> 表示该 Context 是可修改的，也就是在构建 Context 中用户可以动态添加或修改已有的配置信息，它下面又有多个子类，其中最经常使用的是可更新的 Context，即 AbstractRefreshableApplicationContext类。</li><li><strong>WebApplicationContext</strong> 顾名思义，就是为 web 准备的 Context 他可以直接访问到 ServletContext，通常情况下，这个接口使用的少。</li></ul><p>再往下分就是按照构建 Context 的文件类型，接着就是访问 Context 的方式。这样一级一级构成了完整的 Context 等级层次。<br>总体来说 ApplicationContext 必须要完成以下几件事：</p><ul><li>标识一个应用环境</li><li>利用 BeanFactory 创建 Bean 对象</li><li>保存对象关系表</li><li>能够捕获各种事件<br><strong>Context</strong> 作为 Spring 的 IOC 容器，基本上整合了 Spring 的大部分功能，或者说是大部分功能的基础。</li></ul><p><strong>Core</strong><br>Core 组件作为 Spring 的核心组件，他其中包含了很多的关键类，其中一个重要组成部分就是定义了资源的访问方式。这种把所有资源都抽象成一个接口的方式很值得在以后的设计中拿来学习。下面就重要看一下这个部分在 Spring 的作用。<br><img src="/img/springhexin2.png" alt=""><br>从上图可以看出 Resource 接口封装了各种可能的资源类型，也就是对使用者来说屏蔽了文件类型的不同。对资源的提供者来说，如何把资源包装起来交给其他人用这也是一个问题，我们看到 Resource 接口继承了 InputStreamSource 接口，这个接口中有个 getInputStream 方法，返回的是 InputStream 类。这样所有的资源都被可以通过 InputStream 这个类来获取，所以也屏蔽了资源的提供者。另外还有一个问题就是加载资源的问题，也就是资源的加载者要统一，从上图中可以看出这个任务是由 ResourceLoader 接口完成，他屏蔽了所有的资源加载者的差异，只需要实现这个接口就可以加载所有的资源，他的默认实现是 DefaultResourceLoader。</p><p>那么， Context 和 Resource 是如何建立关系的？<br><img src="/img/springhexin3.png" alt=""><br>从上图可以看出，Context 是把资源的加载、解析和描述工作委托给了 ResourcePatternResolver 类来完成，他相当于一个接头人，他把资源的加载、解析和资源的定义整合在一起便于其他组件使用。Core 组件中还有很多类似的方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Spring-的高级特性&quot;&gt;&lt;a href=&quot;#Spring-的高级特性&quot; class=&quot;headerlink&quot; title=&quot;Spring 的高级特性&quot;&gt;&lt;/a&gt;Spring 的高级特性&lt;/h3&gt;&lt;p&gt;由于Spring特殊的依赖注入技巧，导致Bean之间没有耦合
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring 的高级特性和核心组件" scheme="http://yoursite.com/tags/Spring-%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%92%8C%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaBean</title>
    <link href="http://yoursite.com/2018/07/27/%E5%85%B3%E4%BA%8EBean/"/>
    <id>http://yoursite.com/2018/07/27/关于Bean/</id>
    <published>2018-07-27T15:26:01.048Z</published>
    <updated>2018-07-27T15:07:19.888Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于Bean"><a href="#关于Bean" class="headerlink" title="关于Bean"></a>关于Bean</h3><h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4><p>bean准备就绪之前，bean工厂执行了若干启动步骤</p><ul><li>Spring对bean进行实例化；</li><li>Spring将值和bean的引用注入到bean对应的属性中；</li><li>如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；<br>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</li><li>如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</li><li>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；</li><li>如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用init-method声明了初始化方法，该方法也会被调用；</li><li>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；</li><li>此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</li><li>如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</li></ul><p><img src="/img/spring_javabean.png" alt=""></p><h4 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h4><p>Spring定义了多种Bean作用域，可以基于这些作用域创建bean，包括：</p><p>单例（Singleton）：在整个应用中，只创建bean的一个实例。<br>原型（Prototype）：每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。<br>会话（Session）：在Web应用中，为每个会话创建一个bean实例。<br>请求（Rquest）：在Web应用中，为每个请求创建一个bean实例。<br>在默认情况下，Spring应用上下文中所有bean都是作为以单例（singleton）的形式创建的。也就是说，不管给定的一个bean被注入到其他bean多少次，每次所注入的都是同一个实例。</p><p>在大多数情况下，单例bean是很理想的方案。初始化和垃圾回收对象实例所带来的成本只留给一些小规模任务，在这些任务中，让对象保持无状态并且在应用中反复重用这些对象可能并不合理。</p><p>有时候，可能会发现，你所使用的类是易变的（mutable），它们会保持一些状态，因此重用是不安全的。在这种情况下，将class声明为单例的bean就不是什么好主意了，因为对象会被污染，稍后重用的时候会出现意想不到的问题。</p><h4 id="声明Bean"><a href="#声明Bean" class="headerlink" title="声明Bean"></a>声明Bean</h4><p>以下是声明Bean的注解：</p><p>@Component 组件，没有明确的角色<br>@Service 在业务逻辑层使用<br>@Repository 在数据访问层使用<br>@Controller 在展现层使用(MVC -&gt; Spring MVC)使用<br>在这里，可以指定bean的id名：Component(“yourBeanName”)<br>同时，Spring支持将@Named作为@Component注解的替代方案。两者之间有一些细微的差异，但是在大多数场景中，它们是可以互相替换的。</p><h3 id="关于依赖注入"><a href="#关于依赖注入" class="headerlink" title="关于依赖注入"></a>关于依赖注入</h3><h4 id="注入Bean的注解"><a href="#注入Bean的注解" class="headerlink" title="注入Bean的注解"></a>注入Bean的注解</h4><p><strong>@Autowired Spring提供的注解</strong><br>不仅仅是对象，还有在构造器上，还能用在属性的Setter方法上。</p><p>不管是构造器、Setter方法还是其他的方法，Spring都会尝试满足方法参数上所声明的依赖。假如有且只有一个bean匹配依赖需求的话，那么这个bean将会被装配进来。</p><p>如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出一个异常。为了避免异常的出现，你可以将@Autowired的required属性设置为false。</p><p>将required属性设置为false时，Spring会尝试执行自动装配，但是如果没有匹配的bean的话，Spring将会让这个bean处于未装配的状态。但是，把required属性设置为false时，你需要谨慎对待。如果在你的代码中没有进行null检查的话，这个处于未装配状态的属性有可能会出现NullPointerException。</p><p><strong>@Inject</strong>注解来源于Java依赖注入规范，该规范同时还为我们定义了@Named注解。在自动装配中，Spring同时支持@Inject和@Autowired。尽管@Inject和@Autowired之间有着一些细微的差别，但是在大多数场景下，它们都是可以互相替换的。</p><p>@Autowired 是最常见的注解之一，但在老项目中，你可能会看到这些注解，它们的作用和@Autowired 相近：</p><p><strong>@Inject</strong> 是JSR-330提供的注解<br><strong>@Resource</strong> 是JSR-250提供的注解</p><h4 id="条件化的Bean"><a href="#条件化的Bean" class="headerlink" title="条件化的Bean"></a>条件化的Bean</h4><p>假设你希望一个或多个bean只有在应用的类路径下包含特定的库时才创建。或者我们希望某个bean只有当另外某个特定的bean也声明了之后才会创建。我们还可能要求只有某个特定的环境变量设置之后，才会创建某个bean。</p><p>在Spring 4之前，很难实现这种级别的条件化配置，但是Spring 4引入了一个新的@Conditional注解，它可以用到带有@Bean注解的方法上。如果给定的条件计算结果为true，就会创建这个bean，否则的话，这个bean会被忽略。</p><p>通过ConditionContext，我们可以做到如下几点：</p><ul><li>借助getRegistry()返回的BeanDefinitionRegistry检查bean定义；</li><li>借助getBeanFactory()返回的ConfigurableListableBeanFactory检查bean是否存在，甚至探查bean的属性；</li><li>借助getEnvironment()返回的Environment检查环境变量是否存在以及它的值是什么；</li><li>读取并探查getResourceLoader()返回的ResourceLoader所加载的资源；</li><li>借助getClassLoader()返回的ClassLoader加载并检查类是否存在。<h4 id="处理自动装配的歧义性"><a href="#处理自动装配的歧义性" class="headerlink" title="处理自动装配的歧义性"></a>处理自动装配的歧义性</h4><strong>标示首选的bean</strong><br>在声明bean的时候，通过将其中一个可选的bean设置为首选（primary）bean能够避免自动装配时的歧义性。当遇到歧义性的时候，Spring将会使用首选的bean，而不是其他可选的bean。实际上，你所声明就是“最喜欢”的bean。</li></ul><p><strong>限定自动装配的bean</strong><br>设置首选bean的局限性在于@Primary无法将可选方案的范围限定到唯一一个无歧义性的选项中。它只能标示一个优先的可选方案。当首选bean的数量超过一个时，我们并没有其他的方法进一步缩小可选范围。</p><p>与之相反，Spring的限定符能够在所有可选的bean上进行缩小范围的操作，最终能够达到只有一个bean满足所规定的限制条件。如果将所有的限定符都用上后依然存在歧义性，那么你可以继续使用更多的限定符来缩小选择范围。</p><p><strong>@Qualifier</strong>注解是使用限定符的主要方式。它可以与@Autowired和@Inject协同使用，在注入的时候指定想要注入进去的是哪个bean。例如，我们想要确保要将IceCream注入到setDessert()之中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;iceCream&quot;)</span><br><span class="line">public void setDessert(Dessert dessert)&#123;</span><br><span class="line">  this.dessert = dessert;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是使用限定符的最简单的例子。为@Qualifier注解所设置的参数就是想要注入的bean的ID。所有使用@Component注解声明的类都会创建为bean，并且bean的ID为首字母变为小写的类名。因此，@Qualifier(“iceCream”)指向的是组件扫描时所创建的bean，并且这个bean是IceCream类的实例。</p><p>实际上，还有一点需要补充一下。更准确地讲，@Qualifier(“iceCream”)所引用的bean要具有String类型的“iceCream”作为限定符。如果没有指定其他的限定符的话，所有的bean都会给定一个默认的限定符，这个限定符与bean的ID相同。因此，框架会将具有“iceCream”限定符的bean注入到setDessert()方法中。这恰巧就是ID为iceCream的bean，它是IceCream类在组件扫描的时候创建的。</p><p>基于默认的bean ID作为限定符是非常简单的，但这有可能会引入一些问题。如果你重构了IceCream类，将其重命名为Gelato的话，那此时会发生什么情况呢？如果这样的话，bean的ID和默认的限定符会变为gelato，这就无法匹配setDessert()方法中的限定符。自动装配会失败。</p><p>这里的问题在于setDessert()方法上所指定的限定符与要注入的bean的名称是紧耦合的。对类名称的任意改动都会导致限定符失效。</p><h4 id="SpringEL"><a href="#SpringEL" class="headerlink" title="SpringEL"></a>SpringEL</h4><p>Value实现资源的注入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vlaue=#&#123;user&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Bean的初始化和销毁"><a href="#Bean的初始化和销毁" class="headerlink" title="Bean的初始化和销毁"></a>Bean的初始化和销毁</h4><ul><li>Java配置方式：initMethod和destoryMethod</li><li>注解：@PostConstruct和@PreDestory<h4 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h4>提供在不同的环境下使用不同的配置</li></ul><p><strong>激活Profile</strong><br>Spring在确定哪个profile处于激活状态时，需要依赖两个独立的属性：spring.profiles.active和spring.profiles.default。如果设置了spring.profiles.active属性的话，那么它的值就会用来确定哪个profile是激活的。但如果没有设置spring.profiles.active属性的话，那Spring将会查找spring.profiles.default的值。如果spring.profiles.active和spring.profiles.default均没有设置的话，那就没有激活的profile，因此只会创建那些没有定义在profile中的bean。</p><p><strong>使用profile进行测试</strong><br>当运行集成测试时，通常会希望采用与生产环境（或者是生产环境的部分子集）相同的配置进行测试。但是，如果配置中的bean定义在了profile中，那么在运行测试时，我们就需要有一种方式来启用合适的profile。</p><p>Spring提供了@ActiveProfiles注解，我们可以使用它来指定运行测试时要激活哪个profile。在集成测试时，通常想要激活的是开发环境的profile。</p><p>比如Profile(“dev”)</p><h4 id="Application-Event"><a href="#Application-Event" class="headerlink" title="Application Event"></a>Application Event</h4><p>使用Application Event可以做到Bean与Bean之间的通信</p><p>Spring的事件需要遵循如下流程：</p><ul><li>自定义事件，集成ApplicationEvent</li><li>定义事件监听器，实现ApplicationListener</li><li>使用容器发布事件</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关于Bean&quot;&gt;&lt;a href=&quot;#关于Bean&quot; class=&quot;headerlink&quot; title=&quot;关于Bean&quot;&gt;&lt;/a&gt;关于Bean&lt;/h3&gt;&lt;h4 id=&quot;Bean的生命周期&quot;&gt;&lt;a href=&quot;#Bean的生命周期&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="JavaBean" scheme="http://yoursite.com/tags/JavaBean/"/>
    
  </entry>
  
  <entry>
    <title>关于ＡＯＰ</title>
    <link href="http://yoursite.com/2018/07/27/%E5%85%B3%E4%BA%8EAOP/"/>
    <id>http://yoursite.com/2018/07/27/关于AOP/</id>
    <published>2018-07-27T15:26:01.048Z</published>
    <updated>2018-07-27T15:24:37.012Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于AOP"><a href="#关于AOP" class="headerlink" title="关于AOP"></a>关于AOP</h3><h4 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h4><p><strong>通知（Advice）</strong><br>通知定义了切面是什么以及何时使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题。它应该应用在某个方法被调用之前？之后？之前和之后都调用？还是只在方法抛出异常时调用？</p><p>Spring切面可以应用5种类型的通知：</p><ul><li><strong>前置通知（Before）：</strong>在目标方法被调用之前调用通知功能；</li><li><strong>后置通知（After）：</strong>在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li><li><strong>返回通知（After-returning）：</strong>在目标方法成功执行之后调用通知；</li><li><strong>异常通知（After-throwing）：</strong>在目标方法抛出异常后调用通知；</li><li><strong>环绕通知（Around）：</strong>通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。<br>对应注解：</li></ul><table><thead><tr><th>注解</th><th>通知</th></tr></thead><tbody><tr><td>@After</td><td>通知方法会在目标方法返回或抛出异常后调用</td></tr><tr><td>@AfterReturning</td><td>通知方法会在目标方法返回后调用</td></tr><tr><td>@AfterThrowing</td><td>通知方法会在目标方法抛出异常后调用</td></tr><tr><td>@Around</td><td>通知方法会将目标方法封装起来</td></tr><tr><td>@Before</td><td>通知方法会在目标方法调用之前执行</td></tr></tbody></table><h4 id="连接点（Join-point）"><a href="#连接点（Join-point）" class="headerlink" title="连接点（Join point）"></a>连接点（Join point）</h4><p>连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p><h4 id="切点（Pointcut）"><a href="#切点（Pointcut）" class="headerlink" title="切点（Pointcut）"></a>切点（Pointcut）</h4><p>如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了“何处” 。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。有些AOP框架允许我们创建动态的切点，可以根据运行时的决策（比如方法的参数值）来决定是否应用通知。</p><h4 id="切面（Aspect）"><a href="#切面（Aspect）" class="headerlink" title="切面（Aspect）"></a>切面（Aspect）</h4><p>通知+切点=切面</p><h4 id="引入（Introduction）"><a href="#引入（Introduction）" class="headerlink" title="引入（Introduction）"></a>引入（Introduction）</h4><p>引入允许我们向现有的类添加新方法或属性</p><h4 id="织入（Weaving）"><a href="#织入（Weaving）" class="headerlink" title="织入（Weaving）"></a>织入（Weaving）</h4><p>织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入：</p><ul><li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li><li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ 5的加载时织入（load-time weaving，LTW）就支持以这种方式织入切面。</li><li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。<h4 id="Spring对AOP的支持："><a href="#Spring对AOP的支持：" class="headerlink" title="Spring对AOP的支持："></a>Spring对AOP的支持：</h4></li><li>基于代理的经典Spring AOP；</li><li>纯POJO切面（4.x版本需要XML配置）；</li><li>@AspectJ注解驱动的切面；</li><li>注入式AspectJ切面（适用于Spring各版本）。<br>前三种都是Spring AOP实现的变体，Spring AOP构建在动态代理基础之上，因此，Spring对AOP的支持局限于方法拦截。也就是说，AspectJ才是王道。</li></ul><p>另外在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中。如下图所示，代理类封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。直到应用需要被代理的bean时，Spring才创建代理对象。 如果使用的是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean的时候，Spring才会创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入Spring AOP的切面。<br><strong>例子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Performance()&#123;</span><br><span class="line">  public void perform();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在来写一个切点表达式，这个表达式能够设置当perform()方法执行时触发通知的调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">execution(* concert.Performance.perform(..))</span><br><span class="line">//execution：在方法执行时触发</span><br><span class="line">//*：返回任意类型</span><br><span class="line">//concert.Performance：方法所属类</span><br><span class="line">//perform：方法名</span><br><span class="line">//(..)：使用任意参数</span><br><span class="line">不仅如此，还可以写的更复杂一点</span><br><span class="line">execution(* concert.Performance.perform(..)&amp;&amp;within(concert.*))</span><br><span class="line">//增加了一个与操作，当concert包下的任意类方法被调用时也会触发</span><br></pre></td></tr></table></figure><p>在切点中选择bean</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execution(*concert.Performance.perform()) and bean(&apos;woodstock&apos;)</span><br><span class="line">//限定bean id为woodstock</span><br></pre></td></tr></table></figure><p>来个完整的切面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class Audience&#123;</span><br><span class="line">  @Before(&quot;execution(**concert.Performance.perform(..))&quot;)</span><br><span class="line">  public void silenceCellPhones()&#123;</span><br><span class="line">    System.out.println(&quot;Silencing cell phones&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  @Before(&quot;execution&#123;** concert.Performance.perform&#123;..&#125;&#125;&quot;)</span><br><span class="line">  public void taskSeats()&#123;</span><br><span class="line">    System.out.println(&quot;Talking seats&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  @AfterReturning(&quot;execution&#123;** concert.Performance.perform&#123;..&#125;&#125;&quot;)</span><br><span class="line">  public void applause()&#123;</span><br><span class="line">    System.out.println(&quot;CLAP CLAP CLAP!!!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  @AfterThrowing(&quot;execution&#123;** concert.Performance.perform&#123;..&#125;&#125;&quot;)</span><br><span class="line">  public void demanRefund()&#123;</span><br><span class="line">    System.out.println(&quot;Demanding a refund&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以简化一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class Audience&#123;</span><br><span class="line">  //避免频繁使用切点表达式</span><br><span class="line">  @Pointcut(&quot;execution(** concert.Performance.perform(..))&quot;)</span><br><span class="line">  public void performance()&#123;&#125;</span><br><span class="line"> </span><br><span class="line">  @Before(&quot;performance()&quot;)</span><br><span class="line">  public void silenceCellPhones()&#123;</span><br><span class="line">    System.out.println(&quot;Silencing cell phones&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  @Before(&quot;performance()&quot;)</span><br><span class="line">  public void taskSeats()&#123;</span><br><span class="line">    System.out.println(&quot;Talking seats&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  @AfterReturning(&quot;performance()&quot;)</span><br><span class="line">  public void applause()&#123;</span><br><span class="line">    System.out.println(&quot;CLAP CLAP CLAP!!!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  @AfterThrowing(&quot;performance()&quot;)</span><br><span class="line">  public void demanRefund()&#123;</span><br><span class="line">    System.out.println(&quot;Demanding a refund&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>XML中声明切面</strong></p><table><thead><tr><th>AOP配置元素</th><th>用途</th></tr></thead><tbody><tr><td>aop:advisor</td><td>定义AOP通知器</td></tr><tr><td>aop:after</td><td>定义AOP后置通知（不管被通知的方法是否执行成功）</td></tr><tr><td>aop:after-returning</td><td>定义AOP返回通知</td></tr><tr><td>aop:after-throwing</td><td>定义AOP异常通知</td></tr><tr><td>aop:around</td><td>定义AOP环绕通知</td></tr><tr><td>aop:aspect</td><td>定义一个切面</td></tr><tr><td>aop:aspectj-autoproxy</td><td>启用@AspectJ注解驱动的切面</td></tr><tr><td>aop:before</td><td>定义一个AOP前置通知</td></tr><tr><td>aop:config</td><td>顶层的AOP配置元素。大多数的aop:*元素必须包含在aop:config元素内</td></tr><tr><td>aop:declare-parents</td><td>以透明的方式为被通知的对象引入额外的接口</td></tr><tr><td>aop:pointcut</td><td>定义一个切点</td></tr></tbody></table><p>来个栗子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Audience&#123;</span><br><span class="line">  public void silenceCellPhones()&#123;</span><br><span class="line">    System.out.println(&quot;Silencing cell phones&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  public void taskSeats()&#123;</span><br><span class="line">    System.out.println(&quot;Talking seats&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  public void applause()&#123;</span><br><span class="line">    System.out.println(&quot;CLAP CLAP CLAP!!!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  public void demandRefund()&#123;</span><br><span class="line">    System.out.println(&quot;Demanding a refund&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过XML将无注解的Audience声明为切面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">  &lt;aop:aspect ref=&quot;audience&quot;&gt;</span><br><span class="line">    &lt;aop:before</span><br><span class="line">      pointcut =&quot;execution(** concert.Performance.perform(..))&quot;</span><br><span class="line">      method=&quot;sillenceCellPhones&quot;/&gt;</span><br><span class="line">    &lt;aop:before</span><br><span class="line">      pointcut =&quot;execution(** concert.Performance.perform(..))&quot;</span><br><span class="line">      method=&quot;taskSeats&quot;/&gt;</span><br><span class="line">    &lt;aop:after-returning</span><br><span class="line">      pointcut =&quot;execution(** concert.Performance.perform(..))&quot;</span><br><span class="line">      method=&quot;applause&quot;/&gt;</span><br><span class="line">    &lt;aop:After-throwing</span><br><span class="line">        pointcut =&quot;execution(** concert.Performance.perform(..))&quot;</span><br><span class="line">        method=&quot;demanRefund&quot;/&gt;</span><br><span class="line">  &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure></p><p>AspectJ关于Spring AOP的AspectJ切点，最重要的一点就是Spring仅支持AspectJ切点指示器（pointcut designator）的一个子集。让我们回顾下，Spring是基于代理的，而某些切点表达式是与基于代理的AOP无关的。下表列出了Spring AOP所支持的AspectJ切点指示器。</p><p><strong>Spring借助AspectJ的切点表达式语言来定义Spring切面</strong></p><table><thead><tr><th>AspectJ指示器</th><th>描述</th></tr></thead><tbody><tr><td>arg()</td><td>限制连接点匹配参数为指定类型的执行方法</td></tr><tr><td>@args()</td><td>限制连接点匹配参数由指定注解标注的执行方法</td></tr><tr><td>execution()</td><td>用于匹配是连接点的执行方法</td></tr><tr><td>this()</td><td>限制连接点匹配AOP代理的bean引用为指定类型的类</td></tr><tr><td>target</td><td>限制连接点匹配目标对象为指定类型的类</td></tr><tr><td>@target()</td><td>限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类型的注解</td></tr><tr><td>within()</td><td>限制连接点匹配指定的类型</td></tr><tr><td>@within()</td><td>限制连接点匹配指定注解所标注的类型（当使用Spring AOP时，方法定义在由指定的注解所标注的类里）</td></tr><tr><td>@annotation</td><td>限定匹配带有指定注解的连接点</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关于AOP&quot;&gt;&lt;a href=&quot;#关于AOP&quot; class=&quot;headerlink&quot; title=&quot;关于AOP&quot;&gt;&lt;/a&gt;关于AOP&lt;/h3&gt;&lt;h4 id=&quot;名词介绍&quot;&gt;&lt;a href=&quot;#名词介绍&quot; class=&quot;headerlink&quot; title=&quot;名词介绍&quot;
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="AOP" scheme="http://yoursite.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>ApplicationContext容器</title>
    <link href="http://yoursite.com/2018/07/27/ApplicationContext%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2018/07/27/ApplicationContext简介/</id>
    <published>2018-07-27T15:26:01.048Z</published>
    <updated>2018-07-27T14:52:44.812Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ApplicationContext简介"><a href="#ApplicationContext简介" class="headerlink" title="ApplicationContext简介"></a>ApplicationContext简介</h3><p>Spring容器最基本的接口是BeanFactory,他负责配置、创建、管理bean，他的子接口之一：ApplicationContext,也叫做spring的上下文。ApplicationContext是BeanFactory的子接口，在web应用中，通常会用到<strong>XmlWebApplicationContext、AnnotationCofigWebApplicationContext</strong>两个实现类。</p><h4 id="ApplicationContext简介-1"><a href="#ApplicationContext简介-1" class="headerlink" title="ApplicationContext简介"></a>ApplicationContext简介</h4><p>系统创建ApplicationContext容器的时候，默认会预先初始化所有的单例的bean，调用构造器创建实例对象，然后通过set方法注入依赖的对象实例。这样的情况下，也就是说会面临着一个问题，容器在初始化的时候会有较大的性能的消耗，但是一旦初始化完成之后，程序在获取单例的bean的时候，又会获得较好的性能。<br>下面看一个简单的例子，来理解一下ApplicationContext的初始化流程。<br>创建如下的一个类。包括无参数的构造函数以及一个set方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.qgx.spring.applicationContext;</span><br><span class="line">public class Qin12 &#123;</span><br><span class="line">    private  String name;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        System.out.println(&quot;。。。。。。。。ｇｅｔ方法。。。。。。。&quot;);</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        System.out.println(&quot;。。。。。。。ｓｅｔｔｅｒ方法。。。。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Qin12() &#123;</span><br><span class="line">        System.out.println(&quot;。。。。默认构造器。。。。。。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配置文件中添加这个bean类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">         &lt;bean id=&quot;qin12&quot; class=&quot;com.qgx.spring.applicationContext.Qin12&quot;&gt;</span><br><span class="line">             &lt;property name=&quot;name&quot; value=&quot;qin12&quot;&gt;&lt;/property&gt;</span><br><span class="line">         &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p>测试类初始化ＡｐｐｌｉｃａｔｉｏｎＣｏｎｔｅｘｔ<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.qgx.spring.applicationContext;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line">public class MainTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationcontext.xml&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">。。。。默认构造器。。。。。。。。</span><br><span class="line">。。。。。。。ｓｅｔｔｅｒ方法。。。。。。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ApplicationContext简介&quot;&gt;&lt;a href=&quot;#ApplicationContext简介&quot; class=&quot;headerlink&quot; title=&quot;ApplicationContext简介&quot;&gt;&lt;/a&gt;ApplicationContext简介&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="ApplicationContext" scheme="http://yoursite.com/tags/ApplicationContext/"/>
    
  </entry>
  
  <entry>
    <title>Spring核心机制：依赖注入/控制反转</title>
    <link href="http://yoursite.com/2018/07/26/Spring%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%9A%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5_%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/"/>
    <id>http://yoursite.com/2018/07/26/Spring核心机制：依赖注入_控制反转/</id>
    <published>2018-07-26T14:57:28.019Z</published>
    <updated>2018-07-26T14:57:28.019Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring核心机制：依赖注入-控制反转"><a href="#Spring核心机制：依赖注入-控制反转" class="headerlink" title="Spring核心机制：依赖注入/控制反转"></a>Spring核心机制：依赖注入/控制反转</h3><h4 id="初涉依赖注入"><a href="#初涉依赖注入" class="headerlink" title="初涉依赖注入"></a>初涉依赖注入</h4><p>　　对于spring而言，将自己置身于spring的立场上去看，当调用方需要某一个类的时候我就为你提供这个类的实例，就是说spring负责将被依赖的这个对象赋值给调用方，那么就相当于我为调用方注入了这样的一个实例。从这方面来看是依赖注入。</p><p>　</p><h4 id="浅谈控制反转（Inversion-of-Control，IOC）"><a href="#浅谈控制反转（Inversion-of-Control，IOC）" class="headerlink" title="浅谈控制反转（Inversion of Control，IOC）"></a>浅谈控制反转（Inversion of Control，IOC）</h4><p>　我们首先先来了解一下控制二字，也就是在控制“正”转的情况下，在任何一个有请求作用的系统当中，至少需要有两个类互相配合工作，在一个入口类下使用new关键字创建另一个类的对象实例，这就好比在面向对象编程的思想下，“我“充当一个入口类，在这个入口类中，我每次吃饭的时候都要买一双一次性筷子（每一次使用都要new一次），在这样的关系下，是”我“（即调用者）每次都要”主动“去买一次性筷子（另一个类），我对筷子说你老老实实的过来我的手上，是我控制了筷子，那好，在这种控制正转的关系下，放在现实生活当中，肯定是不现实的，而且人是懒惰的，他总会去创造出更加方便自己生活的想法，更确切的做法是，买一双普通的筷子（非一次性），把他放在一个容器当中（在Spring中叫做IOC容器），你需要使用的时候就对容器说：IOC我想要用筷子（向容器发出请求），接着筷子就会”注入“到的手上，而在这个过程当中，你不再是控制方，反而演变成一名请求者（虽然本身还是调用者），依赖于容器给予你资源，控制权坐落到了容器身上，于是这就是人们俗称的控制反转。</p><h4 id="依赖注入两种方式"><a href="#依赖注入两种方式" class="headerlink" title="依赖注入两种方式"></a>依赖注入两种方式</h4><p><strong>1.设值注入</strong><br>设值注入:通过set的方式注入值.Ioc容器通过成员变量的setter方法来注入被依赖的对象，这种注入方式简单，直观，因而在spring中大量的使用。<br>下面我们采用实际的例子来体会一下：<br>假设这样的一个场景，我想打印消息，这样一件事情<br>首先定义一个MessageService的接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.qgx.spring;</span><br><span class="line"></span><br><span class="line">public interface MessageService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 消息打印</span><br><span class="line">     */</span><br><span class="line">    public void printMessage();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后实现这个接口，并实现这个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.qgx.spring;</span><br><span class="line"></span><br><span class="line">public class MessagePrinter implements MessageService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void printMessage() &#123;</span><br><span class="line">        System.out.println(&quot;输出消息&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义一个person的接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.qgx.spring;</span><br><span class="line"></span><br><span class="line">public interface Person &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 人发送消息</span><br><span class="line">     */</span><br><span class="line">    public void sendMessage();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我来实现人这个接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.qgx.spring;</span><br><span class="line"></span><br><span class="line">public class Qin12 implements Person &#123;</span><br><span class="line">    private MessageService service;</span><br><span class="line"></span><br><span class="line">    public MessageService getService() &#123;</span><br><span class="line">        return service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setService(MessageService service) &#123;</span><br><span class="line">        this.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sendMessage() &#123;</span><br><span class="line">        service.printMessage();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Spring的配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">&lt;bean id=&quot;messageService&quot; class=&quot;com.qgx.spring.MessagePrinter&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;qin12&quot; class=&quot;com.qgx.spring.Qin12&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;service&quot; ref=&quot;messageService&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p>测试类如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.qgx.spring;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class MainTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">    Person person = context.getBean(&quot;qin12&quot;,Person.class);</span><br><span class="line">    person.sendMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2.构造注入</strong></p><p>通过构造函数的方式注入。spring以反射的方式执行带指定参数的构造器，当执行带参数的构造器时就可以通过构造器的参数赋值给成员变量，完成构造注入。<br>那么现在需求变了，我需要改一些东西，下面可以注意下我主要改动了哪里：<br>在Qin12这个类中添加有参数和无参数的构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.qgx.spring;</span><br><span class="line"></span><br><span class="line">public class Qin12 implements Person &#123;</span><br><span class="line">    private MessageService service;</span><br><span class="line"></span><br><span class="line">    public Qin12(MessageService service) &#123;</span><br><span class="line">        this.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Qin12() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MessageService getService() &#123;</span><br><span class="line">        return service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setService(MessageService service) &#123;</span><br><span class="line">        this.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sendMessage() &#123;</span><br><span class="line">        service.printMessage();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Spring配置文件中，稍微改动，即将原来的设值注入换为构造注入即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">&lt;bean id=&quot;messageService&quot; class=&quot;com.qgx.spring.MessagePrinter&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;qin12&quot; class=&quot;com.qgx.spring.Qin12&quot;&gt;</span><br><span class="line">    &lt;!--&lt;property name=&quot;service&quot; ref=&quot;messageService&quot;&gt;&lt;/property&gt;--&gt;</span><br><span class="line">    &lt;!-- 构造注入 --&gt;</span><br><span class="line">    &lt;constructor-arg ref=&quot;messageService&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><h4 id="设值注入和构造注入的对比"><a href="#设值注入和构造注入的对比" class="headerlink" title="设值注入和构造注入的对比"></a>设值注入和构造注入的对比</h4><p>这两种方式，效果是一样的，注入的时机不同，设值注入是先调用无参的构造函数，创建出实例后然后调用set方法注入属性值。而构造输入是通过在调用构造函数初始化实例的同时完成了注入。</p><p><strong>设值注入的优点</strong></p><ul><li><ol><li>通过set的方式设定依赖关系显得更加直观，自然，和javabean写法类似。</li></ol></li><li><ol start="2"><li>复杂的依赖关系，采用构造注入会造成构造器过于臃肿，spring 实例化的时候同时实例化其依赖的全部实例，导致性能下降，set方式可以避免这些问题。</li></ol></li><li><ol start="3"><li>在成员变量可选的情况下，构造注入不够灵活。</li></ol></li></ul><p><strong>构造注入的优点</strong></p><p>某些特定的情况下，构造注入比设值注入好一些。</p><ul><li><ol><li>构造注入可以在构造器中决定依赖关系的注入顺序，优先依赖的优先注入，构造注入可以清楚的分清注入的顺序。</li></ol></li><li><ol start="2"><li>组件的调用者无需知道组件内部的依赖关系，符合高内聚原则。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Spring核心机制：依赖注入-控制反转&quot;&gt;&lt;a href=&quot;#Spring核心机制：依赖注入-控制反转&quot; class=&quot;headerlink&quot; title=&quot;Spring核心机制：依赖注入/控制反转&quot;&gt;&lt;/a&gt;Spring核心机制：依赖注入/控制反转&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="依赖注入/控制反转" scheme="http://yoursite.com/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>Sping 简介</title>
    <link href="http://yoursite.com/2018/07/26/Sping%20%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2018/07/26/Sping 简介/</id>
    <published>2018-07-26T14:48:32.055Z</published>
    <updated>2018-07-26T14:48:32.055Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Sping-简介"><a href="#Sping-简介" class="headerlink" title="Sping 简介"></a>Sping 简介</h3><h4 id="1、什么是Spring框架？"><a href="#1、什么是Spring框架？" class="headerlink" title="1、什么是Spring框架？"></a>1、什么是Spring框架？</h4><p>Spring是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架，从控制反转和面向切面这两个方面去了解，容器是用来盛放物品的装备，而Spring就是实现这一功能的。在开发过程当中把所需要的对象配置到Spring框架当中去，由它进行控制，由此就出现了控制反转和面向切面。控制反转就是把一个对象的生成权交给第三方，也就是Spring去完成，那么这就是定向反转。一般在应用程序当中，需要生产的对象的这一权力来转让给Spring，在应用的过程当中，到Spring里面去查找，由Spring来进行控制对象的生产。在这样的生产中，有这样一个好处，就是说什么时候生产这样的对象，或者说这个对象怎么去维护，这就是Spring去管理，而不是要我们程序当中过多的考虑这个问题，这样就减少了程序的吻合度。<br>除此之外，Spring要使用一个轻量级控制反转这个对象必须要有一个类存在，在这个过程中就叫依赖注入，我们把所需要的对象注册到Spring容器当中去，让Spring能够找到它，然后去生产它，这种方式就叫做依赖注入。面向切面的编程，大家在开发的过程中会遇到一些这样的操作，比如要进行增删改的操作，要验证你的身份，要验证你的权限，而这些方法基本上是一样的。一般的方法抽取出来配置到Spring当中去，让它以切面的这种方式去执行，这样的方式就是面向切面的程序设计。</p><h4 id="2、为什么要使用Spring？"><a href="#2、为什么要使用Spring？" class="headerlink" title="2、为什么要使用Spring？"></a>2、为什么要使用Spring？</h4><p>Spring主要两个有功能为我们的业务对象管理提供了非常便捷的方法：</p><ul><li>DI（Dependency Injection，依赖注入）(IoC)</li><li>AOP（Aspect Oriented Programming，面向切面编程）</li></ul><h4 id="Java-Bean规范"><a href="#Java-Bean规范" class="headerlink" title="Java Bean规范"></a>Java Bean规范</h4><ul><li>必须是个公有(public)类</li><li>有无参构造函数</li><li>用公共方法暴露内部成员属性(getter,setter)</li><li>实现这样规范的类，被称为Java Bean。即是一种可重用的组件。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Sping-简介&quot;&gt;&lt;a href=&quot;#Sping-简介&quot; class=&quot;headerlink&quot; title=&quot;Sping 简介&quot;&gt;&lt;/a&gt;Sping 简介&lt;/h3&gt;&lt;h4 id=&quot;1、什么是Spring框架？&quot;&gt;&lt;a href=&quot;#1、什么是Spring框架？&quot;
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring简介" scheme="http://yoursite.com/tags/Spring%E7%AE%80%E4%BB%8B/"/>
    
  </entry>
  
  <entry>
    <title>linux下搭建hexo个人博客</title>
    <link href="http://yoursite.com/2018/07/20/Linux%20%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/07/20/Linux 搭建hexo个人博客/</id>
    <published>2018-07-20T10:01:16.701Z</published>
    <updated>2018-07-20T10:01:16.701Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux-搭建hexo个人博客"><a href="#Linux-搭建hexo个人博客" class="headerlink" title="Linux 搭建hexo个人博客"></a>Linux 搭建hexo个人博客</h3><h4 id="安装需要的软件"><a href="#安装需要的软件" class="headerlink" title="安装需要的软件"></a>安装需要的软件</h4><p><strong>git</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></p><p><strong>node.js</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br></pre></td></tr></table></figure></p><p><strong>npm</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure></p><h4 id="检查是否安装成功"><a href="#检查是否安装成功" class="headerlink" title="检查是否安装成功"></a>检查是否安装成功</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure><p><strong>hexo</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p><p><strong>将node,npm命令设置全局命令：   将hexo-cli/bin/文件夹下的hexo命令设置为全局：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/bin/node</span><br><span class="line">sudo ln -s /usr/bin/npm</span><br><span class="line">hexo /usr/local/bin/hexo</span><br></pre></td></tr></table></figure></p><h4 id="创建hexo文件夹"><a href="#创建hexo文件夹" class="headerlink" title="创建hexo文件夹"></a>创建hexo文件夹</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir hexo</span><br><span class="line">cd hexo</span><br><span class="line">sudo mkdir hexo</span><br><span class="line">cd hexo</span><br><span class="line">hexo init</span><br><span class="line">sudo npm install</span><br></pre></td></tr></table></figure><h4 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo server -p 5000</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Linux-搭建hexo个人博客&quot;&gt;&lt;a href=&quot;#Linux-搭建hexo个人博客&quot; class=&quot;headerlink&quot; title=&quot;Linux 搭建hexo个人博客&quot;&gt;&lt;/a&gt;Linux 搭建hexo个人博客&lt;/h3&gt;&lt;h4 id=&quot;安装需要的软件&quot;&gt;
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="linux;hexo" scheme="http://yoursite.com/tags/linux-hexo/"/>
    
  </entry>
  
  <entry>
    <title>我的第一个Android设计第三天</title>
    <link href="http://yoursite.com/2018/07/20/Fragment%20%20%E7%9A%84%E5%B5%8C%E5%A5%97%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/07/20/Fragment  的嵌套使用/</id>
    <published>2018-07-20T09:41:52.733Z</published>
    <updated>2018-07-20T09:41:52.733Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Fragment-的嵌套使用"><a href="#Fragment-的嵌套使用" class="headerlink" title="Fragment  的嵌套使用"></a>Fragment  的嵌套使用</h3><h4 id="Fragment管理类"><a href="#Fragment管理类" class="headerlink" title="Fragment管理类"></a>Fragment管理类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package com.example.qgx.androidkeshe.Fragement;</span><br><span class="line"></span><br><span class="line">import android.support.v4.app.Fragment;</span><br><span class="line">import android.support.v4.app.FragmentManager;</span><br><span class="line">import android.support.v4.app.FragmentTransaction;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * Created by qgx on 2018/6/22.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class FragmentManagerHelper &#123;</span><br><span class="line">    private FragmentManager mFragmentManager;</span><br><span class="line">    private int mContainerViewId;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param mFragmentManager  管理类</span><br><span class="line">     * @param mContainerViewId 容器布局的id</span><br><span class="line">     */</span><br><span class="line">    public FragmentManagerHelper(FragmentManager mFragmentManager, int mContainerViewId) &#123;</span><br><span class="line">        this.mFragmentManager = mFragmentManager;</span><br><span class="line">        this.mContainerViewId = mContainerViewId;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 添加fragment</span><br><span class="line">     * @param fragment</span><br><span class="line">     */</span><br><span class="line">    public void add(Fragment fragment)&#123;</span><br><span class="line">        FragmentTransaction fragmentTransaction = mFragmentManager.beginTransaction();</span><br><span class="line"></span><br><span class="line">        fragmentTransaction.add(mContainerViewId,fragment);</span><br><span class="line">        fragmentTransaction.commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 切换显示fragment</span><br><span class="line">     * @param fragment</span><br><span class="line">     */</span><br><span class="line">    public void switchFragmnet(Fragment fragment) &#123;</span><br><span class="line">        FragmentTransaction fragmentTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">        List&lt;Fragment&gt; childFragments = mFragmentManager.getFragments();</span><br><span class="line">        for (Fragment childFragment : childFragments) &#123;</span><br><span class="line">            fragmentTransaction.hide(childFragment);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!childFragments.contains(fragment)) &#123;</span><br><span class="line">            fragmentTransaction.add(mContainerViewId, fragment);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            fragmentTransaction.show(fragment);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fragmentTransaction.commit();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>是重写Fragment的setUserVisibleHint（）方法，实现Fragment内部的懒加载机制。<br>懒加载Fragment<br>lazyLoadFragment.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">package com.example.qgx.androidkeshe.Fragement;</span><br><span class="line"></span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.support.annotation.Nullable;</span><br><span class="line">import android.support.v4.app.Fragment;</span><br><span class="line">import android.view.LayoutInflater;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.view.ViewGroup;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by qgx on 2018/6/22.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public abstract class LazyLoadFragment extends Fragment &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 视图是否已经初初始化</span><br><span class="line">     */</span><br><span class="line">    protected boolean isInit = false;</span><br><span class="line">    protected boolean isLoad = false;</span><br><span class="line">    protected final String TAG = &quot;LazyLoadFragment&quot;;</span><br><span class="line">    private View view;</span><br><span class="line">    /**</span><br><span class="line">     * 设置Fragment要显示的布局</span><br><span class="line">     *</span><br><span class="line">     * @return 布局的layoutId</span><br><span class="line">     */</span><br><span class="line">    protected abstract int setContentView();</span><br><span class="line">    public abstract void initView();</span><br><span class="line">    public abstract void setListener();</span><br><span class="line">    public abstract void initData();</span><br><span class="line">    /**</span><br><span class="line">     * 获取设置的布局</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    protected View getContentView() &#123;</span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 找出对应的控件</span><br><span class="line">     *</span><br><span class="line">     * @param id</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    protected &lt;T extends View&gt; T findViewById(int id) &#123;</span><br><span class="line">        return (T) getContentView().findViewById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 当视图初始化并且对用户可见的时候去真正的加载数据</span><br><span class="line">     */</span><br><span class="line">    protected abstract void lazyLoad();</span><br><span class="line">    /**</span><br><span class="line">     * 当视图已经对用户不可见并且加载过数据，如果需要在切换到其他页面时停止加载数据，可以调用此方法</span><br><span class="line">     */</span><br><span class="line">    protected void stopLoad() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 视图销毁的时候讲Fragment是否初始化的状态变为false</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroyView() &#123;</span><br><span class="line">        super.onDestroyView();</span><br><span class="line">        isInit = false;</span><br><span class="line">        isLoad = false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 是否可以加载数据</span><br><span class="line">     * 可以加载数据的条件：</span><br><span class="line">     * 1.视图已经初始化</span><br><span class="line">     * 2.视图对用户可见</span><br><span class="line">     */</span><br><span class="line">    private void isCanLoadData() &#123;</span><br><span class="line">        if (!isInit) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (getUserVisibleHint()) &#123;</span><br><span class="line">            lazyLoad();</span><br><span class="line">            isLoad = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (isLoad) &#123;</span><br><span class="line">                stopLoad();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 视图是否已经对用户可见，系统的方法</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void setUserVisibleHint(boolean isVisibleToUser) &#123;</span><br><span class="line">        super.setUserVisibleHint(isVisibleToUser);</span><br><span class="line">        isCanLoadData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">       view = inflater.inflate(setContentView(), container, false);</span><br><span class="line">        initView();</span><br><span class="line">        initData();</span><br><span class="line">        setListener();</span><br><span class="line">        isInit = true;</span><br><span class="line">        /**初始化的时候去加载数据**/</span><br><span class="line">        isCanLoadData();</span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Fragment-的嵌套使用&quot;&gt;&lt;a href=&quot;#Fragment-的嵌套使用&quot; class=&quot;headerlink&quot; title=&quot;Fragment  的嵌套使用&quot;&gt;&lt;/a&gt;Fragment  的嵌套使用&lt;/h3&gt;&lt;h4 id=&quot;Fragment管理类&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android 课设" scheme="http://yoursite.com/tags/Android-%E8%AF%BE%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>推荐一些有意思的东西</title>
    <link href="http://yoursite.com/2018/07/20/3dTagCloudAndroid/"/>
    <id>http://yoursite.com/2018/07/20/3dTagCloudAndroid/</id>
    <published>2018-07-20T04:10:37.825Z</published>
    <updated>2018-07-20T04:10:37.825Z</updated>
    
    <content type="html"><![CDATA[<h3 id="3dTagCloudAndroid"><a href="#3dTagCloudAndroid" class="headerlink" title="3dTagCloudAndroid"></a>3dTagCloudAndroid</h3><h4 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h4><p>TagCloudView是一个完全基于Android ViewGroup编写的控件，支持将一组View展示为一个3D球形集合，并支持全方向滚动。</p><h4 id="运行效果："><a href="#运行效果：" class="headerlink" title="运行效果："></a>运行效果：</h4><p><img src="/img/3d.gif" alt=""></p><h4 id="使用说明："><a href="#使用说明：" class="headerlink" title="使用说明："></a>使用说明：</h4><p>Android Studio / IDEA</p><p>在build.gradle中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.moxun:tagcloudlib:1.0.3&apos;</span><br></pre></td></tr></table></figure></p><p>在布局文件中引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.moxun.tagcloudlib.view.TagCloudView/&gt;</span><br></pre></td></tr></table></figure></p><p><strong>设置Adapter 继承TagsAdapter，实现以下方法</strong></p><p>public int getCount();<br><strong>返回Tag数量</strong><br>public View getView(Context context, int position, ViewGroup parent);<br><strong>返回每个Tag实例</strong><br>public Object getItem(int position);<br><strong>返回Tag数据</strong><br>public int getPopularity(int position);<br><strong>针对每个Tag返回一个权重值，该值与ThemeColor和Tag初始大小有关</strong><br>public void onThemeColorChanged(View view,int themeColor);<br><strong>Tag主题色发生变化时会回调该方法</strong></p><h4 id="定制属性"><a href="#定制属性" class="headerlink" title="定制属性"></a>定制属性</h4><table><thead><tr><th>属性</th><th style="text-align:center">xml</th><th style="text-align:center">代码</th><th>值类型</th></tr></thead><tbody><tr><td>自动滚动</td><td style="text-align:center">app:autoScrollMode</td><td style="text-align:center">setAutoScrollMode(int mode)</td><td>[disable,uniform,decelerate]</td></tr><tr><td>半径百分比</td><td style="text-align:center">app:radiusPercent</td><td style="text-align:center">setRadiusPercent(float percent)</td><td>float [0,1]</td></tr><tr><td>滚动速度</td><td style="text-align:center">app:scrollSpeed</td><td style="text-align:center">setScrollSpeed(float scrollSpeed)</td><td>float [0,+]</td></tr><tr><td>起始颜色</td><td style="text-align:center">app:lightColor</td><td style="text-align:center">setLightColor(int color)</td><td>int</td></tr><tr><td>终止颜色</td><td style="text-align:center">app:darkColor</td><td style="text-align:center">setDarkColor(int color)</td><td>int</td></tr></tbody></table><h4 id="轻松调试数据库"><a href="#轻松调试数据库" class="headerlink" title="轻松调试数据库"></a>轻松调试数据库</h4><p>日常开发中一个非常痛苦的事情，就是在需要操作数据库的项目中，需要不断的调试数据库，很多时候我们选择是导出数据库，然后使用Sqlite 可视化软件打开打开。</p><p>高端一点的使用sqlite3，然后通过命令行操作。</p><p>当然了还有个比较强大好用的工具是：facebook 的stetho。</p><p>不过我今天推荐的是另一个项目：</p><p><a href="https://github.com/amitshekhariitbhu/Android-Debug-Database" target="_blank" rel="noopener">https://github.com/amitshekhariitbhu/Android-Debug-Database</a></p><p>怎么用呢？</p><p>在我们的项目对应的module 中添加一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">debugImplementation &apos;com.amitshekhar.android:debug-db:1.0.4&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后直接运行包含数据库的项目，在手机安装成功后，在浏览器访问：</p><p><strong>你手机的 IP：8080</strong></p><p>你就可以看到如下界面：<br><img src="/img/sqlite1.png" alt=""><br>在这里，你可以执行sql 语句，查看任何表数据，甚至可以新增、修改、删除数据。<br><img src="/img/sqlite2.gif" alt=""><br>所有的操作都是直接反馈到数据库的。</p><p>此外还支持 SharedPref的直接查看与修改~</p><p>是不是非常简单！</p><p>项目支持更换端口，从多年的编程经验来看，建议设置一个别的端口号，一开始默认8080端口我就遇到了问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">debug &#123;</span><br><span class="line">resValue(&quot;string&quot;, &quot;PORT_NUMBER&quot;, &quot;9999&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，手机需要和 PC 在同一个网段；usb 连接也可以，自行参考 readme即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;3dTagCloudAndroid&quot;&gt;&lt;a href=&quot;#3dTagCloudAndroid&quot; class=&quot;headerlink&quot; title=&quot;3dTagCloudAndroid&quot;&gt;&lt;/a&gt;3dTagCloudAndroid&lt;/h3&gt;&lt;h4 id=&quot;介绍：&quot;&gt;
      
    
    </summary>
    
      <category term="杂七杂八" scheme="http://yoursite.com/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
      <category term="有意思" scheme="http://yoursite.com/tags/%E6%9C%89%E6%84%8F%E6%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot(五)</title>
    <link href="http://yoursite.com/2018/07/20/Spring%20Boot%E6%9E%84%E5%BB%BARESTful%20API%E4%B8%8E%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2018/07/20/Spring Boot构建RESTful API与单元测试/</id>
    <published>2018-07-20T04:10:37.825Z</published>
    <updated>2018-07-20T04:10:37.825Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring-Boot构建RESTful-API与单元测试"><a href="#Spring-Boot构建RESTful-API与单元测试" class="headerlink" title="Spring Boot构建RESTful API与单元测试"></a>Spring Boot构建RESTful API与单元测试</h3><ul><li>@Controller：修饰class，用来创建处理http请求的对象</li><li>@RestController：Spring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@ResponseBody，默认返回json格式。</li><li>@RequestMapping：配置url映射<br>下面我们尝试使用Spring MVC来实现一组对User对象操作的RESTful API，配合注释详细说明在Spring MVC中如何映射HTTP请求、如何传参、如何编写单元测试。</li></ul><p>RESTful API具体设计如下：<br><img src="/img/springbootrestfulapi-1.png" alt=""><br><strong>User实体定义：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123; </span><br><span class="line"> </span><br><span class="line">    private Long id; </span><br><span class="line">    private String name; </span><br><span class="line">    private Integer age; </span><br><span class="line"> </span><br><span class="line">    // 省略setter和getter </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>实现对User对象的操作接口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@RestController </span><br><span class="line">@RequestMapping(value=&quot;/users&quot;)     // 通过这里配置使下面的映射都在/users下 </span><br><span class="line">public class UserController &#123; </span><br><span class="line"> </span><br><span class="line">    // 创建线程安全的Map </span><br><span class="line">    static Map&lt;Long, User&gt; users = Collections.synchronizedMap(new HashMap&lt;Long, User&gt;()); </span><br><span class="line"> </span><br><span class="line">    @RequestMapping(value=&quot;/&quot;, method=RequestMethod.GET) </span><br><span class="line">    public List&lt;User&gt; getUserList() &#123; </span><br><span class="line">        // 处理&quot;/users/&quot;的GET请求，用来获取用户列表 </span><br><span class="line">        // 还可以通过@RequestParam从页面中传递参数来进行查询条件或者翻页信息的传递 </span><br><span class="line">        List&lt;User&gt; r = new ArrayList&lt;User&gt;(users.values()); </span><br><span class="line">        return r; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    @RequestMapping(value=&quot;/&quot;, method=RequestMethod.POST) </span><br><span class="line">    public String postUser(@ModelAttribute User user) &#123; </span><br><span class="line">        // 处理&quot;/users/&quot;的POST请求，用来创建User </span><br><span class="line">        // 除了@ModelAttribute绑定参数之外，还可以通过@RequestParam从页面中传递参数 </span><br><span class="line">        users.put(user.getId(), user); </span><br><span class="line">        return &quot;success&quot;; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    @RequestMapping(value=&quot;/&#123;id&#125;&quot;, method=RequestMethod.GET) </span><br><span class="line">    public User getUser(@PathVariable Long id) &#123; </span><br><span class="line">        // 处理&quot;/users/&#123;id&#125;&quot;的GET请求，用来获取url中id值的User信息 </span><br><span class="line">        // url中的id可通过@PathVariable绑定到函数的参数中 </span><br><span class="line">        return users.get(id); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    @RequestMapping(value=&quot;/&#123;id&#125;&quot;, method=RequestMethod.PUT) </span><br><span class="line">    public String putUser(@PathVariable Long id, @ModelAttribute User user) &#123; </span><br><span class="line">        // 处理&quot;/users/&#123;id&#125;&quot;的PUT请求，用来更新User信息 </span><br><span class="line">        User u = users.get(id); </span><br><span class="line">        u.setName(user.getName()); </span><br><span class="line">        u.setAge(user.getAge()); </span><br><span class="line">        users.put(id, u); </span><br><span class="line">        return &quot;success&quot;; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    @RequestMapping(value=&quot;/&#123;id&#125;&quot;, method=RequestMethod.DELETE) </span><br><span class="line">    public String deleteUser(@PathVariable Long id) &#123; </span><br><span class="line">        // 处理&quot;/users/&#123;id&#125;&quot;的DELETE请求，用来删除User </span><br><span class="line">        users.remove(id); </span><br><span class="line">        return &quot;success&quot;; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面针对该Controller编写测试用例验证正确性，具体如下。当然也可以通过浏览器插件等进行请求提交验证。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class) </span><br><span class="line">@SpringApplicationConfiguration(classes = MockServletContext.class) </span><br><span class="line">@WebAppConfiguration </span><br><span class="line">public class ApplicationTests &#123; </span><br><span class="line"> </span><br><span class="line">private MockMvc mvc; </span><br><span class="line"> </span><br><span class="line">@Before </span><br><span class="line">public void setUp() throws Exception &#123; </span><br><span class="line">mvc = MockMvcBuilders.standaloneSetup(new UserController()).build(); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">@Test </span><br><span class="line">public void testUserController() throws Exception &#123; </span><br><span class="line">        // 测试UserController </span><br><span class="line">RequestBuilder request = null; </span><br><span class="line"> </span><br><span class="line">// 1、get查一下user列表，应该为空 </span><br><span class="line">request = get(&quot;/users/&quot;); </span><br><span class="line">mvc.perform(request) </span><br><span class="line">.andExpect(status().isOk()) </span><br><span class="line">.andExpect(content().string(equalTo(&quot;[]&quot;))); </span><br><span class="line"> </span><br><span class="line">// 2、post提交一个user </span><br><span class="line">request = post(&quot;/users/&quot;) </span><br><span class="line">.param(&quot;id&quot;, &quot;1&quot;) </span><br><span class="line">.param(&quot;name&quot;, &quot;测试大师&quot;) </span><br><span class="line">.param(&quot;age&quot;, &quot;20&quot;); </span><br><span class="line">mvc.perform(request) </span><br><span class="line">        .andExpect(content().string(equalTo(&quot;success&quot;))); </span><br><span class="line"> </span><br><span class="line">// 3、get获取user列表，应该有刚才插入的数据 </span><br><span class="line">request = get(&quot;/users/&quot;); </span><br><span class="line">mvc.perform(request) </span><br><span class="line">.andExpect(status().isOk()) </span><br><span class="line">.andExpect(content().string(equalTo(&quot;[&#123;\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;测试大师\&quot;,\&quot;age\&quot;:20&#125;]&quot;))); </span><br><span class="line"> </span><br><span class="line">// 4、put修改id为1的user </span><br><span class="line">request = put(&quot;/users/1&quot;) </span><br><span class="line">.param(&quot;name&quot;, &quot;测试终极大师&quot;) </span><br><span class="line">.param(&quot;age&quot;, &quot;30&quot;); </span><br><span class="line">mvc.perform(request) </span><br><span class="line">.andExpect(content().string(equalTo(&quot;success&quot;))); </span><br><span class="line"> </span><br><span class="line">// 5、get一个id为1的user </span><br><span class="line">request = get(&quot;/users/1&quot;); </span><br><span class="line">mvc.perform(request) </span><br><span class="line">.andExpect(content().string(equalTo(&quot;&#123;\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;测试终极大师\&quot;,\&quot;age\&quot;:30&#125;&quot;))); </span><br><span class="line"> </span><br><span class="line">// 6、del删除id为1的user </span><br><span class="line">request = delete(&quot;/users/1&quot;); </span><br><span class="line">mvc.perform(request) </span><br><span class="line">.andExpect(content().string(equalTo(&quot;success&quot;))); </span><br><span class="line"> </span><br><span class="line">// 7、get查一下user列表，应该为空 </span><br><span class="line">request = get(&quot;/users/&quot;); </span><br><span class="line">mvc.perform(request) </span><br><span class="line">.andExpect(status().isOk()) </span><br><span class="line">.andExpect(content().string(equalTo(&quot;[]&quot;))); </span><br><span class="line"> </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们通过引入web模块（没有做其他的任何配置），就可以轻松利用Spring MVC的功能，以非常简洁的代码完成了对User对象的RESTful API的创建以及单元测试的编写。其中同时介绍了Spring MVC中最为常用的几个核心注解：<strong>@Controller,@RestController,RequestMapping</strong>以及一些参数绑定的注解：<strong>@PathVariable,@ModelAttribute,@RequestParam</strong>等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Spring-Boot构建RESTful-API与单元测试&quot;&gt;&lt;a href=&quot;#Spring-Boot构建RESTful-API与单元测试&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot构建RESTful API与单元测试&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="Spring Boot构建RESTful API与单元测试" scheme="http://yoursite.com/tags/Spring-Boot%E6%9E%84%E5%BB%BARESTful-API%E4%B8%8E%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>多线程编程</title>
    <link href="http://yoursite.com/2018/07/20/Android%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/07/20/Android 多线程编程/</id>
    <published>2018-07-20T04:10:37.825Z</published>
    <updated>2018-07-20T04:10:37.821Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android-多线程编程"><a href="#Android-多线程编程" class="headerlink" title="Android 多线程编程"></a>Android 多线程编程</h3><h4 id="一、线程的基本用法"><a href="#一、线程的基本用法" class="headerlink" title="一、线程的基本用法"></a>一、线程的基本用法</h4><p>方法一、新建一个类继承自 Thread，然后重写父类的 run() 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 处理具体的逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new MyThread().start();</span><br></pre></td></tr></table></figure></p><p> 方法二、使用继承的方式耦合性有点高，更多的时候会选择使用实现 Runnable 接口的方式来定义一个线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyThread implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 处理具体的逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyThread myThread = new MyThread();</span><br><span class="line">new Thread(myThread).start();</span><br></pre></td></tr></table></figure></p><p>方法三、或使用匿名类的方式，这种写法更为常见。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 处理具体的逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></p><h4 id="二、异步消息处理机制"><a href="#二、异步消息处理机制" class="headerlink" title="二、异步消息处理机制"></a>二、异步消息处理机制</h4><p>Android 的 UI 是线程不安全的。如果想要更新应用程序里的 UI 元素，则必须在主线程中进行，否则就会出现异常。<br>可以使用 异步消息处理机制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity implements OnClickListener &#123;</span><br><span class="line">    public static final int UPDATE_TEXT = 1;</span><br><span class="line">    private TextView text;</span><br><span class="line">    private Button changeText;</span><br><span class="line"></span><br><span class="line">    private Handler handler = new Handler() &#123;</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                case UPDATE_TEXT:</span><br><span class="line">                    // 在这里可以进行UI操作</span><br><span class="line">                    text.setText(&quot;Nice to meet you&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">......</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        switch (v.getId()) &#123;</span><br><span class="line">            case R.id.change_text:</span><br><span class="line">                new Thread(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        Message message = new Message();</span><br><span class="line">                        message.what = UPDATE_TEXT;</span><br><span class="line">                        handler.sendMessage(message); // 将Message对象发送出去</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="1-Message"><a href="#1-Message" class="headerlink" title="1. Message"></a>1. Message</h5><p>Message 是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间交换数据。上一小节中我们使用到了 Message 的 what 字段，除此之外还可以使用 <strong>arg1 </strong>和 <strong>arg2 </strong>字段来携带一些整型数据，使用 obj 字段携带一个 Object 对象。</p><h5 id="2-Handler"><a href="#2-Handler" class="headerlink" title="2. Handler"></a>2. Handler</h5><p>Handler 顾名思义也就是处理者的意思，它主要是用于发送和处理消息的。发送消息一般是使用 Handler 的 <strong>sendMessage() </strong>方法，而发出的消息经过一系列地辗转处理后，最终会传递到 Handler 的 <strong>handleMessage() </strong>方法中。</p><h5 id="3-MessageQueue"><a href="#3-MessageQueue" class="headerlink" title="3. MessageQueue"></a>3. MessageQueue</h5><p>MessageQueue 是消息队列的意思，它主要用于存放所有通过 Handler 发送的消息。这部分消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个 MessageQueue 对象。</p><h5 id="4-Looper"><a href="#4-Looper" class="headerlink" title="4. Looper"></a>4. Looper</h5><p>Looper 是每个线程中的 MessageQueue 的管家，调用 Looper 的 <strong>loop() </strong>方法后，就会进入到一个无限循环当中，然后每当发现 MessageQueue 中存在一条消息，就会将它取出，并传递到 Handler 的 handleMessage() 方法中。每个线程中也只会有一个 Looper 对象。</p><p><img src="/img/xiancheng21.png" alt=""></p><h4 id="三、使用-AsyncTask"><a href="#三、使用-AsyncTask" class="headerlink" title="三、使用 AsyncTask"></a>三、使用 AsyncTask</h4><p>不过为了更加方便我们在子线程中对 UI 进行操作，Android 还提供了另外一些好用的工具，AsyncTask 就是其中之一。借助 AsyncTask，即使你对异步消息处理机制完全不了解，也可以十分简单地从子线程切换到主线程。当然，AsyncTask 背后的实现原理也是基于异步消息处理机制的，只是 Android 帮我们做了很好的封装而已。<br>由于AsyncTask 是一个抽象类，所以如果我们想使用它，就必须要创建一个子类去继承它。在继承时我们可以为 AsyncTask 类指定三个泛型参数，这三个参数的用途如下：<br>Params<br>在执行 AsyncTask 时需要传入的参数，可用于在后台任务中使用。<br>Progress<br>后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。<br>Result<br>当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。<br>因此，一个最简单的自定义 AsyncTask 就可以写成如下方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>经常需要去重写的方法有以下四个：</p><h5 id="onPreExecute"><a href="#onPreExecute" class="headerlink" title="onPreExecute()"></a>onPreExecute()</h5><p>这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等。</p><h5 id="doInBackground-Params…"><a href="#doInBackground-Params…" class="headerlink" title="doInBackground(Params…)"></a>doInBackground(Params…)</h5><p>这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成就可以通过 return 语句来将任务的执行结果返回，如果 AsyncTask 的第三个泛型参数指定的是 Void，就可以不返回任务执行结果。注意，在这个方法中是不可以进行 UI 操作的，如果需要更新 UI 元素，比如说反馈当前任务的执行进度，可以调用 </p><h5 id="publishProgress-Progress…"><a href="#publishProgress-Progress…" class="headerlink" title="publishProgress(Progress…)"></a>publishProgress(Progress…)</h5><p> 方法来完成。</p><p>#####onProgressUpdate(Progress…)<br>当在后台任务中调用了</p><h5 id="publishProgress-Progress…-1"><a href="#publishProgress-Progress…-1" class="headerlink" title="publishProgress(Progress…)"></a>publishProgress(Progress…)</h5><p>方法后，这个方法就会很快被调用，方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对 UI 进行操作，利用参数中的数值就可以对界面元素进行相应地更新。</p><h5 id="onPostExecute-Result"><a href="#onPostExecute-Result" class="headerlink" title="onPostExecute(Result)"></a>onPostExecute(Result)</h5><p>当后台任务执行完毕并通过 return 语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些 UI 操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等。<br>因此，一个比较完整的自定义 AsyncTask 就可以写成如下方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onPreExecute() &#123;</span><br><span class="line">        progressDialog.show(); // 显示进度对话框</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Boolean doInBackground(Void... params) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                int downloadPercent = doDownload(); // 这是一个虚构的方法</span><br><span class="line">                publishProgress(downloadPercent);</span><br><span class="line">                if (downloadPercent &gt;= 100) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">             return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onProgressUpdate(Integer... values) &#123;</span><br><span class="line">        // 在这里更新下载进度</span><br><span class="line">        progressDialog.setMessage(&quot;Downloaded &quot; + values[0] + &quot;%&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onPostExecute(Boolean result) &#123;</span><br><span class="line">        progressDialog.dismiss(); // 关闭进度对话框</span><br><span class="line">        // 在这里提示下载结果</span><br><span class="line">        if (result) &#123;</span><br><span class="line">            Toast.makeText(context, &quot;Download succeeded&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Toast.makeText(context, &quot; Download failed&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new DownloadTask().execute();</span><br></pre></td></tr></table></figure></p><p>在这个 DownloadTask 中，我们在 doInBackground() 方法里去执行具体的下载任务。这个方法里的代码都是在子线程中运行的，因而不会影响到主线程的运行。注意这里虚构了一个 doDownload() 方法，这个方法用于计算当前的下载进度并返回，我们假设这个方法已经存在了。在得到了当前的下载进度后， 下面就该考虑如何把它显示到界面上了， 由于 doInBackground() 方法是在子线程中运行的，在这里肯定不能进行 UI 操作，所以我们可以调用 publishProgress() 方法并将当前的下载进度传进来，这样 onProgressUpdate() 方法就会很快被调用，在这里就可以进行UI 操作了。<br>当下载完成后，doInBackground() 方法会返回一个布尔型变量，这样 onPostExecute() 方法就会很快被调用，这个方法也是在主线程中运行的。然后在这里我们会根据下载的结果来弹出相应的 Toast 提示，从而完成整个 DownloadTask 任务。<br>简单来说，使用 AsyncTask 的诀窍就是，在 doInBackground() 方法中去执行具体的耗时任务，在 onProgressUpdate() 方法中进行 UI 操作，在 onPostExecute() 方法中执行一些任务的收尾工作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android-多线程编程&quot;&gt;&lt;a href=&quot;#Android-多线程编程&quot; class=&quot;headerlink&quot; title=&quot;Android 多线程编程&quot;&gt;&lt;/a&gt;Android 多线程编程&lt;/h3&gt;&lt;h4 id=&quot;一、线程的基本用法&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android 多线程编程" scheme="http://yoursite.com/tags/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>重识OkHttp</title>
    <link href="http://yoursite.com/2018/07/20/OkHttp%EF%BC%9A%E4%BB%8E%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E5%88%B0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/07/20/OkHttp：从深入了解到源码分析/</id>
    <published>2018-07-20T04:10:37.825Z</published>
    <updated>2018-07-20T04:10:37.825Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OkHttp：从深入了解到源码分析"><a href="#OkHttp：从深入了解到源码分析" class="headerlink" title="OkHttp：从深入了解到源码分析"></a>OkHttp：从深入了解到源码分析</h3><p>作者博客：<a href="http://www.jianshu.com/u/16925b46816d" target="_blank" rel="noopener">http://www.jianshu.com/u/16925b46816d</a></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>本文的分析基于OkHttp3.4，不展示完整的代码示例，具体可以看这个官方例子或者项目中的例子。<br><a href="https://github.com/square/okhttp/wiki/Recipes" target="_blank" rel="noopener">https://github.com/square/okhttp/wiki/Recipes</a><br>OkHttp作为square公司出品的一个网络请求框架，应该算是目前Android端最火爆的网络框架了。我公司目前的项目中采用的都是Rxjava结合Retrofit进行网络请求的处理，对于底层真正实现网络请求的OkHttp关注的不是很多。最近探究了一下OkHttp的源码，对OkHttp的使用有了一些新的认识，在此做一下总结。</p><p>###目录</p><h4 id="使用篇"><a href="#使用篇" class="headerlink" title="使用篇"></a>使用篇</h4><ul><li>OkHttp的优点</li><li><p>网络处理3要素<br>1 请求Request</p><pre><code>- 1、表单FormBody- 2、分块MultipartBody-  3、客户端OkHttpClient</code></pre><p> 2、同步请求和异步请求<br>3、其他</p><ul><li>配置响应缓存</li><li>取消请求</li><li>Response读取响应结果<br>4、总结<h4 id="分析篇"><a href="#分析篇" class="headerlink" title="分析篇"></a>分析篇</h4></li></ul></li><li>客户端完整的请求</li><li>探究源码<ul><li>Call的实现类RealCall</li><li>RealCall的enqueue( Callback callBack)</li><li>Dispatcher的enqueue</li><li>getResponseWithInterceptorChain()</li></ul></li></ul><ul><li>同步请求</li><li>总结</li></ul><h4 id="使用篇-1"><a href="#使用篇-1" class="headerlink" title="使用篇"></a>使用篇</h4><h5 id="1-OkHttp的优点"><a href="#1-OkHttp的优点" class="headerlink" title="1.OkHttp的优点"></a>1.OkHttp的优点</h5><p>OkHttp作为当前Android端最火热的网络请求框架，必然有很多的优点。</p><p>支持HTTP / 2协议，允许连接到同一个主机地址的所有请求共享Socket。这必然会提高请求效率。<br>在HTTP / 2协议不可用的情况下，通过连接池减少请求的延迟。<br>GZip透明压缩减少传输的数据包大小。<br>响应缓存，避免同一个重复的网络请求。</p><h5 id="2-网络处理3要素"><a href="#2-网络处理3要素" class="headerlink" title="2.网络处理3要素"></a>2.网络处理3要素</h5><p>对于客户端来讲，我们关注的就是把正确的请求发送到服务端并拿到结果来进行处理。在OkHttp中，我认为可以分为3个部分：</p><p><strong>请求类封装客户端发送的请求，包括请求的url，请求方法（主要是GET和POST方法），请求头标题以及请求体requestBody;</strong></p><p>响应类封装了服务器响应的数据，包括代码，消息，主体，头等。<br>OkHttpClient负责发送请求请求并通过同步或者异步的方式返回服务器的响应响应，就好比是一个浏览器。</p><p><strong>OkHttp中通过建造者模式来构建OkHttpClient，请求和响应对于客户端来讲，我们不需要过多关注响应是如何构建的，因为这个是OkHttp对响应结果进行了封装处理。我们只关注请求请求和客户端OkHttpClient如何构建即可。</strong></p><h5 id="2-1请求Request"><a href="#2-1请求Request" class="headerlink" title="2.1请求Request"></a>2.1请求Request</h5><p>请求采用建模者模式来配置url，请求方法method，header，tag和cacheControl。</p><p><strong>设置url</strong>。可以是String类型，URL类型和HttpUrl类型。最终都是用到HttpUrl类型。<br><strong>设置方法</strong>，包含get，post方法等。默认的是get方法.post方法要传RequestBody，类似的还有delete，put，patch。<br><strong>设置头</strong>，方法有addHeader（String name，String value），removeHeader（String name），header（String name，String value），headers（Headers headers）.headers（Headers headers）调用之后其它的头都会被移除，只添加这一个标题。而头（String name，String value）方法调用之后，其它与这个名称同名的标题都会被移除，只保留这一个标题。<br><strong>设置标签</strong>，设置标签可以用来取消这一请求。如果未指定标签或者标签为null，那么这个请求本身就会当做是一个标签用来被取消请求。<br><strong>设置cacheControl</strong>，这个是设置到请求头中。用来替换其它名称是“Cache-Control”的头。如果cacheControl是空的话就会移除请求头中名是“Cache-Control”的头。<br><img src="/img/okhttp1.png" alt=""></p><p>OkHttp采用POST方法向服务器发送一个请求体，在OkHttp中这个请求体是RequestBody。这个请求体可以是：</p><p><strong>字符串类型</strong><br><strong>流流类型</strong><br><strong>文件类型</strong><br><strong>表单形式的键值类型</strong><br><strong>类似Html文件上传表单的复杂请求体类型（多块请求）</strong></p><p>RequestBody有几个静态方法用于创建不同类型的请求体：<br><img src="/img/okhttp2.png" alt=""><br>最终都是相当于重写了RequestBody的两个抽象方法来写入流，如果传递流类型的参数，只要重写这两个抽象方法即可。<br><img src="/img/okhttp3.jpg" alt=""><br>例如，我们提交一个String：<br><img src="/img/okhttp4.png" alt=""><br>提交File：<br><img src="/img/okhttp5.png" alt=""><br>提交流：<br><img src="/img/okhttp6.png" alt=""><br>对于提交表单和分块请求，OkHttp提供了两个RequestBody的子类，<strong>FormBody</strong>和<strong>MultipartBody</strong></p><h5 id="2-1-1-表单FormBody"><a href="#2-1-1-表单FormBody" class="headerlink" title="2.1.1 表单FormBody"></a>2.1.1 表单FormBody</h5><p>FormBody也是采用建造者模式， 这个很简单，添加key-value形式的键值对即可。<br>添加键值对有两个方法：<br><img src="/img/okhttp7.png" alt=""><br>例如：<br><img src="/img/okhttp8.png" alt=""></p><h5 id="2-1-2-分块MultipartBody"><a href="#2-1-2-分块MultipartBody" class="headerlink" title="2.1.2 分块MultipartBody"></a>2.1.2 分块MultipartBody</h5><p>MultipartBody也是采用建造者模式，MultipartBody.Builder可以构建兼容Html文件上传表单的复杂请求体。每一部分的多块请求体都是它自身的请求体，并且可以定义它自己的请求头。如果存在的话，这些请求头用来描述这部分的请求体。例如Content-Disposition、Content-Length 和 Content-Type如果可用就会被自动添加到头。</p><p>MIME类型有：<br><img src="/img/okhttp9.png" alt=""><br>有几个主要的方法：<br><img src="/img/okhttp10.png" alt=""><br>例如提交一个图片文件：<br><img src="/img/okhttp11.png" alt=""></p><h5 id="2-2-客户端OkHttpClient"><a href="#2-2-客户端OkHttpClient" class="headerlink" title="2.2 客户端OkHttpClient"></a>2.2 客户端OkHttpClient</h5><p>OkHttpClient采用建造者模式，通过Builder可以配置连接超时时间、读写时间，是否缓存、是否重连，还可以设置各种拦截器interceptor等。<br>建议在一个App中，OkHttpClient保持一个实例。一个OkHttpClient支持一定数量的并发，请求同一个主机最大并发是5，所有的并发最大是64。这个与OkHttp中的调度器Dispatcher有关，可以设置并发数。本文不对Dispatcher进行讨论。<br><img src="/img/okhttp12.png" alt=""><br>一个例子：<br><img src="/img/okhttp13.png" alt=""><br>OkHttpClient支持单独配置，例如原来设置不同的请求时间，可以通过OkHttpClient的newBuilder()方法来重新构造一个OkHttpClient。例如：<br><img src="/img/okhttp14.png" alt=""></p><h4 id="3-同步请求和异步请求"><a href="#3-同步请求和异步请求" class="headerlink" title="3.同步请求和异步请求"></a>3.同步请求和异步请求</h4><p>上面已经讲了如何创建Request和OkHttpClient，剩下的就是发送请求并得到服务器的响应了。OkHttp发送请求可分为同步和异步。OkHttpClient首先通过Request构建一个Call，通过这个Call去执行同步或者异步请求。<br><img src="/img/okhttp15.png" alt=""><br>同步方式，调用Call的execute()方法，返回Response，会阻塞当前线程：<br><img src="/img/okhttp16.png" alt=""><br>异步方式，调用Call的enqueue(CallBack callBack)方法，会在另一个线程中返回结果。<br><img src="/img/okhttp17.png" alt=""></p><h4 id="4-其他"><a href="#4-其他" class="headerlink" title="4.其他"></a>4.其他</h4><h5 id="4-1-配置响应缓存"><a href="#4-1-配置响应缓存" class="headerlink" title="4.1 配置响应缓存"></a>4.1 配置响应缓存</h5><p>为了缓存响应，需要一个可读写并且设置大小Size的缓存目录。缓存目录需要私有，其它不信任的应用不能访问这个文件。<br>如果同时有多个缓存访问同一个缓存目录会报错。所以最好只在App中初始化一次OkHttpClient，给这个实例配置缓存，在整个App生命周期内都用这一个缓存。否则几个缓存会相互影响，导致缓存出错，引起程序崩溃。<br>响应缓存采用Http头来配置，你可以添加这样的请求头Cache-Control: max-stale=3600。 max-age指的是客户端可以接收生存期不大于指定时间（以秒为单位）的响应。<br>为了防止响应使用缓存，可以用CacheControl.FORCE_NETWORK。为了防止使用网络，采用 CacheControl.FORCE_CACHE。</p><p><strong>注意:如果使用FORCE_CACHE禁止使用网络，而响应又没有缓存存在，OkHttp会报504 Unsatisfiable Request 响应错误。</strong></p><h5 id="4-2-取消请求"><a href="#4-2-取消请求" class="headerlink" title="4.2 取消请求"></a>4.2 取消请求</h5><p>调用Call.cancel()方法可以立即取消一个网络请求。如果当前线程正在写request或者读response会报IO异常。如果不再需要网络请求，采用这种方法是比较方便的。例如在App中返回了上一页。无论是同步还是异步的请求都可以被取消。</p><h5 id="4-3-Response读取响应结果"><a href="#4-3-Response读取响应结果" class="headerlink" title="4.3 Response读取响应结果"></a>4.3 Response读取响应结果</h5><p>可以通过Response的code来判断请求是否成功，如果服务器返回的有数据，可以通过Response的body得到一个ResponseBody读取。<br>如果采用ResponseBody的string()方法会一次性把数据读取到内存中，如果数据超过1MB可能会报内存溢出，所以对于超过1MB的数据，建议采用流的方式去读取，如ResponseBody的byteStream()方法。</p><p>需要说明的是：</p><p><strong>如果ResponseBody的内容不读取的话，不会触发IO流的读取操作<br>内容读取之后，这个body需要关闭。</strong></p><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h4><p>OkHttp中的很多类都用到了建造者模式，可以根据需要灵活配置。采用建造者模式的有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient.Builder</span><br><span class="line">Request.Builder</span><br><span class="line">FormBody.Builder</span><br><span class="line">MultipartBody.Builder</span><br><span class="line">Response.Builder</span><br></pre></td></tr></table></figure></p><p>如果单独使用OkHttp进行网络请求，通常需要开发者自己再封装一下，如果不想重复造轮子，Github上面的有一些优秀开源库可以拿来使用（本文只列出star较多的几个）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hongyangAndroid/okhttputils（曾经在项目中用过）</span><br><span class="line">jeasonlzy/okhttp-OkGo</span><br><span class="line">yanzhenjie/NoHttp</span><br></pre></td></tr></table></figure></p><h3 id="分析篇-1"><a href="#分析篇-1" class="headerlink" title="分析篇"></a>分析篇</h3><h4 id="1-客户端完整的请求"><a href="#1-客户端完整的请求" class="headerlink" title="1.客户端完整的请求"></a>1.客户端完整的请求</h4><p>OkHttp发送一个请求需要4步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1  构建OkHttpClient</span><br><span class="line">2  构建Request</span><br><span class="line">3  创建一个Call</span><br><span class="line">4  执行Call的同步或者异步方法，处理响应。</span><br></pre></td></tr></table></figure></p><p>我们只以一个简单的异步get请求来举例：<br><img src="/img/okhttp18.png" alt=""><br>Request和OkHttpClient都是我们自己创建的，不再讨论了。就从这个Call来展开讨论。</p><h4 id="2-探究源码"><a href="#2-探究源码" class="headerlink" title="2.探究源码"></a>2.探究源码</h4><h5 id="2-1-Call的实现类RealCall"><a href="#2-1-Call的实现类RealCall" class="headerlink" title="2.1 Call的实现类RealCall"></a>2.1 Call的实现类RealCall</h5><p>Call是一个准备执行的请求，它是一个接口。含有一个内部接口Factory 用于生成Call。<br><img src="/img/okhttp19.png" alt=""><br>OkHttpClient实现了Call.Factory接口，所以有一个newCall方法，这个方法中干了这么个事：<br><img src="/img/okhttp20.png" alt=""><br>可以看到，返回了一个RealCall，这个RealCall是OkHttp中Call的唯一实现类。说明我们执行请求，是通过RealCall发出的。<br>在RealCall的构造方法中，我们还创建了一个拦截器RetryAndFollowUpInterceptor，通过名字我们可以猜测一下这个拦截器的作用是重试和跟进，这个负责是否断线重连和重定向，可以看到这个拦截器跟OkHttpClient有关联，我们可以在配置OkHttpClient的时候配置断线重连等，默认的都是true。</p><p><strong>在OkHttp中以Real为前缀的类，都是真正干活的类</strong></p><h5 id="2-2-RealCall的enqueue-Callback-callBack-方法"><a href="#2-2-RealCall的enqueue-Callback-callBack-方法" class="headerlink" title="2.2 RealCall的enqueue( Callback callBack)方法"></a>2.2 RealCall的enqueue( Callback callBack)方法</h5><p>OkHttpClient的newCall方法只是创建了一个RealCall，RealCall的enqueue方法传递了一个CallBack用于处理回调，那我们看看这个方法都干了些什么:<br><img src="/img/okhttp21.png" alt=""><br>从上面可以看出，同一个Call只能执行一次，否则会报错。<br>client.dispatcher()返回的是与OkHttpClient绑定的一个Dispatcher。这个Dispatcher用来管理请求的调度。在使用篇我们简单的也提到过这个类。这个类主要是用来管理异步请求的调度，同步请求中虽然也参与了，但只是简单的统计正在执行的Call并在Call执行完毕之后做相应的处理。</p><p>AsyncCall是RealCall的内部类，继承了NamedRunnable，实际上也是一个Runnable实现类。这个AsyncCall 包装了Callback。它的run()方法中最终会调用它自己的execute()方法。后面我们会讲到AsyncCall的execute()方法。<br><img src="/img/okhttp22.jpg" alt=""><br>RealCall的enqueue( Callback callBack)实际上最后调用了Dispatcher的enqueue(AsyncCall call)方法。</p><h5 id="2-3-Dispatcher的enqueue方法"><a href="#2-3-Dispatcher的enqueue方法" class="headerlink" title="2.3 Dispatcher的enqueue方法"></a>2.3 Dispatcher的enqueue方法</h5><p>Dispatcher的enqueue方法是这样的：<br><img src="/img/okhttp23.jpg" alt=""><br>这个方法中首先会判断当前正在执行的Call的数量以及访问同一个主机地址的Call的数量是否在限定范围内。Dispatcher默认的Call的并发数是64，同一个主机地址的并发数是5。这个并发数可以更改。<br>如果满足条件，就向代表当前正在执行的Call的集合中添加该Call，并且去执行它。否则就会向等待的集合中添加该Call，等待被执行。</p><p>executorService()返回的是ExecutorService对象，调用ExecutorService的execute(call)方法实际上最后调用的就是AsyncCall 的execute()方法。<br><img src="/img/okhttp24.png" alt=""><br>在这个execute()方法中，能获得返回Response，之后做回调处理，Dispatcher也会对Call进行管理。核心的方法是getResponseWithInterceptorChain()。</p><p>#####2.4 核心方法getResponseWithInterceptorChain()<br><img src="/img/okhttp25.png" alt=""><br><img src="/img/okhttp26.png" alt=""><br>在这个getResponseWithInterceptorChain()方法中，有大量的Interceptors，有开发者自己定义的Interceptor也有OkHttp自己的Interceptor。这些Interceptor都存入到了ArrayList集合，我们在这里就可以大胆猜测一下这个Interceptor应该是顺序执行的。最后创建了一个RealInterceptorChain，通过调用它的proceed(request)方法开始处理原始的request，然后我们就拿到了我们想要的Response。</p><p>RealInterceptorChain是Interceptor.Chain的实现类，看这个Real前缀就知道它干的绝对是重要的事。它是一个具体的拦截器链，我们存放在List<interceptor> interceptors集合中的拦截器之间的传递都要靠它。</interceptor></p><p>它的proceed(request)最终会调用到四个参数的重载方法：<br><img src="/img/okhttp27.png" alt=""><br>上述代码部分就是这个方法的核心，能够把Request依次传递给下一个Interceptor去处理。<br>拦截器Interceptor的设计真是很赞，每一个Interceptor在发送Request的时候只处理自己那一部分Request，然后通过RealInterceptorChain的带动传递给下一个Interceptor进行处理，最后一个Interceptor发送完请求得到服务器的响应Response，经过自己的处理之后返回给它之前的那个Interceptor进行处理，依次进行，最后一个处理完毕的Response返回给开发者用户。<br>形象一点，Interceptor就像是生产线上的工人，Request是物料，Response是产品，RealInterceptorChain是一节一节的传送带。每个工人同时负责处理自己那一部分的Request和Response，由传送带进行传递，各司其职，最后完成一件对用户来讲完美的产品。<br><img src="/img/okhttp28.png" alt=""><br>我第一次看OkHttp3.4源码的的时候真是一脸懵逼继而叹为观止。后来看了其它文章，才知道原来这个设计模式叫作责任链模式。在Android源码设计模式解析与实战这本书中介绍了Android的事件分发处理采用的也是责任链模式。</p><p>具体到每个拦截器都是怎么处理Request和Response的，最好自己去看一下，我们就不展开讨论了。</p><h4 id="3-同步请求"><a href="#3-同步请求" class="headerlink" title="3.同步请求"></a>3.同步请求</h4><p>看了异步请求的调用，同步请求的分析就比较简单最终调用的是getResponseWithInterceptorChain()这个核心方法。<br><img src="/img/okhttp29.png" alt=""><br>4.总结</p><p>本文对OkHttp一个完整的请求过程做了简单的说明，限于篇幅有些地方讲的不是很详细，有兴趣的读者可以自己去探索一下这个流程，尤其是在拦截器那一部分，掌握好了之后对我们平时灵活运用OkHttp会有很大帮助，如配置我们自定义的缓存拦截器，或者在拦截器中监听下载进度，网上也有很多文章可供参考。</p><p><strong>参考:<br>OkHttp官方Wiki文档<br>从OKHttp框架看代码设计<br>拆轮子系列：拆 OkHttp</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;OkHttp：从深入了解到源码分析&quot;&gt;&lt;a href=&quot;#OkHttp：从深入了解到源码分析&quot; class=&quot;headerlink&quot; title=&quot;OkHttp：从深入了解到源码分析&quot;&gt;&lt;/a&gt;OkHttp：从深入了解到源码分析&lt;/h3&gt;&lt;p&gt;作者博客：&lt;a hr
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="OkHttp" scheme="http://yoursite.com/tags/OkHttp/"/>
    
  </entry>
  
  <entry>
    <title>初识RecyclerView</title>
    <link href="http://yoursite.com/2018/07/20/RecyclerView/"/>
    <id>http://yoursite.com/2018/07/20/RecyclerView/</id>
    <published>2018-07-20T04:10:37.825Z</published>
    <updated>2018-07-20T04:10:37.825Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="1-使用前需要在在gradle中添加依赖"><a href="#1-使用前需要在在gradle中添加依赖" class="headerlink" title="1.使用前需要在在gradle中添加依赖"></a>1.使用前需要在在gradle中添加依赖</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;com.android.support:recyclerview-v7:27.0.2&apos;</span><br></pre></td></tr></table></figure><h5 id="2-编写代码，首先我们需要在Xml中写RecyclerView的布局"><a href="#2-编写代码，首先我们需要在Xml中写RecyclerView的布局" class="headerlink" title="2.编写代码，首先我们需要在Xml中写RecyclerView的布局"></a>2.编写代码，首先我们需要在Xml中写RecyclerView的布局</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.v7.widget.RecyclerView     </span><br><span class="line">android:id=&quot;@+id/recyclerView&quot;       </span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;/&gt;</span><br></pre></td></tr></table></figure><p>然后在activity中获取RecyclerView，并设置LayoutManager以及adapter</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//通过findViewById拿到RecyclerView实例</span><br><span class="line">mRecyclerView =   findViewById(R.id.recyclerView);</span><br><span class="line">//设置RecyclerView管理器</span><br><span class="line">mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false));</span><br><span class="line">//初始化适配器</span><br><span class="line">mAdapter = new MyRecyclerViewAdapter(list); </span><br><span class="line">//设置添加或删除item时的动画，这里使用默认动画</span><br><span class="line">mRecyclerView.setItemAnimator(new DefaultItemAnimator());</span><br><span class="line">//设置适配器</span><br><span class="line">mRecyclerView.setAdapter(mAdapter);</span><br></pre></td></tr></table></figure><p>下面是MyRecyclerViewAdapter的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class MyRecyclerViewAdapter extends RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt; &#123;</span><br><span class="line">    private List&lt;String&gt; list;</span><br><span class="line">    //初始化适配器</span><br><span class="line">    public MyAdapter(List&lt;String&gt; list) &#123;</span><br><span class="line">        this.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public MyAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</span><br><span class="line">        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_base_use, parent, false);</span><br><span class="line">        MyAdapter.ViewHolder viewHolder = new MyAdapter.ViewHolder(view);</span><br><span class="line">        return viewHolder;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void onBindViewHolder(MyAdapter.ViewHolder holder, int position) &#123;</span><br><span class="line">        holder.mText.setText(list.get(position));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public int getItemCount() &#123;</span><br><span class="line">        return list.size();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    class ViewHolder extends RecyclerView.ViewHolder &#123;</span><br><span class="line">        TextView mText;</span><br><span class="line">        ViewHolder(View itemView) &#123;</span><br><span class="line">            super(itemView);</span><br><span class="line">            mText = itemView.findViewById(R.id.item_tx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里item_normal的布局也非常简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/item_tx&quot;</span><br><span class="line">        android:layout_width=&quot;match_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:gravity=&quot;center&quot;</span><br><span class="line">        android:padding=&quot;10dp&quot;</span><br><span class="line">        android:layout_gravity=&quot;center_horizontal&quot;</span><br><span class="line">        android:text=&quot;Item&quot;/&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/img/R1.png" alt=""><br>从例子也可以看出来，RecyclerView的用法并不比ListView复杂，反而更灵活好用，它将数据、排列方式、数据的展示方式都分割开来，因此可定制型，自定义的形式也非常多，非常灵活。<br><strong>设置横向布局：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false));</span><br></pre></td></tr></table></figure></p><p><img src="/img/R2.png" alt=""><br><strong>设置网格布局：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mRecyclerView.setLayoutManager(new GridLayoutManager(this, 3));</span><br></pre></td></tr></table></figure></p><p> <img src="/img/R3.png" alt=""><br> <strong>设置瀑布流：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mRecyclerView.setLayoutManager(new StaggeredGridLayoutManager(3,StaggeredGridLayoutManager.VERTICAL));</span><br></pre></td></tr></table></figure></p><p> <img src="/img/R4.png" alt=""><br> 如果第二个参数可以设置为横向的，则效果如下：<br>  <img src="/img/R5.png" alt=""><br>  以上可知，我们可以通过设置不同的管理器，实现不同的效果</p><p><strong>LinearLayoutManager</strong>：以线性布局展示，可以设置横向和纵向<br><strong>GridLayoutManager</strong>：以网格形式展示，类似GridView效果<br><strong>StaggeredGridLayoutManager</strong>：以瀑布流形式的效果</p><p>RecyclerView条目之间默认没有分割线，那是否可以像ListView一样设置divider以及dividerHight搞一条分割线出来呢，答案是不可以的，google并没有提供这样的属性。但是谷歌为我们提供了可以定制的解决办法，那就是以下要说ItemDecoration</p><h4 id="利用ItemDecoration实现条目分割线"><a href="#利用ItemDecoration实现条目分割线" class="headerlink" title="利用ItemDecoration实现条目分割线"></a>利用ItemDecoration实现条目分割线</h4><p>ItemDecoration是谷歌定义的可用于画分割线的类， 是抽象的，需要我们自己去实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public abstract static class ItemDecoration &#123;</span><br><span class="line">       public void onDraw(Canvas c, RecyclerView parent, State state) &#123;</span><br><span class="line">           onDraw(c, parent);</span><br><span class="line">       &#125;</span><br><span class="line">       @Deprecated</span><br><span class="line">       public void onDraw(Canvas c, RecyclerView parent) &#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public void onDrawOver(Canvas c, RecyclerView parent, State state) &#123;</span><br><span class="line">           onDrawOver(c, parent);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       @Deprecated</span><br><span class="line">       public void onDrawOver(Canvas c, RecyclerView parent) &#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       @Deprecated</span><br><span class="line">       public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) &#123;</span><br><span class="line">           outRect.set(0, 0, 0, 0);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state) &#123;</span><br><span class="line">           getItemOffsets(outRect, ((LayoutParams) view.getLayoutParams()).getViewLayoutPosition(),</span><br><span class="line">                   parent);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>当我们通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mRecyclerView.addItemDecoration();</span><br></pre></td></tr></table></figure></p><p><strong>onDraw:</strong>  该方法可以在RecyclerView的画布上画任何装饰，且是在 the item views 被绘制之前回调<br> <strong>onDrawOver:</strong> 该方法可以在RecyclerView的画布上画任何装饰，且是在 the item views 被绘制之后回调<br><strong>getItemOffsets :</strong> 可以在该方法中为the item views添加偏移量</p><p>下面我们可以就通过继承ItemDecoration为RecyclerView添加分割线。<br>DividerItemDecoration的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"> public class DividerItemDecoration extends RecyclerView.ItemDecoration &#123;</span><br><span class="line">    @OrientationType</span><br><span class="line">    private int mOrientation = LinearLayoutManager.VERTICAL;</span><br><span class="line">    private Drawable mDivider;</span><br><span class="line"> </span><br><span class="line">    private int[] attrs = new int[]&#123;</span><br><span class="line">            android.R.attr.listDivider</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    public DividerItemDecoration(Context context, @OrientationType int orientation) &#123;</span><br><span class="line">        TypedArray typedArray = context.obtainStyledAttributes(attrs);</span><br><span class="line">        mDivider = typedArray.getDrawable(0);</span><br><span class="line">        typedArray.recycle();</span><br><span class="line">        setOrientation(orientation);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private void setOrientation(@OrientationType int orientation) &#123;</span><br><span class="line">        if (orientation != LinearLayoutManager.VERTICAL &amp;&amp; orientation != LinearLayoutManager.HORIZONTAL) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;传入的布局类型不合法&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.mOrientation = orientation;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123;</span><br><span class="line">        //调用这个绘制方法，RecyclerView会回调该绘制方法，需要我们自己去绘制条目的间隔线</span><br><span class="line">        if (mOrientation == LinearLayoutManager.VERTICAL) &#123;</span><br><span class="line">            //垂直</span><br><span class="line">            drawVertical(c, parent);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //水平</span><br><span class="line">            drawHorizontal(c, parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private void drawVertical(Canvas c, RecyclerView parent) &#123;</span><br><span class="line">        // 画水平线</span><br><span class="line">        int left = parent.getPaddingLeft();</span><br><span class="line">        int right = parent.getWidth() - parent.getPaddingRight();</span><br><span class="line">        int childCount = parent.getChildCount();</span><br><span class="line">        for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">            View child = parent.getChildAt(i);</span><br><span class="line"> </span><br><span class="line">            RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();</span><br><span class="line">            int top = child.getBottom() + params.bottomMargin + Math.round(ViewCompat.getTranslationY(child));</span><br><span class="line">            int bottom = top + mDivider.getIntrinsicHeight();</span><br><span class="line">            mDivider.setBounds(left, top, right, bottom);</span><br><span class="line">            mDivider.draw(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private void drawHorizontal(Canvas c, RecyclerView parent) &#123;</span><br><span class="line">        int top = parent.getPaddingTop();</span><br><span class="line">        int bottom = parent.getHeight() - parent.getPaddingBottom();</span><br><span class="line">        int childCount = parent.getChildCount();</span><br><span class="line">        for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">            View child = parent.getChildAt(i);</span><br><span class="line"> </span><br><span class="line">            RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();</span><br><span class="line">            int left = child.getRight() + params.rightMargin + Math.round(ViewCompat.getTranslationX(child));</span><br><span class="line">            int right = left + mDivider.getIntrinsicHeight();</span><br><span class="line">            mDivider.setBounds(left, top, right, bottom);</span><br><span class="line">            mDivider.draw(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123;</span><br><span class="line">        //获得条目的偏移量（所有的条目都会回调一次该方法）</span><br><span class="line">        if (mOrientation == LinearLayoutManager.VERTICAL) &#123;</span><br><span class="line">            //垂直</span><br><span class="line">            outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //水平</span><br><span class="line">            outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @IntDef(&#123;LinearLayoutManager.VERTICAL, LinearLayoutManager.HORIZONTAL&#125;)</span><br><span class="line">    public @interface OrientationType &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在activity设置<strong>水平方向:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false); </span><br><span class="line">mRecyclerView.addItemDecoration(new DividerItemDecoration(this, LinearLayoutManager.VERTICAL));</span><br></pre></td></tr></table></figure></p><p><img src="/img/R6.png" alt=""><br><strong>竖直方向：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.HORIZONAL, false); </span><br><span class="line">mRecyclerView.addItemDecoration(new DividerItemDecoration(this, LinearLayoutManager.HORIZONAL));</span><br></pre></td></tr></table></figure></p><p>这里的分割线是默认的，我们可以在主题中去设置分割线的颜色<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Base application theme. --&gt;</span><br><span class="line">   &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt;</span><br><span class="line">       &lt;!-- Customize your theme here. --&gt;</span><br><span class="line">       &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;</span><br><span class="line">       &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;</span><br><span class="line">       &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;</span><br><span class="line">       &lt;item name=&quot;android:listDivider&quot;&gt;@drawable/bg_recyclerview_divider&lt;/item&gt;</span><br><span class="line">   &lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p><strong>bg_recyclerview_divider.xml</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">       android:shape=&quot;rectangle&quot;&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;gradient</span><br><span class="line">        android:centerColor=&quot;#ff00ff00&quot;</span><br><span class="line">        android:endColor=&quot;#ff0000ff&quot;</span><br><span class="line">        android:startColor=&quot;#ffff0000&quot;</span><br><span class="line">        android:type=&quot;linear&quot;/&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;size</span><br><span class="line">        android:width=&quot;10dp&quot;</span><br><span class="line">        android:height=&quot;10dp&quot;/&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/shape&gt;</span><br></pre></td></tr></table></figure></p><p>运行后效果如下<br><img src="/img/R8.png" alt=""><br><strong>以上的分割线只适用在LinearLayoutManager的相关布局中。</strong><br>对于GridLayoutManager布局是不适用的。需要我们单独写一个。<br><strong>以下是对于GridLayoutManager布局的分割线代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">public class DividerGridViewItemDecoration extends RecyclerView.ItemDecoration &#123;</span><br><span class="line">    private Drawable mDivider;</span><br><span class="line">    private int[] attrs = new int[]&#123;</span><br><span class="line">            android.R.attr.listDivider&#125;;</span><br><span class="line"> </span><br><span class="line">    public DividerGridViewItemDecoration(Context context) &#123;</span><br><span class="line">        TypedArray typedArray = context.obtainStyledAttributes(attrs);</span><br><span class="line">        mDivider = typedArray.getDrawable(0);</span><br><span class="line">        typedArray.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123;</span><br><span class="line">        drawVertical(c, parent);</span><br><span class="line">        drawHorizontal(c, parent);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private void drawVertical(Canvas c, RecyclerView parent) &#123;</span><br><span class="line">        //绘制垂直间隔线（垂直的矩形）</span><br><span class="line">        int childCount = parent.getChildCount();</span><br><span class="line">        for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">            View child = parent.getChildAt(i);</span><br><span class="line">            RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();</span><br><span class="line">            int left = child.getRight() + params.rightMargin;</span><br><span class="line">            int right = left + mDivider.getIntrinsicWidth();</span><br><span class="line">            int top = child.getTop() - params.topMargin;</span><br><span class="line">            int bottom = child.getBottom() + params.bottomMargin;</span><br><span class="line"> </span><br><span class="line">            mDivider.setBounds(left, top, right, bottom);</span><br><span class="line">            mDivider.draw(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private void drawHorizontal(Canvas c, RecyclerView parent) &#123;</span><br><span class="line">        //绘制水平分割线</span><br><span class="line">        int childCount = parent.getChildCount();</span><br><span class="line">        for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">            View child = parent.getChildAt(i);</span><br><span class="line">            RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();</span><br><span class="line">            int left = child.getLeft() - params.leftMargin;</span><br><span class="line">            int right = child.getRight() + params.rightMargin + mDivider.getIntrinsicWidth();</span><br><span class="line">            int top = child.getBottom() + params.bottomMargin;</span><br><span class="line">            int bottom = top + mDivider.getIntrinsicHeight();</span><br><span class="line"> </span><br><span class="line">            mDivider.setBounds(left, top, right, bottom);</span><br><span class="line">            mDivider.draw(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123;</span><br><span class="line">        // 四个方向的偏移值</span><br><span class="line">        int right = mDivider.getIntrinsicWidth();</span><br><span class="line">        int bottom = mDivider.getIntrinsicHeight();</span><br><span class="line"> </span><br><span class="line">        RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) view.getLayoutParams();</span><br><span class="line">        int itemPosition = params.getViewAdapterPosition();</span><br><span class="line">        if (isLastColum(itemPosition, parent)) &#123;</span><br><span class="line">            right = 0;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        if (isLastRow(itemPosition, parent)) &#123;</span><br><span class="line">            bottom = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        outRect.set(0, 0, right, bottom);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 是否最后一行</span><br><span class="line">     */</span><br><span class="line">    private boolean isLastRow(int itemPosition, RecyclerView parent) &#123;</span><br><span class="line">        int spanCount = getSpanCount(parent);</span><br><span class="line">        if (spanCount != -1) &#123;</span><br><span class="line">            int childCount = parent.getAdapter().getItemCount();</span><br><span class="line">            int lastRowCount = childCount % spanCount;</span><br><span class="line">            //最后一行的数量小于spanCount</span><br><span class="line">            if (lastRowCount == 0 || lastRowCount &lt; spanCount) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 根据parent获取到列数</span><br><span class="line">     */</span><br><span class="line">    private int getSpanCount(RecyclerView parent) &#123;</span><br><span class="line">        RecyclerView.LayoutManager layoutManager = parent.getLayoutManager();</span><br><span class="line">        if (layoutManager instanceof GridLayoutManager) &#123;</span><br><span class="line">            GridLayoutManager lm = (GridLayoutManager) layoutManager;</span><br><span class="line">            int spanCount = lm.getSpanCount();</span><br><span class="line">            return spanCount;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 判断是否是最后一列</span><br><span class="line">     */</span><br><span class="line">    private boolean isLastColum(int itemPosition, RecyclerView parent) &#123;</span><br><span class="line">        int spanCount = getSpanCount(parent);</span><br><span class="line">        if (spanCount != -1) &#123;</span><br><span class="line">            if ((itemPosition + 1) % spanCount == 0) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在activity中使用该分割线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mRecyclerView.setLayoutManager(new GridLayoutManager(this, 3));</span><br><span class="line">mRecyclerView.addItemDecoration(new DividerGridViewItemDecoration(this));</span><br></pre></td></tr></table></figure></p><p><img src="/img/R9.png" alt=""></p><h4 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h4><p>RecyclerView并没有像ListView的那样可以设置点击事件以及长按点击事件，这个需要我们可以在adapter中去设置回调的方式实现，具体代码如下：<br>MyRecyclerViewAdapter的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MyRecyclerViewAdapter extends RecyclerView.Adapter&lt;MyRecyclerViewAdapter.ViewHolder&gt; &#123;</span><br><span class="line">    private List&lt;String&gt; list;</span><br><span class="line">    private OnItemClickListener onItemClickListener;</span><br><span class="line">    private OnItemLongClickListener onItemLongClickListener;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 设置点击事件</span><br><span class="line">     */</span><br><span class="line">    public void setOnItemClickListener(OnItemClickListener onItemClickListener) &#123;</span><br><span class="line">        this.onItemClickListener = onItemClickListener;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 设置长按点击事件</span><br><span class="line">     */</span><br><span class="line">    public void setOnItemLongClickListener(OnItemLongClickListener onItemLongClickListener) &#123;</span><br><span class="line">        this.onItemLongClickListener = onItemLongClickListener;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public MyRecyclerViewAdapter(List&lt;String&gt; list) &#123;</span><br><span class="line">        this.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public MyRecyclerViewAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</span><br><span class="line">        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_base_use, parent, false);</span><br><span class="line">        MyRecyclerViewAdapter.ViewHolder viewHolder = new MyRecyclerViewAdapter.ViewHolder(view);</span><br><span class="line">        return viewHolder;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void onBindViewHolder(MyRecyclerViewAdapter.ViewHolder holder, int position) &#123;</span><br><span class="line">        holder.mText.setText(list.get(position));</span><br><span class="line">        int adapterPosition = holder.getAdapterPosition();</span><br><span class="line">        if (onItemClickListener != null) &#123;</span><br><span class="line">            holder.itemView.setOnClickListener(new MyOnClickListener(position, list.get(adapterPosition)));</span><br><span class="line">        &#125;</span><br><span class="line">        if (onItemLongClickListener != null) &#123;</span><br><span class="line">            holder.itemView.setOnLongClickListener(new MyOnLongClickListener(position, list.get(adapterPosition)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public int getItemCount() &#123;</span><br><span class="line">        return list.size();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    class ViewHolder extends RecyclerView.ViewHolder &#123;</span><br><span class="line">        TextView mText;</span><br><span class="line"> </span><br><span class="line">        ViewHolder(View itemView) &#123;</span><br><span class="line">            super(itemView);</span><br><span class="line">            mText = itemView.findViewById(R.id.item_tx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private class MyOnLongClickListener implements View.OnLongClickListener &#123;</span><br><span class="line">        private int position;</span><br><span class="line">        private String data;</span><br><span class="line"> </span><br><span class="line">        public MyOnLongClickListener(int position, String data) &#123;</span><br><span class="line">            this.position = position;</span><br><span class="line">            this.data = data;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        @Override</span><br><span class="line">        public boolean onLongClick(View v) &#123;</span><br><span class="line">            onItemLongClickListener.onItemLongClick(v, position, data);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private class MyOnClickListener implements View.OnClickListener &#123;</span><br><span class="line">        private int position;</span><br><span class="line">        private String data;</span><br><span class="line"> </span><br><span class="line">        public MyOnClickListener(int position, String data) &#123;</span><br><span class="line">            this.position = position;</span><br><span class="line">            this.data = data;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        @Override</span><br><span class="line">        public void onClick(View v) &#123;</span><br><span class="line">            onItemClickListener.onItemClick(v, position, data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    public interface OnItemClickListener &#123;</span><br><span class="line">        void onItemClick(View view, int position, String data);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public interface OnItemLongClickListener &#123;</span><br><span class="line">        void onItemLongClick(View view, int position, String data);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>activity中设置监听：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mAdapter.setOnItemClickListener(new MyRecyclerViewAdapter.OnItemClickListener() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void onItemClick(View view, int position, String data)&#123;</span><br><span class="line">           Toast.makeText(MainActivity.this, &quot;您点击了：  &quot; + data, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> mAdapter.setOnItemLongClickListener(new MyRecyclerViewAdapter.OnItemLongClickListener() &#123;</span><br><span class="line"> @Override</span><br><span class="line">public void onItemLongClick(View view, int position, String data) &#123;</span><br><span class="line">Toast.makeText(MainActivity.this, &quot;您长按点击了：  &quot; + data, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><p><img src="/img/R10.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;RecyclerView&quot;&gt;&lt;a href=&quot;#RecyclerView&quot; class=&quot;headerlink&quot; title=&quot;RecyclerView&quot;&gt;&lt;/a&gt;RecyclerView&lt;/h3&gt;&lt;h4 id=&quot;基本使用&quot;&gt;&lt;a href=&quot;#基本使用&quot; cla
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="初识RecyclerView" scheme="http://yoursite.com/tags/%E5%88%9D%E8%AF%86RecyclerView/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://yoursite.com/2018/07/20/Git%20%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/07/20/Git 指令/</id>
    <published>2018-07-20T04:10:37.825Z</published>
    <updated>2018-07-20T04:10:37.825Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Git-指令"><a href="#Git-指令" class="headerlink" title="Git 指令"></a>Git 指令</h3><p><strong>git init</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在本地新建一个repo,进入一个项目目录,执行git init,会初始化一个repo,并在当前文件夹下创建一个.git文件夹.</span><br></pre></td></tr></table></figure></p><p><strong>git clone</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">获取一个url对应的远程Git repo, 创建一个local copy.</span><br><span class="line">一般的格式是git clone [url].</span><br><span class="line">clone下来的repo会以url最后一个斜线后面的名称命名,创建一个文件夹,如果想要指定特定的名称,可以git clone [url] newname指定.</span><br></pre></td></tr></table></figure></p><p><strong>git status</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查询repo的状态.</span><br><span class="line">git status -s: -s表示short, -s的输出标记会有两列,第一列是对staging区域而言,第二列是对working目录而言.</span><br></pre></td></tr></table></figure></p><p><strong>git log</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">show commit history of a branch.</span><br><span class="line">git log --oneline --number: 每条log只显示一行,显示number条.</span><br><span class="line">git log --oneline --graph:可以图形化地表示出分支合并历史.</span><br><span class="line">git log branchname可以显示特定分支的log.</span><br><span class="line">git log --oneline branch1 ^branch2,可以查看在分支1,却不在分支2中的提交.^表示排除这个分支(Window下可能要给^branch2加上引号).</span><br><span class="line">git log --decorate会显示出tag信息.</span><br><span class="line">git log --author=[author name] 可以指定作者的提交历史.</span><br><span class="line">git log --since --before --until --after 根据提交时间筛选log.</span><br><span class="line">--no-merges可以将merge的commits排除在外.</span><br><span class="line">git log --grep 根据commit信息过滤log: git log --grep=keywords</span><br><span class="line">默认情况下, git log --grep --author是OR的关系,即满足一条即被返回,如果你想让它们是AND的关系,可以加上--all-match的option.</span><br><span class="line">git log -S: filter by introduced diff.</span><br><span class="line">比如: git log -SmethodName (注意S和后面的词之间没有等号分隔).</span><br><span class="line">git log -p: show patch introduced at each commit.</span><br><span class="line">每一个提交都是一个快照(snapshot),Git会把每次提交的diff计算出来,作为一个patch显示给你看.</span><br><span class="line">另一种方法是git show [SHA].</span><br><span class="line">git log --stat: show diffstat of changes introduced at each commit.</span><br><span class="line">同样是用来看改动的相对信息的,--stat比-p的输出更简单一些.</span><br></pre></td></tr></table></figure></p><p><strong>git add</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在提交之前,Git有一个暂存区(staging area),可以放入新添加的文件或者加入新的改动. commit时提交的改动是上一次加入到staging area中的改动,而不是我们disk上的改动.</span><br><span class="line">git add .</span><br><span class="line">会递归地添加当前工作目录中的所有文件.</span><br></pre></td></tr></table></figure></p><p><strong>git diff</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">不加参数的git diff:</span><br><span class="line">show diff of unstaged changes.</span><br><span class="line">此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容.</span><br><span class="line"></span><br><span class="line">若要看已经暂存起来的文件和上次提交时的快照之间的差异,可以用:</span><br><span class="line">git diff --cached 命令.</span><br><span class="line">show diff of staged changes.</span><br><span class="line">(Git 1.6.1 及更高版本还允许使用 git diff --staged，效果是相同的).</span><br><span class="line">git diff HEAD</span><br><span class="line">show diff of all staged or unstated changes.</span><br><span class="line">也即比较woking directory和上次提交之间所有的改动.</span><br><span class="line"></span><br><span class="line">如果想看自从某个版本之后都改动了什么,可以用:</span><br><span class="line">git diff [version tag]</span><br><span class="line">跟log命令一样,diff也可以加上--stat参数来简化输出.</span><br><span class="line"></span><br><span class="line">git diff [branchA] [branchB]可以用来比较两个分支.</span><br><span class="line">它实际上会返回一个由A到B的patch,不是我们想要的结果.</span><br><span class="line">一般我们想要的结果是两个分支分开以后各自的改动都是什么,是由命令:</span><br><span class="line">git diff [branchA]…[branchB]给出的.</span><br><span class="line">实际上它是:git diff $(git merge-base [branchA] [branchB]) [branchB]的结果.</span><br></pre></td></tr></table></figure></p><p><strong>git commit</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提交已经被add进来的改动.</span><br><span class="line">git commit -m “the commit message&quot;</span><br><span class="line">git commit -a 会先把所有已经track的文件的改动add进来,然后提交(有点像svn的一次提交,不用先暂存). 对于没有track的文件,还是需要git add一下.</span><br><span class="line">git commit --amend 增补提交. 会使用与当前提交节点相同的父节点进行一次新的提交,旧的提交将会被取消.</span><br></pre></td></tr></table></figure></p><p><strong>git reset</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">undo changes and commits.</span><br><span class="line">这里的HEAD关键字指的是当前分支最末梢最新的一个提交.也就是版本库中该分支上的最新版本.</span><br><span class="line">git reset HEAD: unstage files from index and reset pointer to HEAD</span><br><span class="line">这个命令用来把不小心add进去的文件从staged状态取出来,可以单独针对某一个文件操作: git reset HEAD - - filename, 这个- - 也可以不加.</span><br><span class="line">git reset --soft</span><br><span class="line">move HEAD to specific commit reference, index and staging are untouched.</span><br><span class="line">git reset --hard</span><br><span class="line">unstage files AND undo any changes in the working directory since last commit.</span><br><span class="line">使用git reset —hard HEAD进行reset,即上次提交之后,所有staged的改动和工作目录的改动都会消失,还原到上次提交的状态.</span><br><span class="line">这里的HEAD可以被写成任何一次提交的SHA-1.</span><br><span class="line">不带soft和hard参数的git reset,实际上带的是默认参数mixed.</span><br><span class="line"></span><br><span class="line">总结:</span><br><span class="line">git reset --mixed id,是将git的HEAD变了(也就是提交记录变了),但文件并没有改变，(也就是working tree并没有改变). 取消了commit和add的内容.</span><br><span class="line">git reset --soft id. 实际上，是git reset –mixed id 后,又做了一次git add.即取消了commit的内容.</span><br><span class="line">git reset --hard id.是将git的HEAD变了,文件也变了.</span><br><span class="line">按改动范围排序如下:</span><br><span class="line">soft (commit) &lt; mixed (commit + add) &lt; hard (commit + add + local working)</span><br></pre></td></tr></table></figure></p><p><strong>git revert</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">反转撤销提交.只要把出错的提交(commit)的名字(reference)作为参数传给命令就可以了.</span><br><span class="line">git revert HEAD: 撤销最近的一个提交.</span><br><span class="line">git revert会创建一个反向的新提交,可以通过参数-n来告诉Git先不要提交.</span><br></pre></td></tr></table></figure></p><p><strong>git rm</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm file: 从staging区移除文件,同时也移除出工作目录.</span><br><span class="line">git rm --cached: 从staging区移除文件,但留在工作目录中.</span><br><span class="line">git rm --cached从功能上等同于git reset HEAD,清除了缓存区,但不动工作目录树.</span><br></pre></td></tr></table></figure></p><p><strong>git clean</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clean是从工作目录中移除没有track的文件.</span><br><span class="line">通常的参数是git clean -df:</span><br><span class="line">-d表示同时移除目录,-f表示force,因为在git的配置文件中, clean.requireForce=true,如果不加-f,clean将会拒绝执行.</span><br></pre></td></tr></table></figure></p><p><strong>git mv</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm - - cached orig; mv orig new; git add new</span><br></pre></td></tr></table></figure></p><p><strong>git stash</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">把当前的改动压入一个栈.</span><br><span class="line">git stash将会把当前目录和index中的所有改动(但不包括未track的文件)压入一个栈,然后留给你一个clean的工作状态,即处于上一次最新提交处.</span><br><span class="line">git stash list会显示这个栈的list.</span><br><span class="line">git stash apply:取出stash中的上一个项目(stash@&#123;0&#125;),并且应用于当前的工作目录.</span><br><span class="line">也可以指定别的项目,比如git stash apply stash@&#123;1&#125;.</span><br><span class="line">如果你在应用stash中项目的同时想要删除它,可以用git stash pop</span><br><span class="line"></span><br><span class="line">删除stash中的项目:</span><br><span class="line">git stash drop: 删除上一个,也可指定参数删除指定的一个项目.</span><br><span class="line">git stash clear: 删除所有项目.</span><br></pre></td></tr></table></figure></p><p><strong>git branch</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git branch可以用来列出分支,创建分支和删除分支.</span><br><span class="line">git branch -v可以看见每一个分支的最后一次提交.</span><br><span class="line">git branch: 列出本地所有分支,当前分支会被星号标示出.</span><br><span class="line">git branch (branchname): 创建一个新的分支(当你用这种方式创建分支的时候,分支是基于你的上一次提交建立的). </span><br><span class="line">git branch -d (branchname): 删除一个分支.</span><br><span class="line">删除remote的分支:</span><br><span class="line">git push (remote-name) :(branch-name): delete a remote branch.</span><br><span class="line">这个是因为完整的命令形式是:</span><br><span class="line">git push remote-name local-branch:remote-branch</span><br><span class="line">而这里local-branch的部分为空,就意味着删除了remote-branch</span><br></pre></td></tr></table></figure></p><p><strong>git checkout</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git checkout（branchname）</span><br><span class="line">切换到一个分支.</span><br><span class="line">git checkout -b (branchname): 创建并切换到新的分支.</span><br><span class="line">这个命令是将git branch newbranch和git checkout newbranch合在一起的结果.</span><br><span class="line">checkout还有另一个作用:替换本地改动:</span><br><span class="line">git checkout --&lt;filename&gt;</span><br><span class="line">此命令会使用HEAD中的最新内容替换掉你的工作目录中的文件.已添加到暂存区的改动以及新文件都不会受到影响.</span><br><span class="line">注意:git checkout filename会删除该文件中所有没有暂存和提交的改动,这个操作是不可逆的.</span><br></pre></td></tr></table></figure></p><p><strong>git merge</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">把一个分支merge进当前的分支.</span><br><span class="line">git merge [alias]/[branch]</span><br><span class="line">把远程分支merge到当前分支.</span><br><span class="line"></span><br><span class="line">如果出现冲突,需要手动修改,可以用git mergetool.</span><br><span class="line">解决冲突的时候可以用到git diff,解决完之后用git add添加,即表示冲突已经被resolved.</span><br></pre></td></tr></table></figure></p><p><strong>git tag</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tag a point in history as import.</span><br><span class="line">会在一个提交上建立永久性的书签,通常是发布一个release版本或者ship了什么东西之后加tag.</span><br><span class="line">比如: git tag v1.0</span><br><span class="line">git tag -a v1.0, -a参数会允许你添加一些信息,即make an annotated tag.</span><br><span class="line">当你运行git tag -a命令的时候,Git会打开一个编辑器让你输入tag信息.</span><br><span class="line"></span><br><span class="line">我们可以利用commit SHA来给一个过去的提交打tag:</span><br><span class="line">git tag -a v0.9 XXXX</span><br><span class="line"></span><br><span class="line">push的时候是不包含tag的,如果想包含,可以在push时加上--tags参数.</span><br><span class="line">fetch的时候,branch HEAD可以reach的tags是自动被fetch下来的, tags that aren’t reachable from branch heads will be skipped.如果想确保所有的tags都被包含进来,需要加上--tags选项.</span><br></pre></td></tr></table></figure></p><p><strong>git remote</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list, add and delete remote repository aliases.</span><br><span class="line">因为不需要每次都用完整的url,所以Git为每一个remote repo的url都建立一个别名,然后用git remote来管理这个list.</span><br><span class="line">git remote: 列出remote aliases.</span><br><span class="line">如果你clone一个project,Git会自动将原来的url添加进来,别名就叫做:origin.</span><br><span class="line">git remote -v:可以看见每一个别名对应的实际url.</span><br><span class="line">git remote add [alias] [url]: 添加一个新的remote repo.</span><br><span class="line">git remote rm [alias]: 删除一个存在的remote alias.</span><br><span class="line">git remote rename [old-alias] [new-alias]: 重命名.</span><br><span class="line">git remote set-url [alias] [url]:更新url. 可以加上—push和fetch参数,为同一个别名set不同的存取地址.</span><br></pre></td></tr></table></figure></p><p><strong>git fetch</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">download new branches and data from a remote repository.</span><br><span class="line">可以git fetch [alias]取某一个远程repo,也可以git fetch --all取到全部repo</span><br><span class="line">fetch将会取到所有你本地没有的数据,所有取下来的分支可以被叫做remote branches,它们和本地分支一样(可以看diff,log等,也可以merge到其他分支),但是Git不允许你checkout到它们.</span><br></pre></td></tr></table></figure></p><p><strong>git pull</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch from a remote repo and try to merge into the current branch.</span><br><span class="line">pull == fetch + merge FETCH_HEAD</span><br><span class="line">git pull会首先执行git fetch,然后执行git merge,把取来的分支的head merge到当前分支.这个merge操作会产生一个新的commit.    </span><br><span class="line">如果使用--rebase参数,它会执行git rebase来取代原来的git merge.</span><br></pre></td></tr></table></figure></p><p><strong>git rebase</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--rebase不会产生合并的提交,它会将本地的所有提交临时保存为补丁(patch),放在”.git/rebase”目录中,然后将当前分支更新到最新的分支尖端,最后把保存的补丁应用到分支上.</span><br><span class="line">rebase的过程中,也许会出现冲突,Git会停止rebase并让你解决冲突,在解决完冲突之后,用git add去更新这些内容,然后无需执行commit,只需要:</span><br><span class="line">git rebase --continue就会继续打余下的补丁.</span><br><span class="line">git rebase --abort将会终止rebase,当前分支将会回到rebase之前的状态.</span><br></pre></td></tr></table></figure></p><p><strong>git push</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push your new branches and data to a remote repository.</span><br><span class="line">git push [alias] [branch]</span><br><span class="line">将会把当前分支merge到alias上的[branch]分支.如果分支已经存在,将会更新,如果不存在,将会添加这个分支.</span><br><span class="line">如果有多个人向同一个remote repo push代码, Git会首先在你试图push的分支上运行git log,检查它的历史中是否能看到server上的branch现在的tip,如果本地历史中不能看到server的tip,说明本地的代码不是最新的,Git会拒绝你的push,让你先fetch,merge,之后再push,这样就保证了所有人的改动都会被考虑进来.</span><br></pre></td></tr></table></figure></p><p><strong>git reflog</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reflog是对reflog进行管理的命令,reflog是git用来记录引用变化的一种机制,比如记录分支的变化或者是HEAD引用的变化.</span><br><span class="line">当git reflog不指定引用的时候,默认列出HEAD的reflog.</span><br><span class="line">HEAD@&#123;0&#125;代表HEAD当前的值,HEAD@&#123;3&#125;代表HEAD在3次变化之前的值.</span><br><span class="line">git会将变化记录到HEAD对应的reflog文件中,其路径为.git/logs/HEAD, 分支的reflog文件都放在.git/logs/refs目录下的子目录中.</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Git-指令&quot;&gt;&lt;a href=&quot;#Git-指令&quot; class=&quot;headerlink&quot; title=&quot;Git 指令&quot;&gt;&lt;/a&gt;Git 指令&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;git init&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>springboot</title>
    <link href="http://yoursite.com/2018/07/20/Tomcat%20%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/07/20/Tomcat 部署项目的三种方法/</id>
    <published>2018-07-20T04:10:37.825Z</published>
    <updated>2018-07-20T04:10:37.825Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/ali.png" alt=""></p><h3 id="Tomcat-部署项目的三种方法"><a href="#Tomcat-部署项目的三种方法" class="headerlink" title="Tomcat 部署项目的三种方法"></a>Tomcat 部署项目的三种方法</h3><p>作者：YSOcean<br>链接：cnblogs.com/ysocean/p/6893446.html</p><h4 id="1、下载-Tomcat-服务器"><a href="#1、下载-Tomcat-服务器" class="headerlink" title="1、下载 Tomcat 服务器"></a>1、下载 Tomcat 服务器</h4><p>官网下载地址：<a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/</a></p><h4 id="2、启动并部署-Tomcat-服务器"><a href="#2、启动并部署-Tomcat-服务器" class="headerlink" title="2、启动并部署 Tomcat 服务器"></a>2、启动并部署 Tomcat 服务器</h4><p>①、解压 tomcat 安装包到一个非中文目录下<br>②、配置环境变量。JAVA_HOME(指向 JDK 安装的根目录)<br>③、双击 apache-tomcat-6.0.16\bin 目录下的 startup.bat，启动服务器(如果一闪而过，那就是没有配置 JAVA_HOME 的环境变量)<br>④、在浏览器中输入 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></p><p><strong>注意：Tomcat 启动不了的时候注意配置 JAVA_HOME:C:\Program Files\Java\jdk1.6.0_43这是安装 JDK的根目录</strong></p><h4 id="3、Tomcat-的目录结构"><a href="#3、Tomcat-的目录结构" class="headerlink" title="3、Tomcat 的目录结构"></a>3、Tomcat 的目录结构</h4><p><img src="/img/tomcat1.png" alt=""></p><h4 id="4、部署项目的第一种方法（项目直接放入-webapps-目录中）"><a href="#4、部署项目的第一种方法（项目直接放入-webapps-目录中）" class="headerlink" title="4、部署项目的第一种方法（项目直接放入 webapps 目录中）"></a>4、部署项目的第一种方法（项目直接放入 webapps 目录中）</h4><p>1、将编写并编译好的web项目(注意要是编译好的，如果是 eclipse，可以将项目打成 war 包放入)，放入到 webapps 中<br><img src="/img/tomcat2.png" alt=""><br>2、启动tomcat服务器（双击 apache-tomcat-6.0.16\bin 目录下的 startup.bat，启动服务器）<br><img src="/img/tomcat3.png" alt=""><br>3、在浏览器输入：<a href="http://localhost:8080/项目名/访问的文件名" target="_blank" rel="noopener">http://localhost:8080/项目名/访问的文件名</a><br><img src="/img/tomcat4.png" alt=""></p><h4 id="5、部署项目的第二种方法（修改-conf-server-xml-文件-）"><a href="#5、部署项目的第二种方法（修改-conf-server-xml-文件-）" class="headerlink" title="5、部署项目的第二种方法（修改 conf/server.xml 文件 ）"></a>5、部署项目的第二种方法（修改 conf/server.xml 文件 ）</h4><p>①、打开tomcat下conf/server.xml，在<host> </host>标签之间输入项目配置信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context path=&quot;/WebProject&quot; docBase=&quot;D:/WebProject&quot; reloadable=&quot;true&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p><strong>path:</strong> 浏览器访问时的路径名<br><strong>docBase:</strong> web项目的WebRoot所在的路径，注意是WebRoot的路径，不是项目的路径。其实也就是编译后的项目<br><strong>reloadble:</strong> 设定项目有改动时，tomcat是否重新加载该项目<br>②、双击 startup.bat，启动 tomcat 服务器，然后在浏览器输入访问的项目名称路径、<br><img src="/img/tomcat5.png" alt=""><br><strong>注意：如果你配置的 path=”/xx”,那么访问的时候就是这样：</strong><br><img src="/img/tomcat6.png" alt=""></p><h4 id="6、部署项目的第三种方法（apache-tomcat-7-0-52-conf-Catalina-localhost-）"><a href="#6、部署项目的第三种方法（apache-tomcat-7-0-52-conf-Catalina-localhost-）" class="headerlink" title="6、部署项目的第三种方法（apache-tomcat-7.0.52\conf\Catalina\localhost ）"></a>6、部署项目的第三种方法（apache-tomcat-7.0.52\conf\Catalina\localhost ）</h4><p>①、进入到 apache-tomcat-7.0.52\conf\Catalina\localhost 目录，新建一个 项目名.xml 文件<br><img src="/img/tomcat7.png" alt=""><br>②、在 那个新建的 xml 文件中，增加下面配置语句（和上面的是一样的,但是不需要 path 配置，加上也没什么用）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context  docBase=&quot;D:/WebProject&quot; reloadable=&quot;true&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/img/tomcat8.png" alt=""><br>③、在浏览器输入路径：localhost:8080/xml文件名/访问的文件名<br><img src="/img/tomcat9.png" alt=""><br>总结：<br>①、第一种方法比较普通，但是我们需要将编译好的项目重新 copy 到 webapps 目录下，多出了两步操作。</p><p>②、第二种方法直接在 server.xml 文件中配置，但是从 tomcat5.0版本开始后，server.xml 文件作为 tomcat 启动的主要配置文件，一旦 tomcat 启动后，便不会再读取这个文件，因此无法再 tomcat 服务启动后发布 web 项目。</p><p>③、第三种方法是最好的，每个项目分开配置，tomcat 将以\conf\Catalina\localhost 目录下的 xml 文件的文件名作为 web 应用的上下文路径，而不再理会 <context>中配置的 path 路径，因此在配置的时候，可以不写 path。</context></p><p>通常我们使用第三种方法.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/img/ali.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Tomcat-部署项目的三种方法&quot;&gt;&lt;a href=&quot;#Tomcat-部署项目的三种方法&quot; class=&quot;headerlink&quot; title=&quot;Tomcat 部署项目的三种方法&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="javaEE" scheme="http://yoursite.com/categories/javaEE/"/>
    
    
      <category term="springboot" scheme="http://yoursite.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot(四)</title>
    <link href="http://yoursite.com/2018/07/20/Spring%20Boot%20%E8%BF%9E%E6%8E%A5MySql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2018/07/20/Spring Boot 连接MySql数据库/</id>
    <published>2018-07-20T04:10:37.825Z</published>
    <updated>2018-07-20T04:10:37.825Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring-Boot-连接MySql数据库"><a href="#Spring-Boot-连接MySql数据库" class="headerlink" title="Spring Boot 连接MySql数据库"></a>Spring Boot 连接MySql数据库</h3><p>Spring Boot可以大大简化持久化任务，几乎不需要写SQL语句，在之前章节“Spring Boot 构建框架”中我们新建了一个Spring Boot应用程序，本章在原有的工程中与数据库建立连接。</p><p>Spring Boot有两种方法与数据库建立连接，一种是使用JdbcTemplate，另一种集成Mybatis，下面分别为大家介绍一下如何集成和使用这两种方式。</p><p><strong>1. 使用JdbcTemplate</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>在resource文件夹下添加application.properties配置文件并输入数据库参数，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/test</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.max-idle=10</span><br><span class="line">spring.datasource.max-wait=1000</span><br><span class="line">spring.datasource.min-idle=5</span><br><span class="line">spring.datasource.initial-size=5</span><br><span class="line">server.port=8012</span><br><span class="line">server.session.timeout=10</span><br><span class="line">server.tomcat.uri-encoding=UTF-8</span><br></pre></td></tr></table></figure></p><p>新建Controller类测试数据库连接，实例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Map.Entry;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/mydb&quot;)</span><br><span class="line">public class DBController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(&quot;/getUsers&quot;)</span><br><span class="line">    public List&lt;Map&lt;String, Object&gt;&gt; getDbType()&#123;</span><br><span class="line">        String sql = &quot;select * from appuser&quot;;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list =  jdbcTemplate.queryForList(sql);</span><br><span class="line">        for (Map&lt;String, Object&gt; map : list) &#123;</span><br><span class="line">            Set&lt;Entry&lt;String, Object&gt;&gt; entries = map.entrySet( );</span><br><span class="line">                if(entries != null) &#123;</span><br><span class="line">                    Iterator&lt;Entry&lt;String, Object&gt;&gt; iterator = entries.iterator( );</span><br><span class="line">                    while(iterator.hasNext( )) &#123;</span><br><span class="line">                    Entry&lt;String, Object&gt; entry =(Entry&lt;String, Object&gt;) iterator.next( );</span><br><span class="line">                    Object key = entry.getKey( );</span><br><span class="line">                    Object value = entry.getValue();</span><br><span class="line">                    System.out.println(key+&quot;:&quot;+value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(&quot;/user/&#123;id&#125;&quot;)</span><br><span class="line">    public Map&lt;String,Object&gt; getUser(@PathVariable String id)&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = null;</span><br><span class="line">        </span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list = getDbType();</span><br><span class="line">        </span><br><span class="line">        for (Map&lt;String, Object&gt; dbmap : list) &#123;</span><br><span class="line">            </span><br><span class="line">            Set&lt;String&gt; set = dbmap.keySet();</span><br><span class="line">            </span><br><span class="line">            for (String key : set) &#123;</span><br><span class="line">                if(key.equals(&quot;id&quot;))&#123;    </span><br><span class="line">                    if(dbmap.get(key).equals(id))&#123;</span><br><span class="line">                        map = dbmap;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(map==null)</span><br><span class="line">            map = list.get(0);</span><br><span class="line">        return map;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行App输入地址输出数据库数据。</p><p><strong>2. 集成Mybatis</strong><br> 添加mybatis依赖，在pom.xml文件中增加如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>在resource文件夹下添加application.properties配置文件并输入数据库参数，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/test</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.max-idle=10</span><br><span class="line">spring.datasource.max-wait=1000</span><br><span class="line">spring.datasource.min-idle=5</span><br><span class="line">spring.datasource.initial-size=5</span><br><span class="line">server.port=8012</span><br><span class="line">server.session.timeout=10</span><br><span class="line">server.tomcat.uri-encoding=UTF-8</span><br></pre></td></tr></table></figure></p><p>依次添加mapper的接口类和xml文件，类分别如下：</p><p><strong>AppMessageMapper.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.util.List;</span><br><span class="line">import com.example.demo.bean.AppMessage;</span><br><span class="line">public interface AppMessageMapper &#123;</span><br><span class="line">    int deleteByPrimaryKey(String id);</span><br><span class="line">    int insert(AppMessage record);</span><br><span class="line">    int insertSelective(AppMessage record);</span><br><span class="line">    AppMessage selectByPrimaryKey(String id);</span><br><span class="line">    int updateByPrimaryKeySelective(AppMessage record);</span><br><span class="line">    int updateByPrimaryKey(AppMessage record);</span><br><span class="line">    </span><br><span class="line">    List&lt;AppMessage&gt; selectAll();</span><br><span class="line">    List&lt;AppMessage&gt; getMessById(String id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>AppMessageMapper.xml</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.example.demo.mapper.AppMessageMapper&quot; &gt;</span><br><span class="line">  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.example.demo.bean.AppMessage&quot; &gt;</span><br><span class="line">    &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;message&quot; property=&quot;message&quot; jdbcType=&quot;VARCHAR&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;senddate&quot; property=&quot;senddate&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;</span><br><span class="line">  &lt;/resultMap&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;sql id=&quot;Base_Column_List&quot; &gt;</span><br><span class="line">    id, message, senddate</span><br><span class="line">  &lt;/sql&gt;</span><br><span class="line">  &lt;select id=&quot;selectByPrimaryKey&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.lang.String&quot; &gt;</span><br><span class="line">    select </span><br><span class="line">    &lt;include refid=&quot;Base_Column_List&quot; /&gt;</span><br><span class="line">    from appuser_message</span><br><span class="line">    where id = #&#123;id,jdbcType=VARCHAR&#125;</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">  &lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;java.lang.String&quot; &gt;</span><br><span class="line">    delete from appuser_message</span><br><span class="line">    where id = #&#123;id,jdbcType=VARCHAR&#125;</span><br><span class="line">  &lt;/delete&gt;</span><br><span class="line">  &lt;insert id=&quot;insert&quot; parameterType=&quot;com.example.demo.bean.AppMessage&quot; &gt;</span><br><span class="line">    insert into appuser_message (id, message, senddate</span><br><span class="line">      )</span><br><span class="line">    values (#&#123;id,jdbcType=VARCHAR&#125;, #&#123;message,jdbcType=VARCHAR&#125;, #&#123;senddate,jdbcType=TIMESTAMP&#125;</span><br><span class="line">      )</span><br><span class="line">  &lt;/insert&gt;</span><br><span class="line">  &lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.example.demo.bean.AppMessage&quot; &gt;</span><br><span class="line">    insert into appuser_message</span><br><span class="line">    &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot; &gt;</span><br><span class="line">      &lt;if test=&quot;id != null&quot; &gt;</span><br><span class="line">        id,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;message != null&quot; &gt;</span><br><span class="line">        message,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;senddate != null&quot; &gt;</span><br><span class="line">        senddate,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">    &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot; &gt;</span><br><span class="line">      &lt;if test=&quot;id != null&quot; &gt;</span><br><span class="line">        #&#123;id,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;message != null&quot; &gt;</span><br><span class="line">        #&#123;message,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;senddate != null&quot; &gt;</span><br><span class="line">        #&#123;senddate,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">  &lt;/insert&gt;</span><br><span class="line">  &lt;update id=&quot;updateByPrimaryKeySelective&quot; parameterType=&quot;com.example.demo.bean.AppMessage&quot; &gt;</span><br><span class="line">    update appuser_message</span><br><span class="line">    &lt;set &gt;</span><br><span class="line">      &lt;if test=&quot;message != null&quot; &gt;</span><br><span class="line">        message = #&#123;message,jdbcType=VARCHAR&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;senddate != null&quot; &gt;</span><br><span class="line">        senddate = #&#123;senddate,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">    where id = #&#123;id,jdbcType=VARCHAR&#125;</span><br><span class="line">  &lt;/update&gt;</span><br><span class="line">  &lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;com.example.demo.bean.AppMessage&quot; &gt;</span><br><span class="line">    update appuser_message</span><br><span class="line">    set message = #&#123;message,jdbcType=VARCHAR&#125;,</span><br><span class="line">      senddate = #&#123;senddate,jdbcType=TIMESTAMP&#125;</span><br><span class="line">    where id = #&#123;id,jdbcType=VARCHAR&#125;</span><br><span class="line">  &lt;/update&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;select id=&quot;selectAll&quot; resultMap=&quot;BaseResultMap&quot;&gt;</span><br><span class="line">    select </span><br><span class="line">         id, message, senddate</span><br><span class="line">    from appuser_message</span><br><span class="line">    order by senddate asc</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;select id=&quot;getMessById&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.lang.String&quot;&gt;</span><br><span class="line">   select </span><br><span class="line">           id, message, senddate</span><br><span class="line">   from </span><br><span class="line">        appuser_message  </span><br><span class="line">       where id = #&#123;id,jdbcType=VARCHAR&#125;</span><br><span class="line">    order by senddate asc  </span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">  </span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></p><p><strong>AppMessage.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line">public class AppMessage &#123;</span><br><span class="line">    private String id;</span><br><span class="line">    private String message;</span><br><span class="line">    private Date senddate;</span><br><span class="line">    public String getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setId(String id) &#123;</span><br><span class="line">        this.id = id == null ? null : id.trim();</span><br><span class="line">    &#125;</span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setMessage(String message) &#123;</span><br><span class="line">        this.message = message == null ? null : message.trim();</span><br><span class="line">    &#125;</span><br><span class="line">    public Date getSenddate() &#123;</span><br><span class="line">        return senddate;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setSenddate(Date senddate) &#123;</span><br><span class="line">        this.senddate = senddate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>AppMessageService.java</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import com.example.demo.bean.AppMessage;</span><br><span class="line">import com.example.demo.mapper.AppMessageMapper;</span><br><span class="line">@Service</span><br><span class="line">public class AppMessageService &#123;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private AppMessageMapper mapper;</span><br><span class="line">    </span><br><span class="line">    public List&lt;AppMessage&gt; getMessage()&#123;</span><br><span class="line">         List&lt;AppMessage&gt; list = new ArrayList&lt;AppMessage&gt;();</span><br><span class="line">         list.add(mapper.selectByPrimaryKey(&quot;xtt&quot;));</span><br><span class="line">         //list = mapper.selectAll();</span><br><span class="line">         return list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public List&lt;AppMessage&gt; getAllMessage()&#123;</span><br><span class="line">         List&lt;AppMessage&gt; list = new ArrayList&lt;AppMessage&gt;();</span><br><span class="line">         list = mapper.selectAll();</span><br><span class="line">         return list;</span><br><span class="line">    &#125;</span><br><span class="line">    public int addMessage(AppMessage appMessage) &#123;</span><br><span class="line">        return mapper.insert(appMessage);</span><br><span class="line">    &#125;</span><br><span class="line">    public List&lt;AppMessage&gt; getMessageById(String id) &#123;</span><br><span class="line">        return mapper.getMessById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    public int delMessage(String id) &#123;</span><br><span class="line">        return mapper.deleteByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>APPMessageController.java</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import java.util.List;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import com.example.demo.bean.AppMessage;</span><br><span class="line">import com.example.demo.service.AppMessageService;</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/appmessage&quot;)</span><br><span class="line">public class APPMessageController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AppMessageService service;</span><br><span class="line">    @RequestMapping(&quot;/getThree&quot;)</span><br><span class="line">    public List&lt;AppMessage&gt; getThreeForMessage()&#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;AppMessage&gt; list = service.getMessage();        </span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(&quot;/getAll&quot;)</span><br><span class="line">    public List&lt;AppMessage&gt; getAllMessage()&#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;AppMessage&gt; list = service.getAllMessage();</span><br><span class="line">        int num = list.size();</span><br><span class="line">        if(null!=list &amp;&amp; num&gt;3)&#123;</span><br><span class="line">            for (int i = 0; i &lt; num-3; i++) &#123;</span><br><span class="line">                list.remove(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    @RequestMapping(&quot;/getByID&quot;)</span><br><span class="line">    public List&lt;AppMessage&gt; getMessageById(@RequestParam(&quot;id&quot;) String id)&#123;</span><br><span class="line">        List&lt;AppMessage&gt; list = service.getMessageById(id);</span><br><span class="line">        int num = list.size();</span><br><span class="line">        if(null!=list &amp;&amp; num&gt;5)&#123;</span><br><span class="line">            for (int i = 0; i &lt; num-5; i++) &#123;</span><br><span class="line">                list.remove(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(value = &quot;/add&quot;,method = RequestMethod.POST) // 或者采用@PostMapping(&quot;/add&quot;)方法，更加节省代码的编写量</span><br><span class="line">    public int addMessage(@RequestBody AppMessage appMessage)&#123;</span><br><span class="line">        return service.addMessage(appMessage);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(value=&quot;/delMessageById&quot;,method=RequestMethod.POST) // 或者采用@PostMapping(&quot;/delMessageById&quot;)方法，更加节省代码的编写量</span><br><span class="line">    public int delMessageById(@RequestParam(&quot;id&quot;) String id)&#123;</span><br><span class="line">            return service.delMessage(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>问题描述</strong><br>SpringBoot扫描包提示找不到mapper的问题，异常信息：<br>Consider defining a bean of type in your configuration</p><p><strong>分析原因</strong><br>Spring Boot项目的Bean装配默认规则是根据Application类所在的包位置从上往下扫描，“Application类”是指Spring Boot项目入口类。如果Application类所在的包为：com.yoodb.blog，则只会扫描com.yoodb.blog包及其所有子包，如果service或dao所在包不在com.yoodb.blog及其子包下，则不会被扫描。</p><p><strong>解决方法</strong><br>方式一：使用注解@ComponentScan(value=”com.yoodb.blog”)，其中，com.yoodb.blog为包路径。<br>方式二：将启动类Application放在上一级包中，注意的是Application启动类必须要保证在包的根目录下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Spring-Boot-连接MySql数据库&quot;&gt;&lt;a href=&quot;#Spring-Boot-连接MySql数据库&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot 连接MySql数据库&quot;&gt;&lt;/a&gt;Spring Boot 连接MySql数
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="Spring Boot 连接MySql数据库" scheme="http://yoursite.com/tags/Spring-Boot-%E8%BF%9E%E6%8E%A5MySql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>javaweb (九 )</title>
    <link href="http://yoursite.com/2018/07/20/%E4%B8%80%E3%80%81HttpServletRequest%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2018/07/20/一、HttpServletRequest介绍/</id>
    <published>2018-07-20T04:10:37.821Z</published>
    <updated>2018-07-20T04:10:37.821Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、HttpServletRequest介绍"><a href="#一、HttpServletRequest介绍" class="headerlink" title="一、HttpServletRequest介绍"></a>一、HttpServletRequest介绍</h3><p>&amp;#8195&amp;#8195HttpServletRequest对象代表客户端的请求，当客户端通过HTTP协议访问服务器时，HTTP请求头中的所有信息都封装在这个对象中，通过这个对象提供的方法，可以获得客户端请求的所有信息。</p><h3 id="二、Request常用方法"><a href="#二、Request常用方法" class="headerlink" title="二、Request常用方法"></a>二、Request常用方法</h3><h4 id="2-1、获得客户机信息"><a href="#2-1、获得客户机信息" class="headerlink" title="2.1、获得客户机信息"></a>2.1、获得客户机信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　getRequestURL方法返回客户端发出请求时的完整URL。</span><br><span class="line">　　getRequestURI方法返回请求行中的资源名部分。</span><br><span class="line">　　getQueryString 方法返回请求行中的参数部分。</span><br><span class="line">　　getPathInfo方法返回请求URL中的额外路径信息。额外路径信息是请求URL中的位于Servlet的路径之后和查询参数之前的内容，它以“/”开头。</span><br><span class="line">　　getRemoteAddr方法返回发出请求的客户机的IP地址。</span><br><span class="line">　　getRemoteHost方法返回发出请求的客户机的完整主机名。</span><br><span class="line">　　getRemotePort方法返回客户机所使用的网络端口号。</span><br><span class="line">　　getLocalAddr方法返回WEB服务器的IP地址。</span><br><span class="line">　　getLocalName方法返回WEB服务器的主机名。</span><br></pre></td></tr></table></figure><p>范例：通过request对象获取客户端请求信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package qgx.request.study;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line">public class RequestDemo1 extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        //1.获取客户机信息</span><br><span class="line">        String requestUrl = req.getRequestURL().toString();//请求的URL地址</span><br><span class="line">        String requestUri = req.getRequestURI();//得到请求的资源</span><br><span class="line">        String queryString = req.getQueryString();//得到请求的URL地址中附带的参数</span><br><span class="line">        String remoteAddr = req.getRemoteAddr();//IP地址</span><br><span class="line">        String remoteHost = req.getRemoteHost();</span><br><span class="line">        int remotePort = req.getRemotePort();</span><br><span class="line">        String remoteUser = req.getRemoteUser();</span><br><span class="line">        String method = req.getMethod();//得到请求URL地址时使用的方法</span><br><span class="line">        String pathInfo = req.getPathInfo();</span><br><span class="line">        String localAddr = req.getLocalAddr();//获取WEB服务器的IP地址</span><br><span class="line">        String localName = req.getLocalName();//获取WEB服务器的主机名</span><br><span class="line">        resp.setCharacterEncoding(&quot;UTF-8&quot;);//设置将字符以&quot;UTF-8&quot;编码输出到客户端浏览器</span><br><span class="line">        //通过设置响应头控制浏览器以UTF-8的编码显示数据，如果不加这句话，那么浏览器显示的将是乱码</span><br><span class="line">       //2.显示数据</span><br><span class="line">        resp.setHeader(&quot;content-type&quot;, &quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        out.write(&quot;获取到的客户机信息如下：&quot;);</span><br><span class="line">        out.write(&quot;&lt;hr/&gt;&quot;);</span><br><span class="line">        out.write(&quot;请求的URL地址：&quot; + requestUrl);</span><br><span class="line">        out.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">        out.write(&quot;请求的资源：&quot; + requestUri);</span><br><span class="line">        out.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">        out.write(&quot;请求的URL地址中附带的参数：&quot; + queryString);</span><br><span class="line">        out.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">        out.write(&quot;来访者的IP地址：&quot; + remoteAddr);</span><br><span class="line">        out.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">        out.write(&quot;来访者的主机名：&quot; + remoteHost);</span><br><span class="line">        out.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">        out.write(&quot;使用的端口号：&quot; + remotePort);</span><br><span class="line">        out.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">        out.write(&quot;remoteUser：&quot; + remoteUser);</span><br><span class="line">        out.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">        out.write(&quot;请求使用的方法：&quot; + method);</span><br><span class="line">        out.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">        out.write(&quot;pathInfo：&quot; + pathInfo);</span><br><span class="line">        out.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">        out.write(&quot;localAddr：&quot; + localAddr);</span><br><span class="line">        out.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">        out.write(&quot;localName：&quot; + localName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/img/request.png" alt=""></p><h4 id="2-2、获得客户机请求头"><a href="#2-2、获得客户机请求头" class="headerlink" title="2.2、获得客户机请求头"></a>2.2、获得客户机请求头</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　getHeader(string name)方法:String </span><br><span class="line">　　getHeaders(String name)方法:Enumeration </span><br><span class="line">　　getHeaderNames()方法</span><br></pre></td></tr></table></figure><p>范例：通过request对象获取客户端请求头信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package qgx.request.study;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.util.Enumeration;</span><br><span class="line"></span><br><span class="line">@WebServlet(name = &quot;RequestDemo2&quot;)</span><br><span class="line">public class RequestDemo2 extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        response.setCharacterEncoding(&quot;UTF-8&quot;);//设置将字符以&quot;UTF-8&quot;编码输出到客户端浏览器</span><br><span class="line">        //通过设置响应头控制浏览器以UTF-8的编码显示数据</span><br><span class="line">        response.setHeader(&quot;content-type&quot;, &quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        Enumeration&lt;String&gt; reqHeadInfos = request.getHeaderNames();//获取所有的请求头</span><br><span class="line">        out.write(&quot;获取到的客户端所有的请求头信息如下：&quot;);</span><br><span class="line">        out.write(&quot;&lt;hr/&gt;&quot;);</span><br><span class="line">        while (reqHeadInfos.hasMoreElements()) &#123;</span><br><span class="line">            String headName = (String) reqHeadInfos.nextElement();</span><br><span class="line">            String headValue = request.getHeader(headName);//根据请求头的名字获取对应的请求头的值</span><br><span class="line">            out.write(headName + &quot;:--------:&quot; + headValue);</span><br><span class="line">            out.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        out.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">        out.write(&quot;获取到的客户端Accept-Encoding请求头的值：&quot;);</span><br><span class="line">        out.write(&quot;&lt;hr/&gt;&quot;);</span><br><span class="line">        String value = request.getHeader(&quot;Accept-Encoding&quot;);//获取Accept-Encoding请求头对应的值</span><br><span class="line">        out.write(value);</span><br><span class="line"></span><br><span class="line">        Enumeration&lt;String&gt; e = request.getHeaders(&quot;Accept-Encoding&quot;);</span><br><span class="line">        while (e.hasMoreElements()) &#123;</span><br><span class="line">            String string = (String) e.nextElement();</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/img/request2.png" alt=""></p><h4 id="获得客户机请求参数-客户端提交的数据"><a href="#获得客户机请求参数-客户端提交的数据" class="headerlink" title="获得客户机请求参数(客户端提交的数据)"></a>获得客户机请求参数(客户端提交的数据)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getParameter(String)方法(常用)</span><br><span class="line">getParameterValues(String name)方法(常用)</span><br><span class="line">getParameterNames()方法(不常用)</span><br><span class="line">getParameterMap()方法(编写框架时常用)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: qgx</span><br><span class="line">  Date: 2018/5/16</span><br><span class="line">  Time: 22:38</span><br><span class="line">  To change this template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Html的From表单元素&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;fieldset style=&quot;width:500px;&quot;&gt;</span><br><span class="line">    &lt;legend&gt;Html的Form表单元素&lt;/legend&gt;</span><br><span class="line">    &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/RequestDemo3&quot; method=&quot;post&quot;&gt;</span><br><span class="line">        编&amp;nbsp;&amp;nbsp;号(文本框)：</span><br><span class="line">        &lt;!--输入文本框，SIZE表示显示长度，maxlength表示最多输入长度--&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;userid&quot; value=&quot;NO.1&quot; size=&quot;2&quot; maxlength=&quot;2&quot;&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;!--输入文本框，通过value指定其显示的默认值--&gt;</span><br><span class="line">        用户名(文本框)：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;刘俭梅&quot;&gt;&lt;br&gt;</span><br><span class="line">        &lt;!--密码框，其中所有输入的内容都以密文的形式显示--&gt;</span><br><span class="line">        密&amp;nbsp;&amp;nbsp;码(密码框)：</span><br><span class="line">        &lt;input type=&quot;password&quot; name=&quot;userpassword&quot; value=&quot;请输入密码&quot;&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;!--单选按钮，通过checked指定默认选中，名称必须一样，其中value为真正需要的内容--&gt;</span><br><span class="line">        性&amp;nbsp;&amp;nbsp;别(单选框)：</span><br><span class="line">        &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; &gt;男</span><br><span class="line">        &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;checked&gt;女</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;!--下拉列表框，通过&lt;option&gt;元素指定下拉的选项--&gt;</span><br><span class="line">        学&amp;nbsp;&amp;nbsp;校(下拉框)：</span><br><span class="line">        &lt;select name=&quot;dept&quot;&gt;</span><br><span class="line">            &lt;option value=&quot;衢州学院&quot;SELECTED&gt;衢州学院&lt;/option&gt;</span><br><span class="line">            &lt;option value=&quot;中北大学&quot; &gt;中北大学&lt;/option&gt;</span><br><span class="line">            &lt;option value=&quot;衢职&quot;&gt;衢职&lt;/option&gt;</span><br><span class="line">        &lt;/select&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;!--复选框，可以同时选择多个选项，名称必须一样，其中value为真正需要的内容--&gt;</span><br><span class="line">        兴&amp;nbsp;&amp;nbsp;趣(复选框)：</span><br><span class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;inst&quot; value=&quot;唱歌&quot; checked&gt;唱歌</span><br><span class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;inst&quot; value=&quot;游泳&quot;&gt;游泳</span><br><span class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;inst&quot; value=&quot;跳舞&quot;&gt;跳舞</span><br><span class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;inst&quot; value=&quot;编程&quot;&gt;编程</span><br><span class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;inst&quot; value=&quot;上网&quot;&gt;上网</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;!--大文本输入框，宽度为34列，高度为5行--&gt;</span><br><span class="line">        备&amp;nbsp;&amp;nbsp;注(文本域)：</span><br><span class="line">        &lt;textarea name=&quot;note&quot; cols=&quot;34&quot; rows=&quot;5&quot;&gt;</span><br><span class="line">     &lt;/textarea&gt;</span><br><span class="line">           &lt;br&gt;</span><br><span class="line">            &lt;!--隐藏域，在页面上无法看到，专门用来传递参数或者保存参数--&gt;</span><br><span class="line">           &lt;input type=&quot;hidden&quot; name=&quot;hiddenField&quot; value=&quot;hiddenvalue&quot;/&gt;</span><br><span class="line">            &lt;!--提交表单按钮，当点击提交后，所有填写的表单内容都会被传输到服务器端--&gt;</span><br><span class="line">             &lt;input type=&quot;submit&quot; value=&quot;提交(提交按钮)&quot;&gt;</span><br><span class="line">            &lt;!--重置表单按钮，当点击重置后，所有表单恢复原始显示内容--&gt;</span><br><span class="line">            &lt;input type=&quot;reset&quot; value=&quot;重置(重置按钮)&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">    &lt;!--表单结束--&gt;</span><br><span class="line">&lt;/fieldset&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="/img/request3.png" alt=""><br>在服务器端使用getParameter方法和getParameterValues方法接收表单参数，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package qgx.request.study;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.text.MessageFormat;</span><br><span class="line"></span><br><span class="line">@WebServlet(name = &quot;RequestDemo3&quot;)</span><br><span class="line">public class RequestDemo3 extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        request.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        String userid = request.getParameter(&quot;userid&quot;);//获取填写的编号</span><br><span class="line">        String username = request.getParameter(&quot;username&quot;);</span><br><span class="line">        String userpass = request.getParameter(&quot;userpass&quot;);</span><br><span class="line">        String sex = request.getParameter(&quot;sex&quot;);//获取选中的性别</span><br><span class="line">        String school = request.getParameter(&quot;school&quot;);//获取选中的学校</span><br><span class="line">        String[] insts = request.getParameterValues(&quot;inst&quot;);</span><br><span class="line">        String note = request.getParameter(&quot;note&quot;);//获取填写的说明信息</span><br><span class="line">        String hiddenField = request.getParameter(&quot;hiddenField&quot;);//获取隐藏域的内容</span><br><span class="line">        String instStr = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 获取数组数据的技巧，可以避免insts数组为null时引发的空指针异常错误！</span><br><span class="line">         */</span><br><span class="line">        for (int i = 0; insts != null &amp;&amp; i &lt; insts.length; i++) &#123;</span><br><span class="line">            if (i == insts.length - 1) &#123;</span><br><span class="line">                instStr += insts[i];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                instStr += insts[i] + &quot;,&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String htmlStr = &quot;&lt;table&gt;&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;&lt;td&gt;填写的编号：&lt;/td&gt;&lt;td&gt;&#123;0&#125;&lt;/td&gt;&lt;/tr&gt;&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;&lt;td&gt;填写的用户名：&lt;/td&gt;&lt;td&gt;&#123;1&#125;&lt;/td&gt;&lt;/tr&gt;&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;&lt;td&gt;填写的密码：&lt;/td&gt;&lt;td&gt;&#123;2&#125;&lt;/td&gt;&lt;/tr&gt;&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;&lt;td&gt;选中的性别：&lt;/td&gt;&lt;td&gt;&#123;3&#125;&lt;/td&gt;&lt;/tr&gt;&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;&lt;td&gt;选中的学校：&lt;/td&gt;&lt;td&gt;&#123;4&#125;&lt;/td&gt;&lt;/tr&gt;&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;&lt;td&gt;选中的兴趣：&lt;/td&gt;&lt;td&gt;&#123;5&#125;&lt;/td&gt;&lt;/tr&gt;&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;&lt;td&gt;填写的说明：&lt;/td&gt;&lt;td&gt;&#123;6&#125;&lt;/td&gt;&lt;/tr&gt;&quot; +</span><br><span class="line">                &quot;&lt;tr&gt;&lt;td&gt;隐藏域的内容：&lt;/td&gt;&lt;td&gt;&#123;7&#125;&lt;/td&gt;&lt;/tr&gt;&quot; +</span><br><span class="line">                &quot;&lt;/table&gt;&quot;;</span><br><span class="line">        htmlStr = MessageFormat.format(htmlStr, userid, username, userpass, sex, school, instStr, note, hiddenField);</span><br><span class="line">        response.setCharacterEncoding(&quot;UTF-8&quot;);//设置服务器端以UTF-8编码输出数据到客户端</span><br><span class="line">        response.setContentType(&quot;text/html;charset=UTF-8&quot;);//设置客户端浏览器以UTF-8编码解析数据</span><br><span class="line">        response.getWriter().write(htmlStr);//输出htmlStr里面的内容到客户端浏览器显示</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/img/request4.png" alt=""></p><h5 id="在服务器端使用getParameterNames方法接收表单参数，代码如下："><a href="#在服务器端使用getParameterNames方法接收表单参数，代码如下：" class="headerlink" title="在服务器端使用getParameterNames方法接收表单参数，代码如下："></a>在服务器端使用getParameterNames方法接收表单参数，代码如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Enumeration&lt;String&gt; paramNames = request.getParameterNames();//获取所有的参数名</span><br><span class="line">        while (paramNames.hasMoreElements()) &#123;</span><br><span class="line">            String name = paramNames.nextElement();//得到参数名</span><br><span class="line">            String value = request.getParameter(name);//通过参数名获取对应的值</span><br><span class="line">            System.out.println(MessageFormat.format(&quot;&#123;0&#125;=&#123;1&#125;&quot;, name,value));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h5 id="在服务器端使用getParameterMap方法接收表单参数，代码如下"><a href="#在服务器端使用getParameterMap方法接收表单参数，代码如下" class="headerlink" title="在服务器端使用getParameterMap方法接收表单参数，代码如下:"></a>在服务器端使用getParameterMap方法接收表单参数，代码如下:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//request对象封装的参数是以Map的形式存储的</span><br><span class="line">        Map&lt;String, String[]&gt; paramMap = request.getParameterMap();</span><br><span class="line">       for(Map.Entry&lt;String, String[]&gt; entry :paramMap.entrySet())&#123;</span><br><span class="line">            String paramName = entry.getKey();</span><br><span class="line">            String paramValue = &quot;&quot;;</span><br><span class="line">            String[] paramValueArr = entry.getValue();</span><br><span class="line">             for (int i = 0; paramValueArr!=null &amp;&amp; i &lt; paramValueArr.length; i++) &#123;</span><br><span class="line">                if (i == paramValueArr.length-1) &#123;</span><br><span class="line">                    paramValue+=paramValueArr[i];</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    paramValue+=paramValueArr[i]+&quot;,&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;             System.out.println(MessageFormat.format(&quot;&#123;0&#125;=&#123;1&#125;&quot;, paramName,paramValue));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="三、request接收表单提交中文参数乱码问题"><a href="#三、request接收表单提交中文参数乱码问题" class="headerlink" title="三、request接收表单提交中文参数乱码问题"></a>三、request接收表单提交中文参数乱码问题</h3><h4 id="3-1、以POST方式提交表单中文参数的乱码问题"><a href="#3-1、以POST方式提交表单中文参数的乱码问题" class="headerlink" title="3.1、以POST方式提交表单中文参数的乱码问题"></a>3.1、以POST方式提交表单中文参数的乱码问题</h4><p>index2.jsp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: qgx</span><br><span class="line">  Date: 2018/5/25</span><br><span class="line">  Time: 22:17</span><br><span class="line">  To change this template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;request接收中文参数乱码问题&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;&lt;%=request.getContextPath()%&gt;/RequestDemo4&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;/&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;post方式提交表单&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/img/request5.png" alt=""><br>服务器端接受代码和结果显示如下：<br><img src="/img/request6.png" alt=""></p><h4 id="3-2、post方式提交中文数据乱码产生的原因和解决办法"><a href="#3-2、post方式提交中文数据乱码产生的原因和解决办法" class="headerlink" title="3.2、post方式提交中文数据乱码产生的原因和解决办法"></a>3.2、post方式提交中文数据乱码产生的原因和解决办法</h4><ul><li>之所以会产生乱码，就是因为服务器和客户端沟通的编码不一致造成的，因此解决的办法是：在客户端和服务器之间设置一个统一的编码，之后就按照此编码进行数据的传输和接收。</li><li>由于客户端是以UTF-8字符编码将表单数据传输到服务器端的，因此服务器也需要设置以UTF-8字符编码进行接收，要想完成此操作，服务器可以直接使用从ServletRequest接口继承而来的”setCharacterEncoding(charset)”方法进行统一的编码设置。修改后的代码如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">       request.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">       String  username = request.getParameter(&quot;userName&quot;);</span><br><span class="line">       System.out.println(&quot;userName&quot;+username);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="/img/request7.png" alt=""></p><h4 id="3-3、以GET方式提交表单中文参数的乱码问题"><a href="#3-3、以GET方式提交表单中文参数的乱码问题" class="headerlink" title="3.3、以GET方式提交表单中文参数的乱码问题"></a>3.3、以GET方式提交表单中文参数的乱码问题</h4><p>index3.jsp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: qgx</span><br><span class="line">  Date: 2018/5/25</span><br><span class="line">  Time: 22:17</span><br><span class="line">  To change this template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;request接收中文参数乱码问题&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;&lt;%=request.getContextPath()%&gt;/RequestDemo4&quot; method=&quot;get&quot;&gt;</span><br><span class="line">    用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;/&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;Get方式提交表单&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/img/request8.png" alt=""><br>那么这个中文乱码问题又该如何解决呢，是否可以通过request.setCharacterEncoding(“UTF-8”);设置服务器以UTF-8的编码进行接收这种方式来解决中文乱码问题呢，注意，对于以get方式传输的中文数据，通过request.setCharacterEncoding(“UTF-8”);这种方式是解决不了中文乱码问题，如下所示：<br><img src="/img/request9.png" alt=""></p><h4 id="3-4、get方式提交中文数据乱码产生的原因和解决办法"><a href="#3-4、get方式提交中文数据乱码产生的原因和解决办法" class="headerlink" title="3.4、get方式提交中文数据乱码产生的原因和解决办法"></a>3.4、get方式提交中文数据乱码产生的原因和解决办法</h4><p>对于以get方式传输的数据，request即使设置了以指定的编码接收数据也是无效的(至于为什么无效我也没有弄明白)，默认的还是使用ISO8859-1这个字符编码来接收数据，客户端以UTF-8的编码传输数据到服务器端，而服务器端的request对象使用的是ISO8859-1这个字符编码来接收数据，服务器和客户端沟通的编码不一致因此才会产生中文乱码的。解决办法：在接收到数据后，先获取request对象以ISO8859-1字符编码接收到的原始数据的字节数组，然后通过字节数组以指定的编码构建字符串，解决乱码问题。<br><img src="/img/request10.png" alt=""></p><h4 id="3-5、以超链接形式传递中文参数的乱码问题"><a href="#3-5、以超链接形式传递中文参数的乱码问题" class="headerlink" title="3.5、以超链接形式传递中文参数的乱码问题"></a>3.5、以超链接形式传递中文参数的乱码问题</h4><ul><li>客户端想传输数据到服务器，可以通过表单提交的形式，也可以通过超链接后面加参数的形式，例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/RequestDemo4?userName=&quot;刘俭梅&quot;&gt;点击&lt;/a&gt;</span><br></pre></td></tr></table></figure></li></ul><p>　　点击超链接，数据是以get的方式传输到服务器的，所以接收中文数据时也会产生中文乱码问题，而解决中文乱码问题的方式与上述的以get方式提交表单中文数据乱码处理问题的方式一致，如下所示：</p><p>1 String name = request.getParameter(“name”);<br>2 name =new String(name.getBytes(“ISO8859-1”), “UTF-8”);<br>　　另外，需要提的一点就是URL地址后面如果跟了中文数据，那么中文参数最好使用URL编码进行处理，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/RequestDemo4?userName=&lt;%=URLEncoder.encode(&quot;刘俭梅&quot;, &quot;UTF-8&quot;)%&gt;&quot;&gt;点击&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><h4 id="3-6、提交中文数据乱码问题总结"><a href="#3-6、提交中文数据乱码问题总结" class="headerlink" title="3.6、提交中文数据乱码问题总结"></a>3.6、提交中文数据乱码问题总结</h4><ul><li><p>1、如果提交方式为post，想不乱码，只需要在服务器端设置request对象的编码即可，客户端以哪种编码提交的，服务器端的request对象就以对应的编码接收，比如客户端是以UTF-8编码提交的，那么服务器端request对象就以UTF-8编码接收(request.setCharacterEncoding(“UTF-8”))</p></li><li><p>2、如果提交方式为get，设置request对象的编码是无效的，request对象还是以默认的ISO8859-1编码接收数据，因此要想不乱码，只能在接收到数据后再手工转换，步骤如下：</p><ul><li><p>1).获取获取客户端提交上来的数据，得到的是乱码字符串,data=”???è?????”<br>String data = request.getParameter(“paramName”); </p></li><li><p>2).查找ISO8859-1码表，得到客户机提交的原始数据的字节数组</p></li></ul></li></ul><p>　　 byte[] source = data.getBytes(“ISO8859-1”); </p><ul><li>3).通过字节数组以指定的编码构建字符串，解决乱码<br>　　 data = new String(source, “UTF-8”);<br>　　通过字节数组以指定的编码构建字符串，这里指定的编码是根据客户端那边提交数据时使用的字符编码来定的，如果是GB2312，那么就设置成data = new String(source, “GB2312”)，如果是UTF-8，那么就设置成data = new String(source, “UTF-8”)<h3 id="四、Request对象实现请求转发"><a href="#四、Request对象实现请求转发" class="headerlink" title="四、Request对象实现请求转发"></a>四、Request对象实现请求转发</h3><h4 id="4-1、请求转发的基本概念"><a href="#4-1、请求转发的基本概念" class="headerlink" title="4.1、请求转发的基本概念"></a>4.1、请求转发的基本概念</h4>请求转发：指一个web资源收到客户端请求后，通知服务器去调用另外一个web资源进行处理。<br>请求转发的应用场景：MVC设计模式<br>在Servlet中实现请求转发的两种方式：<ul><li>1、通过ServletContext的getRequestDispatcher(String path)方法，该方法返回一个RequestDispatcher对象，调用这个对象的forward方法可以实现请求转发。<br>例如：将请求转发的test.jsp页面<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RequestDispatcher reqDispatcher =this.getServletContext().getRequestDispatcher(&quot;/test.jsp&quot;);</span><br><span class="line"> reqDispatcher.forward(request, response);</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>2、通过request对象提供的getRequestDispatche(String path)方法，该方法返回一个RequestDispatcher对象，调用这个对象的forward方法可以实现请求转发。<br>例如：将请求转发的test.jsp页面<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(&quot;/test.jsp&quot;).forward(request, response);</span><br></pre></td></tr></table></figure></li></ul><p>request对象同时也是一个域对象(Map容器)，开发人员通过request对象在实现转发时，把数据通过request对象带给其它web资源处理。</p><p>例如：请求RequestDemo5 Servlet，RequestDemo5将请求转发到test.jsp页面<br>RequestDemo5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package qgx.request.study;</span><br><span class="line"></span><br><span class="line">import javax.servlet.RequestDispatcher;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">@WebServlet(name = &quot;RequestDemo5&quot;)</span><br><span class="line">public class RequestDemo5 extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        String data = &quot;情不知所起，一往而情深&quot;;</span><br><span class="line">        request.setAttribute(&quot;data&quot;, data);</span><br><span class="line">        RequestDispatcher requestDispatcher = this.getServletContext().getRequestDispatcher(&quot;/test.jsp&quot;);</span><br><span class="line">        requestDispatcher.forward(request, response);</span><br><span class="line">//request.setAttribute(&quot;data&quot;,data);</span><br><span class="line">//request.getRequestDispatcher(&quot;/test.jsp&quot;).forward(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>test.jsp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: qgx</span><br><span class="line">  Date: 2018/5/27</span><br><span class="line">  Time: 10:55</span><br><span class="line">  To change this template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Request对象实现请求转发&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">       使用普通方式取出存储在request对象中的数据：</span><br><span class="line">      &lt;h3 style=&quot;color:red;&quot;&gt;&lt;%=(String)request.getAttribute(&quot;data&quot;)%&gt;&lt;/h3&gt;</span><br><span class="line">      使用EL表达式取出存储在request对象中的数据：</span><br><span class="line">      &lt;h3 style=&quot;color:red;&quot;&gt;$&#123;data&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/img/request11.png" alt=""></p><h5 id="request对象作为一个域对象-Map容器-使用时，主要是通过以下的四个方法来操作"><a href="#request对象作为一个域对象-Map容器-使用时，主要是通过以下的四个方法来操作" class="headerlink" title="request对象作为一个域对象(Map容器)使用时，主要是通过以下的四个方法来操作"></a>request对象作为一个域对象(Map容器)使用时，主要是通过以下的四个方法来操作</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setAttribute(String name,Object o)方法，将数据作为request对象的一个属性存放到request对象中，例如：request.setAttribute(&quot;data&quot;, data);</span><br><span class="line">getAttribute(String name)方法，获取request对象的name属性的属性值，例如：request.getAttribute(&quot;data&quot;)</span><br><span class="line">removeAttribute(String name)方法，移除request对象的name属性，例如：request.removeAttribute(&quot;data&quot;)</span><br><span class="line">getAttributeNames方法，获取request对象的所有属性名，返回的是一个，例如：Enumeration&lt;String&gt; attrNames = request.getAttributeNames();</span><br></pre></td></tr></table></figure><p>####4.2、请求重定向和请求转发的区别</p><ul><li>一个web资源收到客户端请求后，通知服务器去调用另外一个web资源进行处理，称之为请求转发/307。</li><li>一个web资源收到客户端请求后，通知浏览器去访问另外一个web资源进行处理，称之为请求重定向/302。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、HttpServletRequest介绍&quot;&gt;&lt;a href=&quot;#一、HttpServletRequest介绍&quot; class=&quot;headerlink&quot; title=&quot;一、HttpServletRequest介绍&quot;&gt;&lt;/a&gt;一、HttpServletRequest
      
    
    </summary>
    
      <category term="javaEE" scheme="http://yoursite.com/categories/javaEE/"/>
    
    
      <category term="HttpServletRequest" scheme="http://yoursite.com/tags/HttpServletRequest/"/>
    
  </entry>
  
</feed>
